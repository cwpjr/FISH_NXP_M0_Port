###################################################################################################
#                                                                                                 #
#     IAR Assembler V8.22.1.15669/W32 for ARM 16/Oct/2023  18:10:05                               #
#     Copyright 1999-2018 IAR Systems AB.                                                         #
#                                                                                                 #
#           Source file   =  C:\Users\owner\Desktop\FISH_NXP_M0_Port\FISH_NXP_M0_IAR.s            #
#           List file     =  C:\Users\owner\Desktop\FISH_NXP_M0_Port\NXP_11xx_32X4_PUBREL\List\FISH_NXP_M0_IAR.lst#
#           Object file   =  C:\Users\owner\Desktop\FISH_NXP_M0_Port\NXP_11xx_32X4_PUBREL\Obj\FISH_NXP_M0_IAR.o#
#           Command line  =  -f C:\Users\owner\AppData\Local\Temp\EW64BE.tmp                      #
#                            (C:\Users\owner\Desktop\FISH_NXP_M0_Port\FISH_NXP_M0_IAR.s           #
#                            -OC:\Users\owner\Desktop\FISH_NXP_M0_Port\NXP_11xx_32X4_PUBREL\Obj   #
#                            -s+ -M<> -w+ -r -DNXP_M0_11xx -DFISH_PubRel_WORDSET                  #
#                            -DNXP_M0_11xx_IRC12_48MHZ -DNXP_M0_032kFlash_4KWrite                 #
#                            -DNXP_M0_004kRam                                                     #
#                            -LC:\Users\owner\Desktop\FISH_NXP_M0_Port\NXP_11xx_32X4_PUBREL\List  #
#                            -cAM -i -t8 -xDI --cpu Cortex-M0 --fpu None                          #
#                            -IC:\Users\owner\Desktop\FISH_NXP_M0_Port\..\FISH_RM_COMMON\         #
#                            -IC:\Users\owner\Desktop\FISH_NXP_M0_Port\..\FISH_RM_COMMON_CODE_CORTEX_M\) #
#                                                                                                 #
###################################################################################################

    1                           // FISH_NXP_M0_IAR.s - FULL WORD
    2                           $FISH_NXP_M0_MAIN_INCLUDES.h
    1                           //------------------------------------------------------------------------------
    2                           // This include begins the .sym file
    3                           $FISH_AUTHOR.h
    1                           FISH_Author_Clyde_W_Phillips_Jr:
    2                           FISH_Copyright_2014_2015:
    3                           FISH_Team_A_Team_Forth:
    4                           FISH_Questions_Welcome:
    5                           FISH_FUNDING_Contributions_NEEDED:
    6                           CWPJR02_at_gmail_dot_com:
    4                           // This include is for generic IAR stuff
    5                           $FISH_IAR.h
    1                           //------------------------------------------------------------------------------
    2                             COL 132           // required for dis-assembly output sanity
    3                           // M0 ISR:
    4                               // Pretty much the same as STM except:
    5                               // intvec placement in ram has to be done thru memory remap.
    6                               // saving of hi registers convoluted because only r0-r5 savable by PUSH.
    7                               // Not saving upper regs (r10-12) worked but shouldnt so they will be saved.
    8                               // use of c coroutines us same stack as isr.
    9                           
   10                           // PUSH in ISR uses cstack so:
   11                               // C_CMSIS_DISABLE_IRQS and C_CMSIS_ENABLE_IRQS wrapper used in:
   12                               // c_64by32div      :NONAME USLASH:
   13                               // c_32by32to64mul  :NONAME USTAR:
   14                           
   15                           // Next step is remap IntVecs to RAM. No VTOR!
   16                           // Cortex-M0 (e.g. NXP LPC11xx) has a memory remap feature on its memory system
   17                           // (not a part of the processor) to allow vector table accesses to be optionally redirected to the
                                 SRAM.
   18                           // On a Cortex-M0 (STM32F0) part, you also can't change the vector table, and the trick there is to
                                 either // map FLASH at zero, or copy a small vector table into RAM, and then map RAM at zero.
   19                           
   20                           // Test:
   21                           // : .ST BEGIN STCTR ? ?KEY UNTIL ;
   22                               // .ST skipping 8 on average
   23                           
   24                           // 0x9D8: 3f b5 50 46 59 46 62 46 07 b4 01 4a 08 ca 98 47 00 0a 00 00 f1 09 00 00 35 68 36 1d 07 bc
                                 82 46 8b 46 94 46 3f bd 00 00 01 06 00 00 18 22 00 00 98 35 00 00 14 19 00 00 ec 09 00 00
   25                           /*
   26                           DOCOL_ISR:
   27                           FM0_SYSTICK_ISR:
   28                                   0x9d8: 0xb53f         PUSH      {R0-R5, LR}
   29                                   MOV     r0, r10
   30                                   0x9da: 0x4650         MOV       R0, R10
   31                                   MOV     r1, r11
   32                                   0x9dc: 0x4659         MOV       R1, R11
   33                                   MOV     r2, r12
   34                                   0x9de: 0x4662         MOV       R2, R12
   35                                   PUSH    {r0-r2}
   36                                   0x9e0: 0xb407         PUSH      {R0-R2}
   37                                   LDR     w, [PC, #0X4] //= MY_LTORG The High Level Target
   38                                   0x9e2: 0x4a01         LDR.N     R2, [PC, #0x4]          ; [0x9e8] NONAME_STCTR_INCR
   39                               NEXT1   // -> SEMIS_ISR RETURN required instead of SEMIS!
   40                                   0x9e4: 0xca08         LDM       R2!, {R3}
   41                               NEXT1   // -> SEMIS_ISR RETURN required instead of SEMIS!
   42                                   0x9e6: 0x4798         BLX       R3
   43                                   0x9e8: 0x00000a00     DC32      NONAME_STCTR_INCR
   44                           MY_LTORG_ISR_SEMIS:
   45                                   0x9ec: 0x000009f1     DC32      2545                    ; 'ñ ..'
   46                               POPr2i  // SEMIS to balance DOCOL!!!
   47                                   0x9f0: 0x6835         LDR       R5, [R6]
   48                               POPr2i  // SEMIS to balance DOCOL!!!
   49                                   0x9f2: 0x1d36         ADDS      R6, R6, #4
   50                                   POP     {r0-r2}
   51                                   0x9f4: 0xbc07         POP       {R0-R2}
   52                                   MOV     r10, r0
   53                                   0x9f6: 0x4682         MOV       R10, R0
   54                                   MOV     r11, r1
   55                                   0x9f8: 0x468b         MOV       R11, R1
   56                                   MOV     r12, r2
   57                                   0x9fa: 0x4694         MOV       R12, R2
   58                                   POP     {r0-r5, pc }
   59                                   0x9fc: 0xbd3f         POP       {R0-R5, PC}
   60                                   0x9fe: 0x0000         MOVS      R0, R0
   61                           NONAME_STCTR_INCR:
   62                                   0xa00: 0x00000601     DC32      DOCOL
   63                                   0xa04: 0x00002218     DC32      ONE
   64                                   0xa08: 0x00003598     DC32      STCTR
   65                                   0xa0c: 0x00001914     DC32      PSTORE
   66                                   0xa10: 0x000009ec     DC32      MY_LTORG_ISR_SEMIS
   67                           
   68                           */
   69                           /*
   70                           Here is one implementation:
   71                           
   72                           void SysTick_Handler(void) {
   73                              msTicks++;
   74                           }
   75                           
   76                           void Slow_SysTick_Handler(void) {
   77                              static int slow;
   78                           
   79                              slow++;
   80                              if((slow%4) == 3) {
   81                                 msTicks++;
   82                                 }
   83                           }
   84                            
   85                           /* Declare pFunc_t as a function pointer to a function with no parameters typedef */
   86                           //   typedef void (*pFunc_t)(void);
   87                           
   88                           /* Declare a pointer to an array of function pointers that points to RAM */
   89                           #define pfRAMVectors ((pFunc_t *)0x10000000)
   90                            
   91                           //int main (void) {
   92                            
   93                           //...
   94                            
   95                             // Step 1: modify linker script to leave 0x200 bytes of RAM free
   96                             // In LPCXpresso this is done in the projectname_Debug_mem.ld file
   97                             // MEMORY
   98                             // {
   99                             //   /* Define each memory region */
  100                             //   MFlash32 (rx) : ORIGIN = 0x0, LENGTH = 0x8000 /* 32k */
  101                             //   RamLoc8 (rwx) : ORIGIN = 0x10000200, LENGTH = 0x1E00 /* 8k */
  102                             // }
  103                            
  104                             // 2: Copy current vectors to RAM.
  105                             // memcpy( destination, source, length in bytes )
  106                           //  memcpy( (void *)0x10000000, (void *)0x00000000, 0x200);
  107                           
  108                             // 3: Modify the vector table- redirect SysTick interrupt
  109                           //  pfRAMVectors[15] = Slow_SysTick_Handler;
  110                           
  111                             // 4: Switch over to modified vector table
  112                           //  LPC_SYSCON->SYSMEMREMAP = 1;
  113                            
  114                           //...
  115                           
  116                           /*
  117                               By default, the flash memory is mapped to address 0x0000 0000.
  118                               When the MAP bits in the SYSMEMREMAP register are set to 0x0 or 0x1,
  119                               the boot ROM or RAM respectively are mapped to the bottom 512 bytes
  120                               of the memory map (addresses 0x0000 0000 to 0x0000 0200). 
  121                           */
    6                           //------------------------------------------------------------------------------
    7                           // Include FISH SYSTEM, REGISTERS, STACK MACRO's and MESSAGES
    8                           $io_NXP_M0+_header.h // from Vic AND MODIFIED FOR 812
    1                           ; 81x EQUates that are new or different from 11xx EQUates.
    2                           ; _81x used where register has a different address
    3                           ; Maintain UM naming convention to distinquish which processor they apply to.
    4                           
    5                           // IO_NXP_M0_Plus_81x_Specific_Equates:
    6                           
    7                           PINASSIGN0      EQU     0x4000C000 ; U0_TXD U0_RXD, U0_CTS_I, U0_RTS_O
    8                           PINASSIGN1      EQU     0x4000C004 ; U0_SCLK, U1_TXD, U1_RXD, U1_RTS_O 
    9                           PINASSIGN2      EQU     0x4000C008 ; U1_CTS_I, U1_SCLK, U2_TXD, U2_RXD
   10                           PINASSIGN3      EQU     0x4000C00C ; U2_RTS_O, U2_CTS_I, U2_SCLK, U2_SCK
   11                           PINASSIGN4      EQU     0x4000C010 ; SPI0
   12                           PINASSIGN5      EQU     0x4000C014 ; SPI1, CTIN_0_I
   13                           PINASSIGN6      EQU     0x4000C018 ; CTIN_1_I, (2&3), CTOUT_0_O
   14                           PINASSIGN7      EQU     0x4000C01C ; CTOUT_1_O, (2&3), I2C_SDA_IO
   15                           PINASSIGN8      EQU     0x4000C020 ; I2C_SCL_IO, ACMP_O_O, CLKOUT, GPIO_INT_BMAT
   16                           
   17                           PINENABLE0      EQU     0x4000C1C0 ; SWDCLK_EN, SWDIO_EN and RESET_EN
   18                           
   19                           DIR0            EQU     0xA0002000 ; Direction for gpio pins
   20                           PIN0            EQU     0xA0002100 ; PIN RW
   21                           
   22                           UARTCLKDIV_81x  EQU     0x40048094 ; 81x address different
   23                           UART0_STAT      EQU     0x40064008 ;
   24                           USART0_RXDAT    EQU     0x40064014 ;
   25                           USART0_TXDAT    EQU     0x4006401C ; 
   26                           UARTFRGDIV      EQU     0x400480F0 ; Common fractional generator divider register
   27                           USART0_BRG      EQU     0x40064020 ; Baud Rate Generator register
   28                           USART0_CFG      EQU     0x40064000 ; USART Configuration register
   29                           
   30                           DEVICE_ID_81x   EQU     0x400483F8 ; Part ID numbers for LPC81x parts
   31                           
   32                           // IO_NXP_M0_11xx_Generic_Equates:
   33                           
   34                           ; 11xx EQUates:
   35                           
   36                           ;
   37                           ;               NVIC
   38                           ;
   39                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
   40                           ;     ----                        ----      -------     --------  ----------- --------
   41                           
   42                           SYST_CSR                EQU     0xE000E010 ; E000E010h
   43                           SYSTICKCSR              EQU     SYST_CSR
   44                           
   45                           ;`SYSTICKCSR.ENABLE`        0xE000E010,        4, base=16,    bitRange=0-0
   46                           ;`SYSTICKCSR.TICKINT`       0xE000E010,        4, base=16,    bitRange=1-1
   47                           ;`SYSTICKCSR.CLKSOURCE`     0xE000E010,        4, base=16,    bitRange=2-2
   48                           ;`SYSTICKCSR.COUNTFLAG`     0xE000E010,        4, base=16,    bitRange=16-16
   49                           
   50                           SYST_RVR                EQU     0xE000E014 ;
   51                           SYSTICKRVR              EQU     SYST_RVR
   52                           
   53                           ;`SYSTICKRVR.RELOAD`        0xE000E014,        4, base=16,    bitRange=0-23
   54                           
   55                           SYST_CVR                EQU     0xE000E018 ;
   56                           SYSTICKCVR              EQU     SYST_CVR
   57                           
   58                           ;`SYSTICKCVR.CURRENT`       0xE000E018,        4, base=16,    bitRange=0-23
   59                           
   60                           SYST_CALIB              EQU     0xE000E01C;
   61                           SYSTICKCALVR            EQU     SYST_CALIB
   62                           
   63                           ;`SYSTICKCALVR.TENMS`       0xE000E01C,        4, base=16,    bitRange=0-23
   64                           ;`SYSTICKCALVR.SKEW`        0xE000E01C,        4, base=16,    bitRange=30-30
   65                           ;`SYSTICKCALVR.NOREF`       0xE000E01C,        4, base=16,    bitRange=31-31
   66                           
   67                           SETENA0                  EQU  0xE000E100
   68                           ;`SETENA0.SETENA0`          0xE000E100,        4, base=16,    bitRange=0-0
   69                           ;`SETENA0.SETENA1`          0xE000E100,        4, base=16,    bitRange=1-1
   70                           ;`SETENA0.SETENA2`          0xE000E100,        4, base=16,    bitRange=2-2
   71                           ;`SETENA0.SETENA3`          0xE000E100,        4, base=16,    bitRange=3-3
   72                           ;`SETENA0.SETENA4`          0xE000E100,        4, base=16,    bitRange=4-4
   73                           ;`SETENA0.SETENA5`          0xE000E100,        4, base=16,    bitRange=5-5
   74                           ;`SETENA0.SETENA6`          0xE000E100,        4, base=16,    bitRange=6-6
   75                           ;`SETENA0.SETENA7`          0xE000E100,        4, base=16,    bitRange=7-7
   76                           ;`SETENA0.SETENA8`          0xE000E100,        4, base=16,    bitRange=8-8
   77                           ;`SETENA0.SETENA9`          0xE000E100,        4, base=16,    bitRange=9-9
   78                           ;`SETENA0.SETENA10`         0xE000E100,        4, base=16,    bitRange=10-10
   79                           ;`SETENA0.SETENA11`         0xE000E100,        4, base=16,    bitRange=11-11
   80                           ;`SETENA0.SETENA12`         0xE000E100,        4, base=16,    bitRange=12-12
   81                           ;`SETENA0.SETENA13`         0xE000E100,        4, base=16,    bitRange=13-13
   82                           ;`SETENA0.SETENA14`         0xE000E100,        4, base=16,    bitRange=14-14
   83                           ;`SETENA0.SETENA15`         0xE000E100,        4, base=16,    bitRange=15-15
   84                           ;`SETENA0.SETENA16`         0xE000E100,        4, base=16,    bitRange=16-16
   85                           ;`SETENA0.SETENA17`         0xE000E100,        4, base=16,    bitRange=17-17
   86                           ;`SETENA0.SETENA18`         0xE000E100,        4, base=16,    bitRange=18-18
   87                           ;`SETENA0.SETENA19`         0xE000E100,        4, base=16,    bitRange=19-19
   88                           ;`SETENA0.SETENA20`         0xE000E100,        4, base=16,    bitRange=20-20
   89                           ;`SETENA0.SETENA21`         0xE000E100,        4, base=16,    bitRange=21-21
   90                           ;`SETENA0.SETENA22`         0xE000E100,        4, base=16,    bitRange=22-22
   91                           ;`SETENA0.SETENA23`         0xE000E100,        4, base=16,    bitRange=23-23
   92                           ;`SETENA0.SETENA24`         0xE000E100,        4, base=16,    bitRange=24-24
   93                           ;`SETENA0.SETENA25`         0xE000E100,        4, base=16,    bitRange=25-25
   94                           ;`SETENA0.SETENA26`         0xE000E100,        4, base=16,    bitRange=26-26
   95                           ;`SETENA0.SETENA27`         0xE000E100,        4, base=16,    bitRange=27-27
   96                           ;`SETENA0.SETENA28`         0xE000E100,        4, base=16,    bitRange=28-28
   97                           ;`SETENA0.SETENA29`         0xE000E100,        4, base=16,    bitRange=29-29
   98                           ;`SETENA0.SETENA30`         0xE000E100,        4, base=16,    bitRange=30-30
   99                           ;`SETENA0.SETENA31`         0xE000E100,        4, base=16,    bitRange=31-31
  100                           
  101                           ISER                     EQU  0xE000E100
  102                           ;`ISER.SETENA0`             0xE000E100,        4, base=16,    bitRange=0-0
  103                           ;`ISER.SETENA1`             0xE000E100,        4, base=16,    bitRange=1-1
  104                           ;`ISER.SETENA2`             0xE000E100,        4, base=16,    bitRange=2-2
  105                           ;`ISER.SETENA3`             0xE000E100,        4, base=16,    bitRange=3-3
  106                           ;`ISER.SETENA4`             0xE000E100,        4, base=16,    bitRange=4-4
  107                           ;`ISER.SETENA5`             0xE000E100,        4, base=16,    bitRange=5-5
  108                           ;`ISER.SETENA6`             0xE000E100,        4, base=16,    bitRange=6-6
  109                           ;`ISER.SETENA7`             0xE000E100,        4, base=16,    bitRange=7-7
  110                           ;`ISER.SETENA8`             0xE000E100,        4, base=16,    bitRange=8-8
  111                           ;`ISER.SETENA9`             0xE000E100,        4, base=16,    bitRange=9-9
  112                           ;`ISER.SETENA10`            0xE000E100,        4, base=16,    bitRange=10-10
  113                           ;`ISER.SETENA11`            0xE000E100,        4, base=16,    bitRange=11-11
  114                           ;`ISER.SETENA12`            0xE000E100,        4, base=16,    bitRange=12-12
  115                           ;`ISER.SETENA13`            0xE000E100,        4, base=16,    bitRange=13-13
  116                           ;`ISER.SETENA14`            0xE000E100,        4, base=16,    bitRange=14-14
  117                           ;`ISER.SETENA15`            0xE000E100,        4, base=16,    bitRange=15-15
  118                           ;`ISER.SETENA16`            0xE000E100,        4, base=16,    bitRange=16-16
  119                           ;`ISER.SETENA17`            0xE000E100,        4, base=16,    bitRange=17-17
  120                           ;`ISER.SETENA18`            0xE000E100,        4, base=16,    bitRange=18-18
  121                           ;`ISER.SETENA19`            0xE000E100,        4, base=16,    bitRange=19-19
  122                           ;`ISER.SETENA20`            0xE000E100,        4, base=16,    bitRange=20-20
  123                           ;`ISER.SETENA21`            0xE000E100,        4, base=16,    bitRange=21-21
  124                           ;`ISER.SETENA22`            0xE000E100,        4, base=16,    bitRange=22-22
  125                           ;`ISER.SETENA23`            0xE000E100,        4, base=16,    bitRange=23-23
  126                           ;`ISER.SETENA24`            0xE000E100,        4, base=16,    bitRange=24-24
  127                           ;`ISER.SETENA25`            0xE000E100,        4, base=16,    bitRange=25-25
  128                           ;`ISER.SETENA26`            0xE000E100,        4, base=16,    bitRange=26-26
  129                           ;`ISER.SETENA27`            0xE000E100,        4, base=16,    bitRange=27-27
  130                           ;`ISER.SETENA28`            0xE000E100,        4, base=16,    bitRange=28-28
  131                           ;`ISER.SETENA29`            0xE000E100,        4, base=16,    bitRange=29-29
  132                           ;`ISER.SETENA30`            0xE000E100,        4, base=16,    bitRange=30-30
  133                           ;`ISER.SETENA31`            0xE000E100,        4, base=16,    bitRange=31-31
  134                           
  135                           CLRENA0                  EQU  0xE000E180
  136                           ;`CLRENA0.CLRENA0`          0xE000E180,        4, base=16,    bitRange=0-0
  137                           ;`CLRENA0.CLRENA1`          0xE000E180,        4, base=16,    bitRange=1-1
  138                           ;`CLRENA0.CLRENA2`          0xE000E180,        4, base=16,    bitRange=2-2
  139                           ;`CLRENA0.CLRENA3`          0xE000E180,        4, base=16,    bitRange=3-3
  140                           ;`CLRENA0.CLRENA4`          0xE000E180,        4, base=16,    bitRange=4-4
  141                           ;`CLRENA0.CLRENA5`          0xE000E180,        4, base=16,    bitRange=5-5
  142                           ;`CLRENA0.CLRENA6`          0xE000E180,        4, base=16,    bitRange=6-6
  143                           ;`CLRENA0.CLRENA7`          0xE000E180,        4, base=16,    bitRange=7-7
  144                           ;`CLRENA0.CLRENA8`          0xE000E180,        4, base=16,    bitRange=8-8
  145                           ;`CLRENA0.CLRENA9`          0xE000E180,        4, base=16,    bitRange=9-9
  146                           ;`CLRENA0.CLRENA10`         0xE000E180,        4, base=16,    bitRange=10-10
  147                           ;`CLRENA0.CLRENA11`         0xE000E180,        4, base=16,    bitRange=11-11
  148                           ;`CLRENA0.CLRENA12`         0xE000E180,        4, base=16,    bitRange=12-12
  149                           ;`CLRENA0.CLRENA13`         0xE000E180,        4, base=16,    bitRange=13-13
  150                           ;`CLRENA0.CLRENA14`         0xE000E180,        4, base=16,    bitRange=14-14
  151                           ;`CLRENA0.CLRENA15`         0xE000E180,        4, base=16,    bitRange=15-15
  152                           ;`CLRENA0.CLRENA16`         0xE000E180,        4, base=16,    bitRange=16-16
  153                           ;`CLRENA0.CLRENA17`         0xE000E180,        4, base=16,    bitRange=17-17
  154                           ;`CLRENA0.CLRENA18`         0xE000E180,        4, base=16,    bitRange=18-18
  155                           ;`CLRENA0.CLRENA19`         0xE000E180,        4, base=16,    bitRange=19-19
  156                           ;`CLRENA0.CLRENA20`         0xE000E180,        4, base=16,    bitRange=20-20
  157                           ;`CLRENA0.CLRENA21`         0xE000E180,        4, base=16,    bitRange=21-21
  158                           ;`CLRENA0.CLRENA22`         0xE000E180,        4, base=16,    bitRange=22-22
  159                           ;`CLRENA0.CLRENA23`         0xE000E180,        4, base=16,    bitRange=23-23
  160                           ;`CLRENA0.CLRENA24`         0xE000E180,        4, base=16,    bitRange=24-24
  161                           ;`CLRENA0.CLRENA25`         0xE000E180,        4, base=16,    bitRange=25-25
  162                           ;`CLRENA0.CLRENA26`         0xE000E180,        4, base=16,    bitRange=26-26
  163                           ;`CLRENA0.CLRENA27`         0xE000E180,        4, base=16,    bitRange=27-27
  164                           ;`CLRENA0.CLRENA28`         0xE000E180,        4, base=16,    bitRange=28-28
  165                           ;`CLRENA0.CLRENA29`         0xE000E180,        4, base=16,    bitRange=29-29
  166                           ;`CLRENA0.CLRENA30`         0xE000E180,        4, base=16,    bitRange=30-30
  167                           ;`CLRENA0.CLRENA31`         0xE000E180,        4, base=16,    bitRange=31-31
  168                           
  169                           ICER                     EQU  0xE000E180
  170                           ;`ICER.CLRENA0`             0xE000E180,        4, base=16,    bitRange=0-0
  171                           ;`ICER.CLRENA1`             0xE000E180,        4, base=16,    bitRange=1-1
  172                           ;`ICER.CLRENA2`             0xE000E180,        4, base=16,    bitRange=2-2
  173                           ;`ICER.CLRENA3`             0xE000E180,        4, base=16,    bitRange=3-3
  174                           ;`ICER.CLRENA4`             0xE000E180,        4, base=16,    bitRange=4-4
  175                           ;`ICER.CLRENA5`             0xE000E180,        4, base=16,    bitRange=5-5
  176                           ;`ICER.CLRENA6`             0xE000E180,        4, base=16,    bitRange=6-6
  177                           ;`ICER.CLRENA7`             0xE000E180,        4, base=16,    bitRange=7-7
  178                           ;`ICER.CLRENA8`             0xE000E180,        4, base=16,    bitRange=8-8
  179                           ;`ICER.CLRENA9`             0xE000E180,        4, base=16,    bitRange=9-9
  180                           ;`ICER.CLRENA10`            0xE000E180,        4, base=16,    bitRange=10-10
  181                           ;`ICER.CLRENA11`            0xE000E180,        4, base=16,    bitRange=11-11
  182                           ;`ICER.CLRENA12`            0xE000E180,        4, base=16,    bitRange=12-12
  183                           ;`ICER.CLRENA13`            0xE000E180,        4, base=16,    bitRange=13-13
  184                           ;`ICER.CLRENA14`            0xE000E180,        4, base=16,    bitRange=14-14
  185                           ;`ICER.CLRENA15`            0xE000E180,        4, base=16,    bitRange=15-15
  186                           ;`ICER.CLRENA16`            0xE000E180,        4, base=16,    bitRange=16-16
  187                           ;`ICER.CLRENA17`            0xE000E180,        4, base=16,    bitRange=17-17
  188                           ;`ICER.CLRENA18`            0xE000E180,        4, base=16,    bitRange=18-18
  189                           ;`ICER.CLRENA19`            0xE000E180,        4, base=16,    bitRange=19-19
  190                           ;`ICER.CLRENA20`            0xE000E180,        4, base=16,    bitRange=20-20
  191                           ;`ICER.CLRENA21`            0xE000E180,        4, base=16,    bitRange=21-21
  192                           ;`ICER.CLRENA22`            0xE000E180,        4, base=16,    bitRange=22-22
  193                           ;`ICER.CLRENA23`            0xE000E180,        4, base=16,    bitRange=23-23
  194                           ;`ICER.CLRENA24`            0xE000E180,        4, base=16,    bitRange=24-24
  195                           ;`ICER.CLRENA25`            0xE000E180,        4, base=16,    bitRange=25-25
  196                           ;`ICER.CLRENA26`            0xE000E180,        4, base=16,    bitRange=26-26
  197                           ;`ICER.CLRENA27`            0xE000E180,        4, base=16,    bitRange=27-27
  198                           ;`ICER.CLRENA28`            0xE000E180,        4, base=16,    bitRange=28-28
  199                           ;`ICER.CLRENA29`            0xE000E180,        4, base=16,    bitRange=29-29
  200                           ;`ICER.CLRENA30`            0xE000E180,        4, base=16,    bitRange=30-30
  201                           ;`ICER.CLRENA31`            0xE000E180,        4, base=16,    bitRange=31-31
  202                           
  203                           SETPEND0                 EQU  0xE000E200
  204                           ;`SETPEND0.SETPEND0`        0xE000E200,        4, base=16,    bitRange=0-0
  205                           ;`SETPEND0.SETPEND1`        0xE000E200,        4, base=16,    bitRange=1-1
  206                           ;`SETPEND0.SETPEND2`        0xE000E200,        4, base=16,    bitRange=2-2
  207                           ;`SETPEND0.SETPEND3`        0xE000E200,        4, base=16,    bitRange=3-3
  208                           ;`SETPEND0.SETPEND4`        0xE000E200,        4, base=16,    bitRange=4-4
  209                           ;`SETPEND0.SETPEND5`        0xE000E200,        4, base=16,    bitRange=5-5
  210                           ;`SETPEND0.SETPEND6`        0xE000E200,        4, base=16,    bitRange=6-6
  211                           ;`SETPEND0.SETPEND7`        0xE000E200,        4, base=16,    bitRange=7-7
  212                           ;`SETPEND0.SETPEND8`        0xE000E200,        4, base=16,    bitRange=8-8
  213                           ;`SETPEND0.SETPEND9`        0xE000E200,        4, base=16,    bitRange=9-9
  214                           ;`SETPEND0.SETPEND10`       0xE000E200,        4, base=16,    bitRange=10-10
  215                           ;`SETPEND0.SETPEND11`       0xE000E200,        4, base=16,    bitRange=11-11
  216                           ;`SETPEND0.SETPEND12`       0xE000E200,        4, base=16,    bitRange=12-12
  217                           ;`SETPEND0.SETPEND13`       0xE000E200,        4, base=16,    bitRange=13-13
  218                           ;`SETPEND0.SETPEND14`       0xE000E200,        4, base=16,    bitRange=14-14
  219                           ;`SETPEND0.SETPEND15`       0xE000E200,        4, base=16,    bitRange=15-15
  220                           ;`SETPEND0.SETPEND16`       0xE000E200,        4, base=16,    bitRange=16-16
  221                           ;`SETPEND0.SETPEND17`       0xE000E200,        4, base=16,    bitRange=17-17
  222                           ;`SETPEND0.SETPEND18`       0xE000E200,        4, base=16,    bitRange=18-18
  223                           ;`SETPEND0.SETPEND19`       0xE000E200,        4, base=16,    bitRange=19-19
  224                           ;`SETPEND0.SETPEND20`       0xE000E200,        4, base=16,    bitRange=20-20
  225                           ;`SETPEND0.SETPEND21`       0xE000E200,        4, base=16,    bitRange=21-21
  226                           ;`SETPEND0.SETPEND22`       0xE000E200,        4, base=16,    bitRange=22-22
  227                           ;`SETPEND0.SETPEND23`       0xE000E200,        4, base=16,    bitRange=23-23
  228                           ;`SETPEND0.SETPEND24`       0xE000E200,        4, base=16,    bitRange=24-24
  229                           ;`SETPEND0.SETPEND25`       0xE000E200,        4, base=16,    bitRange=25-25
  230                           ;`SETPEND0.SETPEND26`       0xE000E200,        4, base=16,    bitRange=26-26
  231                           ;`SETPEND0.SETPEND27`       0xE000E200,        4, base=16,    bitRange=27-27
  232                           ;`SETPEND0.SETPEND28`       0xE000E200,        4, base=16,    bitRange=28-28
  233                           ;`SETPEND0.SETPEND29`       0xE000E200,        4, base=16,    bitRange=29-29
  234                           ;`SETPEND0.SETPEND30`       0xE000E200,        4, base=16,    bitRange=30-30
  235                           ;`SETPEND0.SETPEND31`       0xE000E200,        4, base=16,    bitRange=31-31
  236                           
  237                           ISPR                     EQU  0xE000E200
  238                           ;`ISPR.SETPEND0`            0xE000E200,        4, base=16,    bitRange=0-0
  239                           ;`ISPR.SETPEND1`            0xE000E200,        4, base=16,    bitRange=1-1
  240                           ;`ISPR.SETPEND2`            0xE000E200,        4, base=16,    bitRange=2-2
  241                           ;`ISPR.SETPEND3`            0xE000E200,        4, base=16,    bitRange=3-3
  242                           ;`ISPR.SETPEND4`            0xE000E200,        4, base=16,    bitRange=4-4
  243                           ;`ISPR.SETPEND5`            0xE000E200,        4, base=16,    bitRange=5-5
  244                           ;`ISPR.SETPEND6`            0xE000E200,        4, base=16,    bitRange=6-6
  245                           ;`ISPR.SETPEND7`            0xE000E200,        4, base=16,    bitRange=7-7
  246                           ;`ISPR.SETPEND8`            0xE000E200,        4, base=16,    bitRange=8-8
  247                           ;`ISPR.SETPEND9`            0xE000E200,        4, base=16,    bitRange=9-9
  248                           ;`ISPR.SETPEND10`           0xE000E200,        4, base=16,    bitRange=10-10
  249                           ;`ISPR.SETPEND11`           0xE000E200,        4, base=16,    bitRange=11-11
  250                           ;`ISPR.SETPEND12`           0xE000E200,        4, base=16,    bitRange=12-12
  251                           ;`ISPR.SETPEND13`           0xE000E200,        4, base=16,    bitRange=13-13
  252                           ;`ISPR.SETPEND14`           0xE000E200,        4, base=16,    bitRange=14-14
  253                           ;`ISPR.SETPEND15`           0xE000E200,        4, base=16,    bitRange=15-15
  254                           ;`ISPR.SETPEND16`           0xE000E200,        4, base=16,    bitRange=16-16
  255                           ;`ISPR.SETPEND17`           0xE000E200,        4, base=16,    bitRange=17-17
  256                           ;`ISPR.SETPEND18`           0xE000E200,        4, base=16,    bitRange=18-18
  257                           ;`ISPR.SETPEND19`           0xE000E200,        4, base=16,    bitRange=19-19
  258                           ;`ISPR.SETPEND20`           0xE000E200,        4, base=16,    bitRange=20-20
  259                           ;`ISPR.SETPEND21`           0xE000E200,        4, base=16,    bitRange=21-21
  260                           ;`ISPR.SETPEND22`           0xE000E200,        4, base=16,    bitRange=22-22
  261                           ;`ISPR.SETPEND23`           0xE000E200,        4, base=16,    bitRange=23-23
  262                           ;`ISPR.SETPEND24`           0xE000E200,        4, base=16,    bitRange=24-24
  263                           ;`ISPR.SETPEND25`           0xE000E200,        4, base=16,    bitRange=25-25
  264                           ;`ISPR.SETPEND26`           0xE000E200,        4, base=16,    bitRange=26-26
  265                           ;`ISPR.SETPEND27`           0xE000E200,        4, base=16,    bitRange=27-27
  266                           ;`ISPR.SETPEND28`           0xE000E200,        4, base=16,    bitRange=28-28
  267                           ;`ISPR.SETPEND29`           0xE000E200,        4, base=16,    bitRange=29-29
  268                           ;`ISPR.SETPEND30`           0xE000E200,        4, base=16,    bitRange=30-30
  269                           ;`ISPR.SETPEND31`           0xE000E200,        4, base=16,    bitRange=31-31
  270                           
  271                           CLRPEND0                 EQU  0xE000E280
  272                           ;`CLRPEND0.CLRPEND0`        0xE000E280,        4, base=16,    bitRange=0-0
  273                           ;`CLRPEND0.CLRPEND1`        0xE000E280,        4, base=16,    bitRange=1-1
  274                           ;`CLRPEND0.CLRPEND2`        0xE000E280,        4, base=16,    bitRange=2-2
  275                           ;`CLRPEND0.CLRPEND3`        0xE000E280,        4, base=16,    bitRange=3-3
  276                           ;`CLRPEND0.CLRPEND4`        0xE000E280,        4, base=16,    bitRange=4-4
  277                           ;`CLRPEND0.CLRPEND5`        0xE000E280,        4, base=16,    bitRange=5-5
  278                           ;`CLRPEND0.CLRPEND6`        0xE000E280,        4, base=16,    bitRange=6-6
  279                           ;`CLRPEND0.CLRPEND7`        0xE000E280,        4, base=16,    bitRange=7-7
  280                           ;`CLRPEND0.CLRPEND8`        0xE000E280,        4, base=16,    bitRange=8-8
  281                           ;`CLRPEND0.CLRPEND9`        0xE000E280,        4, base=16,    bitRange=9-9
  282                           ;`CLRPEND0.CLRPEND10`       0xE000E280,        4, base=16,    bitRange=10-10
  283                           ;`CLRPEND0.CLRPEND11`       0xE000E280,        4, base=16,    bitRange=11-11
  284                           ;`CLRPEND0.CLRPEND12`       0xE000E280,        4, base=16,    bitRange=12-12
  285                           ;`CLRPEND0.CLRPEND13`       0xE000E280,        4, base=16,    bitRange=13-13
  286                           ;`CLRPEND0.CLRPEND14`       0xE000E280,        4, base=16,    bitRange=14-14
  287                           ;`CLRPEND0.CLRPEND15`       0xE000E280,        4, base=16,    bitRange=15-15
  288                           ;`CLRPEND0.CLRPEND16`       0xE000E280,        4, base=16,    bitRange=16-16
  289                           ;`CLRPEND0.CLRPEND17`       0xE000E280,        4, base=16,    bitRange=17-17
  290                           ;`CLRPEND0.CLRPEND18`       0xE000E280,        4, base=16,    bitRange=18-18
  291                           ;`CLRPEND0.CLRPEND19`       0xE000E280,        4, base=16,    bitRange=19-19
  292                           ;`CLRPEND0.CLRPEND20`       0xE000E280,        4, base=16,    bitRange=20-20
  293                           ;`CLRPEND0.CLRPEND21`       0xE000E280,        4, base=16,    bitRange=21-21
  294                           ;`CLRPEND0.CLRPEND22`       0xE000E280,        4, base=16,    bitRange=22-22
  295                           ;`CLRPEND0.CLRPEND23`       0xE000E280,        4, base=16,    bitRange=23-23
  296                           ;`CLRPEND0.CLRPEND24`       0xE000E280,        4, base=16,    bitRange=24-24
  297                           ;`CLRPEND0.CLRPEND25`       0xE000E280,        4, base=16,    bitRange=25-25
  298                           ;`CLRPEND0.CLRPEND26`       0xE000E280,        4, base=16,    bitRange=26-26
  299                           ;`CLRPEND0.CLRPEND27`       0xE000E280,        4, base=16,    bitRange=27-27
  300                           ;`CLRPEND0.CLRPEND28`       0xE000E280,        4, base=16,    bitRange=28-28
  301                           ;`CLRPEND0.CLRPEND29`       0xE000E280,        4, base=16,    bitRange=29-29
  302                           ;`CLRPEND0.CLRPEND30`       0xE000E280,        4, base=16,    bitRange=30-30
  303                           ;`CLRPEND0.CLRPEND31`       0xE000E280,        4, base=16,    bitRange=31-31
  304                           
  305                           ICPR                     EQU  0xE000E280
  306                           ;`ICPR.CLRPEND0`            0xE000E280,        4, base=16,    bitRange=0-0
  307                           ;`ICPR.CLRPEND1`            0xE000E280,        4, base=16,    bitRange=1-1
  308                           ;`ICPR.CLRPEND2`            0xE000E280,        4, base=16,    bitRange=2-2
  309                           ;`ICPR.CLRPEND3`            0xE000E280,        4, base=16,    bitRange=3-3
  310                           ;`ICPR.CLRPEND4`            0xE000E280,        4, base=16,    bitRange=4-4
  311                           ;`ICPR.CLRPEND5`            0xE000E280,        4, base=16,    bitRange=5-5
  312                           ;`ICPR.CLRPEND6`            0xE000E280,        4, base=16,    bitRange=6-6
  313                           ;`ICPR.CLRPEND7`            0xE000E280,        4, base=16,    bitRange=7-7
  314                           ;`ICPR.CLRPEND8`            0xE000E280,        4, base=16,    bitRange=8-8
  315                           ;`ICPR.CLRPEND9`            0xE000E280,        4, base=16,    bitRange=9-9
  316                           ;`ICPR.CLRPEND10`           0xE000E280,        4, base=16,    bitRange=10-10
  317                           ;`ICPR.CLRPEND11`           0xE000E280,        4, base=16,    bitRange=11-11
  318                           ;`ICPR.CLRPEND12`           0xE000E280,        4, base=16,    bitRange=12-12
  319                           ;`ICPR.CLRPEND13`           0xE000E280,        4, base=16,    bitRange=13-13
  320                           ;`ICPR.CLRPEND14`           0xE000E280,        4, base=16,    bitRange=14-14
  321                           ;`ICPR.CLRPEND15`           0xE000E280,        4, base=16,    bitRange=15-15
  322                           ;`ICPR.CLRPEND16`           0xE000E280,        4, base=16,    bitRange=16-16
  323                           ;`ICPR.CLRPEND17`           0xE000E280,        4, base=16,    bitRange=17-17
  324                           ;`ICPR.CLRPEND18`           0xE000E280,        4, base=16,    bitRange=18-18
  325                           ;`ICPR.CLRPEND19`           0xE000E280,        4, base=16,    bitRange=19-19
  326                           ;`ICPR.CLRPEND20`           0xE000E280,        4, base=16,    bitRange=20-20
  327                           ;`ICPR.CLRPEND21`           0xE000E280,        4, base=16,    bitRange=21-21
  328                           ;`ICPR.CLRPEND22`           0xE000E280,        4, base=16,    bitRange=22-22
  329                           ;`ICPR.CLRPEND23`           0xE000E280,        4, base=16,    bitRange=23-23
  330                           ;`ICPR.CLRPEND24`           0xE000E280,        4, base=16,    bitRange=24-24
  331                           ;`ICPR.CLRPEND25`           0xE000E280,        4, base=16,    bitRange=25-25
  332                           ;`ICPR.CLRPEND26`           0xE000E280,        4, base=16,    bitRange=26-26
  333                           ;`ICPR.CLRPEND27`           0xE000E280,        4, base=16,    bitRange=27-27
  334                           ;`ICPR.CLRPEND28`           0xE000E280,        4, base=16,    bitRange=28-28
  335                           ;`ICPR.CLRPEND29`           0xE000E280,        4, base=16,    bitRange=29-29
  336                           ;`ICPR.CLRPEND30`           0xE000E280,        4, base=16,    bitRange=30-30
  337                           ;`ICPR.CLRPEND31`           0xE000E280,        4, base=16,    bitRange=31-31
  338                           
  339                           IP0                      EQU  0xE000E400
  340                           ;`IP0.PRI_0`                0xE000E400,        4, base=16,    bitRange=0-7
  341                           ;`IP0.PRI_1`                0xE000E400,        4, base=16,    bitRange=8-15
  342                           ;`IP0.PRI_2`                0xE000E400,        4, base=16,    bitRange=16-23
  343                           ;`IP0.PRI_3`                0xE000E400,        4, base=16,    bitRange=24-31
  344                           
  345                           IP1                      EQU  0xE000E404
  346                           ;`IP1.PRI_4`                0xE000E404,        4, base=16,    bitRange=0-7
  347                           ;`IP1.PRI_5`                0xE000E404,        4, base=16,    bitRange=8-15
  348                           ;`IP1.PRI_6`                0xE000E404,        4, base=16,    bitRange=16-23
  349                           ;`IP1.PRI_7`                0xE000E404,        4, base=16,    bitRange=24-31
  350                           
  351                           IP2                      EQU  0xE000E408
  352                           ;`IP2.PRI_8`                0xE000E408,        4, base=16,    bitRange=0-7
  353                           ;`IP2.PRI_9`                0xE000E408,        4, base=16,    bitRange=8-15
  354                           ;`IP2.PRI_10`               0xE000E408,        4, base=16,    bitRange=16-23
  355                           ;`IP2.PRI_11`               0xE000E408,        4, base=16,    bitRange=24-31
  356                           
  357                           IP3                      EQU  0xE000E40C
  358                           ;`IP3.PRI_12`               0xE000E40C,        4, base=16,    bitRange=0-7
  359                           ;`IP3.PRI_13`               0xE000E40C,        4, base=16,    bitRange=8-15
  360                           ;`IP3.PRI_14`               0xE000E40C,        4, base=16,    bitRange=16-23
  361                           ;`IP3.PRI_15`               0xE000E40C,        4, base=16,    bitRange=24-31
  362                           
  363                           IP4                      EQU  0xE000E410
  364                           ;`IP4.PRI_16`               0xE000E410,        4, base=16,    bitRange=0-7
  365                           ;`IP4.PRI_17`               0xE000E410,        4, base=16,    bitRange=8-15
  366                           ;`IP4.PRI_18`               0xE000E410,        4, base=16,    bitRange=16-23
  367                           ;`IP4.PRI_19`               0xE000E410,        4, base=16,    bitRange=24-31
  368                           
  369                           IP5                      EQU  0xE000E414
  370                           ;`IP5.PRI_20`               0xE000E414,        4, base=16,    bitRange=0-7
  371                           ;`IP5.PRI_21`               0xE000E414,        4, base=16,    bitRange=8-15
  372                           ;`IP5.PRI_22`               0xE000E414,        4, base=16,    bitRange=16-23
  373                           ;`IP5.PRI_23`               0xE000E414,        4, base=16,    bitRange=24-31
  374                           
  375                           IP6                      EQU  0xE000E418
  376                           ;`IP6.PRI_24`               0xE000E418,        4, base=16,    bitRange=0-7
  377                           ;`IP6.PRI_25`               0xE000E418,        4, base=16,    bitRange=8-15
  378                           ;`IP6.PRI_26`               0xE000E418,        4, base=16,    bitRange=16-23
  379                           ;`IP6.PRI_27`               0xE000E418,        4, base=16,    bitRange=24-31
  380                           
  381                           IP7                      EQU  0xE000E41C
  382                           ;`IP7.PRI_28`               0xE000E41C,        4, base=16,    bitRange=0-7
  383                           ;`IP7.PRI_29`               0xE000E41C,        4, base=16,    bitRange=8-15
  384                           ;`IP7.PRI_30`               0xE000E41C,        4, base=16,    bitRange=16-23
  385                           ;`IP7.PRI_31`               0xE000E41C,        4, base=16,    bitRange=24-31
  386                           
  387                           CPUIDBR                  EQU  0xE000ED00
  388                           ;`CPUIDBR.REVISION`         0xE000ED00,        4, base=16,    bitRange=0-3
  389                           ;`CPUIDBR.PARTNO`           0xE000ED00,        4, base=16,    bitRange=4-15
  390                           ;`CPUIDBR.CONSTANT`         0xE000ED00,        4, base=16,    bitRange=16-19
  391                           ;`CPUIDBR.VARIANT`          0xE000ED00,        4, base=16,    bitRange=20-23
  392                           ;`CPUIDBR.IMPLEMENTER`      0xE000ED00,        4, base=16,    bitRange=24-31
  393                           
  394                           CPUID                    EQU  0xE000ED00
  395                           ;`CPUID.REVISION`           0xE000ED00,        4, base=16,    bitRange=0-3
  396                           ;`CPUID.PARTNO`             0xE000ED00,        4, base=16,    bitRange=4-15
  397                           ;`CPUID.CONSTANT`           0xE000ED00,        4, base=16,    bitRange=16-19
  398                           ;`CPUID.VARIANT`            0xE000ED00,        4, base=16,    bitRange=20-23
  399                           ;`CPUID.IMPLEMENTER`        0xE000ED00,        4, base=16,    bitRange=24-31
  400                           
  401                           ICSR                     EQU  0xE000ED04
  402                           ;`ICSR.VECTACTIVE`          0xE000ED04,        4, base=16,    bitRange=0-5
  403                           ;`ICSR.VECTPENDING`         0xE000ED04,        4, base=16,    bitRange=12-17
  404                           ;`ICSR.ISRPENDING`          0xE000ED04,        4, base=16,    bitRange=22-22
  405                           ;`ICSR.PENDSTCLR`           0xE000ED04,        4, base=16,    bitRange=25-25
  406                           ;`ICSR.PENDSTSET`           0xE000ED04,        4, base=16,    bitRange=26-26
  407                           ;`ICSR.PENDSVCLR`           0xE000ED04,        4, base=16,    bitRange=27-27
  408                           ;`ICSR.PENDSVSET`           0xE000ED04,        4, base=16,    bitRange=28-28
  409                           ;`ICSR.NMIPENDSET`          0xE000ED04,        4, base=16,    bitRange=31-31
  410                           
  411                           AIRCR                    EQU  0xE000ED0C
  412                           ;`AIRCR.VECTCLRACTIVE`      0xE000ED0C,        4, base=16,    bitRange=1-1
  413                           ;`AIRCR.SYSRESETREQ`        0xE000ED0C,        4, base=16,    bitRange=2-2
  414                           ;`AIRCR.ENDIANESS`          0xE000ED0C,        4, base=16,    bitRange=15-15
  415                           ;`AIRCR.VECTKEY`            0xE000ED0C,        4, base=16,    bitRange=16-31
  416                           
  417                           SCR                      EQU  0xE000ED10
  418                           ;`SCR.SLEEPONEXIT`          0xE000ED10,        4, base=16,    bitRange=1-1
  419                           ;`SCR.SLEEPDEEP`            0xE000ED10,        4, base=16,    bitRange=2-2
  420                           ;`SCR.SEVONPEND`            0xE000ED10,        4, base=16,    bitRange=4-4
  421                           
  422                           CCR                      EQU  0xE000ED14
  423                           ;`CCR.UNALIGN_TRP`          0xE000ED14,        4, base=16,    bitRange=3-3
  424                           ;`CCR.STKALIGN`             0xE000ED14,        4, base=16,    bitRange=8-8
  425                           
  426                           SHPR2                    EQU  0xE000ED1C
  427                           ;`SHPR2.PRI_11`             0xE000ED1C,        4, base=16,    bitRange=24-31
  428                           
  429                           SHPR3                    EQU  0xE000ED20
  430                           ;`SHPR3.PRI_14`             0xE000ED20,        4, base=16,    bitRange=16-23
  431                           ;`SHPR3.PRI_15`             0xE000ED20,        4, base=16,    bitRange=24-31
  432                           
  433                           
  434                           ;
  435                           ;               System control block
  436                           ;
  437                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
  438                           ;     ----                        ----      -------     --------  ----------- --------
  439                           
  440                           
  441                           SYSMEMREMAP              EQU  0x40048000
  442                           ;`SYSMEMREMAP.MAP`          0x40048000,        4, base=16,    bitRange=0-1
  443                           
  444                           PRESETCTRL               EQU  0x40048004
  445                           ;`PRESETCTRL.SSP0_RST_N`    0x40048004,        4, base=16,    bitRange=0-0
  446                           ;`PRESETCTRL.I2C_RST_N`     0x40048004,        4, base=16,    bitRange=1-1
  447                           ;`PRESETCTRL.SSP1_RST_N`    0x40048004,        4, base=16,    bitRange=2-2
  448                           
  449                           SYSPLLCTRL               EQU  0x40048008
  450                           ;`SYSPLLCTRL.MSEL`          0x40048008,        4, base=16,    bitRange=0-4
  451                           ;`SYSPLLCTRL.PSEL`          0x40048008,        4, base=16,    bitRange=5-6
  452                           
  453                           SYSPLLSTAT               EQU  0x4004800C
  454                           ;`SYSPLLSTAT.LOCK`          0x4004800C,        4, base=16,    bitRange=0-0
  455                           
  456                           SYSOSCCTRL               EQU  0x40048020
  457                           ;`SYSOSCCTRL.BYPASS`        0x40048020,        4, base=16,    bitRange=0-0
  458                           ;`SYSOSCCTRL.FREQRANGE`     0x40048020,        4, base=16,    bitRange=1-1
  459                           
  460                           WDTOSCCTRL               EQU  0x40048024
  461                           ;`WDTOSCCTRL.DIVSEL`        0x40048024,        4, base=16,    bitRange=0-4
  462                           ;`WDTOSCCTRL.FREQSEL`       0x40048024,        4, base=16,    bitRange=5-8
  463                           
  464                           IRCCTRL                  EQU  0x40048028
  465                           ;`IRCCTRL.TRIM`             0x40048028,        4, base=16,    bitRange=0-7
  466                           
  467                           SYSRSTSTAT              EQU 0x40048030 ; M0+
  468                           SYSRESSTAT              EQU SYSRSTSTAT ; VIC
  469                           ;`SYSRESSTAT.POR`           0x40048030,        4, base=16,    bitRange=0-0
  470                           ;`SYSRESSTAT.EXTRST`        0x40048030,        4, base=16,    bitRange=1-1
  471                           ;`SYSRESSTAT.WDT`           0x40048030,        4, base=16,    bitRange=2-2
  472                           ;`SYSRESSTAT.BOD`           0x40048030,        4, base=16,    bitRange=3-3
  473                           ;`SYSRESSTAT.SYSRST`        0x40048030,        4, base=16,    bitRange=4-4
  474                           
  475                           SYSPLLCLKSEL             EQU  0x40048040
  476                           ;`SYSPLLCLKSEL.SEL`         0x40048040,        4, base=16,    bitRange=0-1
  477                           
  478                           SYSPLLCLKUEN             EQU  0x40048044
  479                           ;`SYSPLLCLKUEN.ENA`         0x40048044,        4, base=16,    bitRange=0-0
  480                           
  481                           MAINCLKSEL               EQU  0x40048070
  482                           ;`MAINCLKSEL.SEL`           0x40048070,        4, base=16,    bitRange=0-1
  483                           
  484                           MAINCLKUEN               EQU  0x40048074
  485                           ;`MAINCLKUEN.ENA`           0x40048074,        4, base=16,    bitRange=0-0
  486                           
  487                           SYSAHBCLKDIV             EQU  0x40048078
  488                           ;`SYSAHBCLKDIV.DIV`         0x40048078,        4, base=16,    bitRange=0-7
  489                           
  490                           SYSAHBCLKCTRL            EQU  0x40048080
  491                           ;`SYSAHBCLKCTRL.SYS`        0x40048080,        4, base=16,    bitRange=0-0
  492                           ;`SYSAHBCLKCTRL.ROM`        0x40048080,        4, base=16,    bitRange=1-1
  493                           ;`SYSAHBCLKCTRL.RAM`        0x40048080,        4, base=16,    bitRange=2-2
  494                           ;`SYSAHBCLKCTRL.FLASHREG`   0x40048080,        4, base=16,    bitRange=3-3
  495                           ;`SYSAHBCLKCTRL.FLASHARRAY` 0x40048080,        4, base=16,    bitRange=4-4
  496                           ;`SYSAHBCLKCTRL.I2C`        0x40048080,        4, base=16,    bitRange=5-5
  497                           ;`SYSAHBCLKCTRL.GPIO`       0x40048080,        4, base=16,    bitRange=6-6
  498                           ;`SYSAHBCLKCTRL.CT16B0`     0x40048080,        4, base=16,    bitRange=7-7
  499                           ;`SYSAHBCLKCTRL.CT16B1`     0x40048080,        4, base=16,    bitRange=8-8
  500                           ;`SYSAHBCLKCTRL.CT32B0`     0x40048080,        4, base=16,    bitRange=9-9
  501                           ;`SYSAHBCLKCTRL.CT32B1`     0x40048080,        4, base=16,    bitRange=10-10
  502                           ;`SYSAHBCLKCTRL.SSP0`       0x40048080,        4, base=16,    bitRange=11-11
  503                           ;`SYSAHBCLKCTRL.UART`       0x40048080,        4, base=16,    bitRange=12-12
  504                           ;`SYSAHBCLKCTRL.ADC`        0x40048080,        4, base=16,    bitRange=13-13
  505                           ;`SYSAHBCLKCTRL.WDT`        0x40048080,        4, base=16,    bitRange=15-15
  506                           ;`SYSAHBCLKCTRL.IOCON`      0x40048080,        4, base=16,    bitRange=16-16
  507                           ;`SYSAHBCLKCTRL.SSP1`       0x40048080,        4, base=16,    bitRange=18-18
  508                           
  509                           SSP0CLKDIV               EQU  0x40048094
  510                           ;`SSP0CLKDIV.DIV`           0x40048094,        4, base=16,    bitRange=0-7
  511                           
  512                           UARTCLKDIV               EQU  0x40048098 ; 11xx
  513                           ;`UARTCLKDIV.DIV`           0x40048098,        4, base=16,    bitRange=0-7
  514                           
  515                           SSP1CLKDIV               EQU  0x4004809C
  516                           ;`SSP1CLKDIV.DIV`           0x4004809C,        4, base=16,    bitRange=0-7
  517                           
  518                           WDTCLKSEL                EQU  0x400480D0
  519                           ;`WDTCLKSEL.SEL`            0x400480D0,        4, base=16,    bitRange=0-1
  520                           
  521                           WDTCLKUEN                EQU  0x400480D4
  522                           ;`WDTCLKUEN.ENA`            0x400480D4,        4, base=16,    bitRange=0-0
  523                           
  524                           WDTCLKDIV                EQU  0x400480D8
  525                           ;`WDTCLKDIV.DIV`            0x400480D8,        4, base=16,    bitRange=0-7
  526                           
  527                           CLKOUTCLKSEL             EQU  0x400480E0
  528                           ;`CLKOUTCLKSEL.SEL`         0x400480E0,        4, base=16,    bitRange=0-1
  529                           
  530                           CLKOUTUEN                EQU  0x400480E4
  531                           ;`CLKOUTUEN.ENA`            0x400480E4,        4, base=16,    bitRange=0-0
  532                           
  533                           CLKOUTDIV               EQU  0x400480E8 ; M0+
  534                           CLKOUTCLKDIV            EQU  CLKOUTDIV  ; VIC
  535                           ; CLKOUTCLKDIV                EQU  0x400480E8
  536                           ;`CLKOUTDIV.DIV`            0x400480E8,        4, base=16,    bitRange=0-7
  537                           
  538                           PIOPORCAP0               EQU  0x40048100
  539                           ;`PIOPORCAP0.CAPPIO0_0`     0x40048100,        4, base=16,    bitRange=0-0
  540                           ;`PIOPORCAP0.CAPPIO0_1`     0x40048100,        4, base=16,    bitRange=1-1
  541                           ;`PIOPORCAP0.CAPPIO0_2`     0x40048100,        4, base=16,    bitRange=2-2
  542                           ;`PIOPORCAP0.CAPPIO0_3`     0x40048100,        4, base=16,    bitRange=3-3
  543                           ;`PIOPORCAP0.CAPPIO0_4`     0x40048100,        4, base=16,    bitRange=4-4
  544                           ;`PIOPORCAP0.CAPPIO0_5`     0x40048100,        4, base=16,    bitRange=5-5
  545                           ;`PIOPORCAP0.CAPPIO0_6`     0x40048100,        4, base=16,    bitRange=6-6
  546                           ;`PIOPORCAP0.CAPPIO0_7`     0x40048100,        4, base=16,    bitRange=7-7
  547                           ;`PIOPORCAP0.CAPPIO0_8`     0x40048100,        4, base=16,    bitRange=8-8
  548                           ;`PIOPORCAP0.CAPPIO0_9`     0x40048100,        4, base=16,    bitRange=9-9
  549                           ;`PIOPORCAP0.CAPPIO0_10`    0x40048100,        4, base=16,    bitRange=10-10
  550                           ;`PIOPORCAP0.CAPPIO0_11`    0x40048100,        4, base=16,    bitRange=11-11
  551                           ;`PIOPORCAP0.CAPPIO1_0`     0x40048100,        4, base=16,    bitRange=12-12
  552                           ;`PIOPORCAP0.CAPPIO1_1`     0x40048100,        4, base=16,    bitRange=13-13
  553                           ;`PIOPORCAP0.CAPPIO1_2`     0x40048100,        4, base=16,    bitRange=14-14
  554                           ;`PIOPORCAP0.CAPPIO1_3`     0x40048100,        4, base=16,    bitRange=15-15
  555                           ;`PIOPORCAP0.CAPPIO1_4`     0x40048100,        4, base=16,    bitRange=16-16
  556                           ;`PIOPORCAP0.CAPPIO1_5`     0x40048100,        4, base=16,    bitRange=17-17
  557                           ;`PIOPORCAP0.CAPPIO1_6`     0x40048100,        4, base=16,    bitRange=18-18
  558                           ;`PIOPORCAP0.CAPPIO1_7`     0x40048100,        4, base=16,    bitRange=19-19
  559                           ;`PIOPORCAP0.CAPPIO1_8`     0x40048100,        4, base=16,    bitRange=20-20
  560                           ;`PIOPORCAP0.CAPPIO1_9`     0x40048100,        4, base=16,    bitRange=21-21
  561                           ;`PIOPORCAP0.CAPPIO1_10`    0x40048100,        4, base=16,    bitRange=22-22
  562                           ;`PIOPORCAP0.CAPPIO1_11`    0x40048100,        4, base=16,    bitRange=23-23
  563                           ;`PIOPORCAP0.CAPPIO2_0`     0x40048100,        4, base=16,    bitRange=24-24
  564                           ;`PIOPORCAP0.CAPPIO2_1`     0x40048100,        4, base=16,    bitRange=25-25
  565                           ;`PIOPORCAP0.CAPPIO2_2`     0x40048100,        4, base=16,    bitRange=26-26
  566                           ;`PIOPORCAP0.CAPPIO2_3`     0x40048100,        4, base=16,    bitRange=27-27
  567                           ;`PIOPORCAP0.CAPPIO2_4`     0x40048100,        4, base=16,    bitRange=28-28
  568                           ;`PIOPORCAP0.CAPPIO2_5`     0x40048100,        4, base=16,    bitRange=29-29
  569                           ;`PIOPORCAP0.CAPPIO2_6`     0x40048100,        4, base=16,    bitRange=30-30
  570                           ;`PIOPORCAP0.CAPPIO2_7`     0x40048100,        4, base=16,    bitRange=31-31
  571                           
  572                           PIOPORCAP1               EQU  0x40048104
  573                           ;`PIOPORCAP1.CAPPIO2_8`     0x40048104,        4, base=16,    bitRange=0-0
  574                           ;`PIOPORCAP1.CAPPIO2_9`     0x40048104,        4, base=16,    bitRange=1-1
  575                           ;`PIOPORCAP1.CAPPIO2_10`    0x40048104,        4, base=16,    bitRange=2-2
  576                           ;`PIOPORCAP1.CAPPIO2_11`    0x40048104,        4, base=16,    bitRange=3-3
  577                           ;`PIOPORCAP1.CAPPIO3_0`     0x40048104,        4, base=16,    bitRange=4-4
  578                           ;`PIOPORCAP1.CAPPIO3_1`     0x40048104,        4, base=16,    bitRange=5-5
  579                           ;`PIOPORCAP1.CAPPIO3_2`     0x40048104,        4, base=16,    bitRange=6-6
  580                           ;`PIOPORCAP1.CAPPIO3_3`     0x40048104,        4, base=16,    bitRange=7-7
  581                           ;`PIOPORCAP1.CAPPIO3_4`     0x40048104,        4, base=16,    bitRange=8-8
  582                           ;`PIOPORCAP1.CAPPIO3_5`     0x40048104,        4, base=16,    bitRange=9-9
  583                           
  584                           BODCTRL                  EQU  0x40048150
  585                           ;`BODCTRL.BODRSTLEV`        0x40048150,        4, base=16,    bitRange=0-1
  586                           ;`BODCTRL.BODINTVAL`        0x40048150,        4, base=16,    bitRange=2-3
  587                           ;`BODCTRL.BODRSTENA`        0x40048150,        4, base=16,    bitRange=4-4
  588                           
  589                           SYSTCKCAL                EQU  0x40048154
  590                           ;`SYSTCKCAL.CAL`            0x40048154,        4, base=16,    bitRange=0-25
  591                           
  592                           NMISRC                   EQU  0x40048174
  593                           ;`NMISRC.IRQNO`             0x40048174,        4, base=16,    bitRange=0-4
  594                           ;`NMISRC.NMIEN`             0x40048174,        4, base=16,    bitRange=31-31
  595                           
  596                           STARTAPRP0               EQU  0x40048200
  597                           ;`STARTAPRP0.APRPIO0_0`     0x40048200,        4, base=16,    bitRange=0-0
  598                           ;`STARTAPRP0.APRPIO0_1`     0x40048200,        4, base=16,    bitRange=1-1
  599                           ;`STARTAPRP0.APRPIO0_2`     0x40048200,        4, base=16,    bitRange=2-2
  600                           ;`STARTAPRP0.APRPIO0_3`     0x40048200,        4, base=16,    bitRange=3-3
  601                           ;`STARTAPRP0.APRPIO0_4`     0x40048200,        4, base=16,    bitRange=4-4
  602                           ;`STARTAPRP0.APRPIO0_5`     0x40048200,        4, base=16,    bitRange=5-5
  603                           ;`STARTAPRP0.APRPIO0_6`     0x40048200,        4, base=16,    bitRange=6-6
  604                           ;`STARTAPRP0.APRPIO0_7`     0x40048200,        4, base=16,    bitRange=7-7
  605                           ;`STARTAPRP0.APRPIO0_8`     0x40048200,        4, base=16,    bitRange=8-8
  606                           ;`STARTAPRP0.APRPIO0_9`     0x40048200,        4, base=16,    bitRange=9-9
  607                           ;`STARTAPRP0.APRPIO0_10`    0x40048200,        4, base=16,    bitRange=10-10
  608                           ;`STARTAPRP0.APRPIO0_11`    0x40048200,        4, base=16,    bitRange=11-11
  609                           ;`STARTAPRP0.APRPIO1_0`     0x40048200,        4, base=16,    bitRange=12-12
  610                           
  611                           STARTERP0                EQU  0x40048204
  612                           ;`STARTERP0.ERPIO0_0`       0x40048204,        4, base=16,    bitRange=0-0
  613                           ;`STARTERP0.ERPIO0_1`       0x40048204,        4, base=16,    bitRange=1-1
  614                           ;`STARTERP0.ERPIO0_2`       0x40048204,        4, base=16,    bitRange=2-2
  615                           ;`STARTERP0.ERPIO0_3`       0x40048204,        4, base=16,    bitRange=3-3
  616                           ;`STARTERP0.ERPIO0_4`       0x40048204,        4, base=16,    bitRange=4-4
  617                           ;`STARTERP0.ERPIO0_5`       0x40048204,        4, base=16,    bitRange=5-5
  618                           ;`STARTERP0.ERPIO0_6`       0x40048204,        4, base=16,    bitRange=6-6
  619                           ;`STARTERP0.ERPIO0_7`       0x40048204,        4, base=16,    bitRange=7-7
  620                           ;`STARTERP0.ERPIO0_8`       0x40048204,        4, base=16,    bitRange=8-8
  621                           ;`STARTERP0.ERPIO0_9`       0x40048204,        4, base=16,    bitRange=9-9
  622                           ;`STARTERP0.ERPIO0_10`      0x40048204,        4, base=16,    bitRange=10-10
  623                           ;`STARTERP0.ERPIO0_11`      0x40048204,        4, base=16,    bitRange=11-11
  624                           ;`STARTERP0.ERPIO1_0`       0x40048204,        4, base=16,    bitRange=12-12
  625                           
  626                           STARTRSRP0CLR            EQU  0x40048208
  627                           
  628                           STARTSRP0                EQU  0x4004820C
  629                           ;`STARTSRP0.SRPIO0_0`       0x4004820C,        4, base=16,    bitRange=0-0
  630                           ;`STARTSRP0.SRPIO0_1`       0x4004820C,        4, base=16,    bitRange=1-1
  631                           ;`STARTSRP0.SRPIO0_2`       0x4004820C,        4, base=16,    bitRange=2-2
  632                           ;`STARTSRP0.SRPIO0_3`       0x4004820C,        4, base=16,    bitRange=3-3
  633                           ;`STARTSRP0.SRPIO0_4`       0x4004820C,        4, base=16,    bitRange=4-4
  634                           ;`STARTSRP0.SRPIO0_5`       0x4004820C,        4, base=16,    bitRange=5-5
  635                           ;`STARTSRP0.SRPIO0_6`       0x4004820C,        4, base=16,    bitRange=6-6
  636                           ;`STARTSRP0.SRPIO0_7`       0x4004820C,        4, base=16,    bitRange=7-7
  637                           ;`STARTSRP0.SRPIO0_8`       0x4004820C,        4, base=16,    bitRange=8-8
  638                           ;`STARTSRP0.SRPIO0_9`       0x4004820C,        4, base=16,    bitRange=9-9
  639                           ;`STARTSRP0.SRPIO0_10`      0x4004820C,        4, base=16,    bitRange=10-10
  640                           ;`STARTSRP0.SRPIO0_11`      0x4004820C,        4, base=16,    bitRange=11-11
  641                           ;`STARTSRP0.SRPIO1_0`       0x4004820C,        4, base=16,    bitRange=12-12
  642                           
  643                           PDSLEEPCFG               EQU  0x40048230
  644                           ;`PDSLEEPCFG.BOD_PD`        0x40048230,        4, base=16,    bitRange=3-3
  645                           ;`PDSLEEPCFG.WDTOSC_PD`     0x40048230,        4, base=16,    bitRange=6-6
  646                           
  647                           PDAWAKECFG               EQU  0x40048234
  648                           ;`PDAWAKECFG.IRCOUT_PD`     0x40048234,        4, base=16,    bitRange=0-0
  649                           ;`PDAWAKECFG.IRC_PD`        0x40048234,        4, base=16,    bitRange=1-1
  650                           ;`PDAWAKECFG.FLASH_PD`      0x40048234,        4, base=16,    bitRange=2-2
  651                           ;`PDAWAKECFG.BOD_PD`        0x40048234,        4, base=16,    bitRange=3-3
  652                           ;`PDAWAKECFG.ADC_PD`        0x40048234,        4, base=16,    bitRange=4-4
  653                           ;`PDAWAKECFG.SYSOSC_PD`     0x40048234,        4, base=16,    bitRange=5-5
  654                           ;`PDAWAKECFG.WDTOSC_PD`     0x40048234,        4, base=16,    bitRange=6-6
  655                           ;`PDAWAKECFG.SYSPLL_PD`     0x40048234,        4, base=16,    bitRange=7-7
  656                           
  657                           PDRUNCFG                 EQU  0x40048238
  658                           ;`PDRUNCFG.IRCOUT_PD`       0x40048238,        4, base=16,    bitRange=0-0
  659                           ;`PDRUNCFG.IRC_PD`          0x40048238,        4, base=16,    bitRange=1-1
  660                           ;`PDRUNCFG.FLASH_PD`        0x40048238,        4, base=16,    bitRange=2-2
  661                           ;`PDRUNCFG.BOD_PD`          0x40048238,        4, base=16,    bitRange=3-3
  662                           ;`PDRUNCFG.ADC_PD`          0x40048238,        4, base=16,    bitRange=4-4
  663                           ;`PDRUNCFG.SYSOSC_PD`       0x40048238,        4, base=16,    bitRange=5-5
  664                           ;`PDRUNCFG.WDTOSC_PD`       0x40048238,        4, base=16,    bitRange=6-6
  665                           ;`PDRUNCFG.SYSPLL_PD`       0x40048238,        4, base=16,    bitRange=7-7
  666                           
  667                           DEVICE_ID                EQU  0x400483F4 ; Part ID numbers for LPC111x/LPC11Cxx parts
  668                           
  669                           
  670                           ;
  671                           ;               PMU
  672                           ;
  673                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
  674                           ;     ----                        ----      -------     --------  ----------- --------
  675                           
  676                           
  677                           PCON                     EQU  0x40038000
  678                           ;`PCON.DPDEN`               0x40038000,        4, base=16,    bitRange=1-1
  679                           ;`PCON.SLEEPFLAG`           0x40038000,        4, base=16,    bitRange=8-8
  680                           ;`PCON.DPDFLAG`             0x40038000,        4, base=16,    bitRange=11-11
  681                           
  682                           GPREG0                   EQU  0x40038004
  683                           
  684                           GPREG1                   EQU  0x40038008
  685                           
  686                           GPREG2                   EQU  0x4003800C
  687                           
  688                           GPREG3                   EQU  0x40038010
  689                           
  690                           GPREG4                   EQU  0x40038014
  691                           ;`GPREG4.WAKEUPHYS`         0x40038014,        4, base=16,    bitRange=10-10
  692                           ;`GPREG4.GPDATA`            0x40038014,        4, base=16,    bitRange=11-31
  693                           
  694                           
  695                           ;
  696                           ;               I/O configuration
  697                           ;
  698                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
  699                           ;     ----                        ----      -------     --------  ----------- --------
  700                           
  701                           
  702                           IOCON_PIO2_6             EQU  0x40044000
  703                           ;`IOCON_PIO2_6.FUNC`        0x40044000,        4, base=16,    bitRange=0-2
  704                           ;`IOCON_PIO2_6.MODE`        0x40044000,        4, base=16,    bitRange=3-4
  705                           ;`IOCON_PIO2_6.HYS`         0x40044000,        4, base=16,    bitRange=5-5
  706                           ;`IOCON_PIO2_6.OD`          0x40044000,        4, base=16,    bitRange=10-10
  707                           
  708                           IOCON_PIO2_0             EQU  0x40044008
  709                           ;`IOCON_PIO2_0.FUNC`        0x40044008,        4, base=16,    bitRange=0-2
  710                           ;`IOCON_PIO2_0.MODE`        0x40044008,        4, base=16,    bitRange=3-4
  711                           ;`IOCON_PIO2_0.HYS`         0x40044008,        4, base=16,    bitRange=5-5
  712                           ;`IOCON_PIO2_0.OD`          0x40044008,        4, base=16,    bitRange=10-10
  713                           
  714                           IOCON_RESET_PIO0_0       EQU  0x4004400C
  715                           ;`IOCON_RESET_PIO0_0.FUNC`  0x4004400C,        4, base=16,    bitRange=0-2
  716                           ;`IOCON_RESET_PIO0_0.MODE`  0x4004400C,        4, base=16,    bitRange=3-4
  717                           ;`IOCON_RESET_PIO0_0.HYS`   0x4004400C,        4, base=16,    bitRange=5-5
  718                           ;`IOCON_RESET_PIO0_0.OD`    0x4004400C,        4, base=16,    bitRange=10-10
  719                           
  720                           IOCON_PIO0_1             EQU  0x40044010
  721                           ;`IOCON_PIO0_1.FUNC`        0x40044010,        4, base=16,    bitRange=0-2
  722                           ;`IOCON_PIO0_1.MODE`        0x40044010,        4, base=16,    bitRange=3-4
  723                           ;`IOCON_PIO0_1.HYS`         0x40044010,        4, base=16,    bitRange=5-5
  724                           ;`IOCON_PIO0_1.OD`          0x40044010,        4, base=16,    bitRange=10-10
  725                           
  726                           IOCON_PIO1_8             EQU  0x40044014
  727                           ;`IOCON_PIO1_8.FUNC`        0x40044014,        4, base=16,    bitRange=0-2
  728                           ;`IOCON_PIO1_8.MODE`        0x40044014,        4, base=16,    bitRange=3-4
  729                           ;`IOCON_PIO1_8.HYS`         0x40044014,        4, base=16,    bitRange=5-5
  730                           ;`IOCON_PIO1_8.OD`          0x40044014,        4, base=16,    bitRange=10-10
  731                           
  732                           IOCON_PIO0_2             EQU  0x4004401C
  733                           ;`IOCON_PIO0_2.FUNC`        0x4004401C,        4, base=16,    bitRange=0-2
  734                           ;`IOCON_PIO0_2.MODE`        0x4004401C,        4, base=16,    bitRange=3-4
  735                           ;`IOCON_PIO0_2.HYS`         0x4004401C,        4, base=16,    bitRange=5-5
  736                           ;`IOCON_PIO0_2.OD`          0x4004401C,        4, base=16,    bitRange=10-10
  737                           
  738                           IOCON_PIO2_7             EQU  0x40044020
  739                           ;`IOCON_PIO2_7.FUNC`        0x40044020,        4, base=16,    bitRange=0-2
  740                           ;`IOCON_PIO2_7.MODE`        0x40044020,        4, base=16,    bitRange=3-4
  741                           ;`IOCON_PIO2_7.HYS`         0x40044020,        4, base=16,    bitRange=5-5
  742                           ;`IOCON_PIO2_7.OD`          0x40044020,        4, base=16,    bitRange=10-10
  743                           
  744                           IOCON_PIO2_8             EQU  0x40044024
  745                           ;`IOCON_PIO2_8.FUNC`        0x40044024,        4, base=16,    bitRange=0-2
  746                           ;`IOCON_PIO2_8.MODE`        0x40044024,        4, base=16,    bitRange=3-4
  747                           ;`IOCON_PIO2_8.HYS`         0x40044024,        4, base=16,    bitRange=5-5
  748                           ;`IOCON_PIO2_8.OD`          0x40044024,        4, base=16,    bitRange=10-10
  749                           
  750                           IOCON_PIO2_1             EQU  0x40044028
  751                           ;`IOCON_PIO2_1.FUNC`        0x40044028,        4, base=16,    bitRange=0-2
  752                           ;`IOCON_PIO2_1.MODE`        0x40044028,        4, base=16,    bitRange=3-4
  753                           ;`IOCON_PIO2_1.HYS`         0x40044028,        4, base=16,    bitRange=5-5
  754                           ;`IOCON_PIO2_1.OD`          0x40044028,        4, base=16,    bitRange=10-10
  755                           
  756                           IOCON_PIO0_3             EQU  0x4004402C
  757                           ;`IOCON_PIO0_3.FUNC`        0x4004402C,        4, base=16,    bitRange=0-2
  758                           ;`IOCON_PIO0_3.MODE`        0x4004402C,        4, base=16,    bitRange=3-4
  759                           ;`IOCON_PIO0_3.HYS`         0x4004402C,        4, base=16,    bitRange=5-5
  760                           ;`IOCON_PIO0_3.OD`          0x4004402C,        4, base=16,    bitRange=10-10
  761                           
  762                           IOCON_PIO0_4             EQU  0x40044030
  763                           ;`IOCON_PIO0_4.FUNC`        0x40044030,        4, base=16,    bitRange=0-2
  764                           ;`IOCON_PIO0_4.I2CMODE`     0x40044030,        4, base=16,    bitRange=8-9
  765                           
  766                           IOCON_PIO0_5             EQU  0x40044034
  767                           ;`IOCON_PIO0_5.FUNC`        0x40044034,        4, base=16,    bitRange=0-2
  768                           ;`IOCON_PIO0_5.I2CMODE`     0x40044034,        4, base=16,    bitRange=8-9
  769                           
  770                           IOCON_PIO1_9             EQU  0x40044038
  771                           ;`IOCON_PIO1_9.FUNC`        0x40044038,        4, base=16,    bitRange=0-2
  772                           ;`IOCON_PIO1_9.MODE`        0x40044038,        4, base=16,    bitRange=3-4
  773                           ;`IOCON_PIO1_9.HYS`         0x40044038,        4, base=16,    bitRange=5-5
  774                           ;`IOCON_PIO1_9.OD`          0x40044038,        4, base=16,    bitRange=10-10
  775                           
  776                           IOCON_PIO3_4             EQU  0x4004403C
  777                           ;`IOCON_PIO3_4.FUNC`        0x4004403C,        4, base=16,    bitRange=0-2
  778                           ;`IOCON_PIO3_4.MODE`        0x4004403C,        4, base=16,    bitRange=3-4
  779                           ;`IOCON_PIO3_4.HYS`         0x4004403C,        4, base=16,    bitRange=5-5
  780                           ;`IOCON_PIO3_4.OD`          0x4004403C,        4, base=16,    bitRange=10-10
  781                           
  782                           IOCON_PIO2_4             EQU  0x40044040
  783                           ;`IOCON_PIO2_4.FUNC`        0x40044040,        4, base=16,    bitRange=0-2
  784                           ;`IOCON_PIO2_4.MODE`        0x40044040,        4, base=16,    bitRange=3-4
  785                           ;`IOCON_PIO2_4.HYS`         0x40044040,        4, base=16,    bitRange=5-5
  786                           ;`IOCON_PIO2_4.OD`          0x40044040,        4, base=16,    bitRange=10-10
  787                           
  788                           IOCON_PIO2_5             EQU  0x40044044
  789                           ;`IOCON_PIO2_5.FUNC`        0x40044044,        4, base=16,    bitRange=0-2
  790                           ;`IOCON_PIO2_5.MODE`        0x40044044,        4, base=16,    bitRange=3-4
  791                           ;`IOCON_PIO2_5.HYS`         0x40044044,        4, base=16,    bitRange=5-5
  792                           ;`IOCON_PIO2_5.OD`          0x40044044,        4, base=16,    bitRange=10-10
  793                           
  794                           IOCON_PIO3_5             EQU  0x40044048
  795                           ;`IOCON_PIO3_5.FUNC`        0x40044048,        4, base=16,    bitRange=0-2
  796                           ;`IOCON_PIO3_5.MODE`        0x40044048,        4, base=16,    bitRange=3-4
  797                           ;`IOCON_PIO3_5.HYS`         0x40044048,        4, base=16,    bitRange=5-5
  798                           ;`IOCON_PIO3_5.OD`          0x40044048,        4, base=16,    bitRange=10-10
  799                           
  800                           IOCON_PIO0_6             EQU  0x4004404C
  801                           ;`IOCON_PIO0_6.FUNC`        0x4004404C,        4, base=16,    bitRange=0-2
  802                           ;`IOCON_PIO0_6.MODE`        0x4004404C,        4, base=16,    bitRange=3-4
  803                           ;`IOCON_PIO0_6.HYS`         0x4004404C,        4, base=16,    bitRange=5-5
  804                           ;`IOCON_PIO0_6.OD`          0x4004404C,        4, base=16,    bitRange=10-10
  805                           
  806                           IOCON_PIO0_7             EQU  0x40044050
  807                           ;`IOCON_PIO0_7.FUNC`        0x40044050,        4, base=16,    bitRange=0-2
  808                           ;`IOCON_PIO0_7.MODE`        0x40044050,        4, base=16,    bitRange=3-4
  809                           ;`IOCON_PIO0_7.HYS`         0x40044050,        4, base=16,    bitRange=5-5
  810                           ;`IOCON_PIO0_7.OD`          0x40044050,        4, base=16,    bitRange=10-10
  811                           
  812                           IOCON_PIO2_9             EQU  0x40044054
  813                           ;`IOCON_PIO2_9.FUNC`        0x40044054,        4, base=16,    bitRange=0-2
  814                           ;`IOCON_PIO2_9.MODE`        0x40044054,        4, base=16,    bitRange=3-4
  815                           ;`IOCON_PIO2_9.HYS`         0x40044054,        4, base=16,    bitRange=5-5
  816                           ;`IOCON_PIO2_9.OD`          0x40044054,        4, base=16,    bitRange=10-10
  817                           
  818                           IOCON_PIO2_10            EQU  0x40044058
  819                           ;`IOCON_PIO2_10.FUNC`       0x40044058,        4, base=16,    bitRange=0-2
  820                           ;`IOCON_PIO2_10.MODE`       0x40044058,        4, base=16,    bitRange=3-4
  821                           ;`IOCON_PIO2_10.HYS`        0x40044058,        4, base=16,    bitRange=5-5
  822                           ;`IOCON_PIO2_10.OD`         0x40044058,        4, base=16,    bitRange=10-10
  823                           
  824                           IOCON_PIO2_2             EQU  0x4004405C
  825                           ;`IOCON_PIO2_2.FUNC`        0x4004405C,        4, base=16,    bitRange=0-2
  826                           ;`IOCON_PIO2_2.MODE`        0x4004405C,        4, base=16,    bitRange=3-4
  827                           ;`IOCON_PIO2_2.HYS`         0x4004405C,        4, base=16,    bitRange=5-5
  828                           ;`IOCON_PIO2_2.OD`          0x4004405C,        4, base=16,    bitRange=10-10
  829                           
  830                           IOCON_PIO0_8             EQU  0x40044060
  831                           ;`IOCON_PIO0_8.FUNC`        0x40044060,        4, base=16,    bitRange=0-2
  832                           ;`IOCON_PIO0_8.MODE`        0x40044060,        4, base=16,    bitRange=3-4
  833                           ;`IOCON_PIO0_8.HYS`         0x40044060,        4, base=16,    bitRange=5-5
  834                           ;`IOCON_PIO0_8.OD`          0x40044060,        4, base=16,    bitRange=10-10
  835                           
  836                           IOCON_PIO0_9             EQU  0x40044064
  837                           ;`IOCON_PIO0_9.FUNC`        0x40044064,        4, base=16,    bitRange=0-2
  838                           ;`IOCON_PIO0_9.MODE`        0x40044064,        4, base=16,    bitRange=3-4
  839                           ;`IOCON_PIO0_9.HYS`         0x40044064,        4, base=16,    bitRange=5-5
  840                           ;`IOCON_PIO0_9.OD`          0x40044064,        4, base=16,    bitRange=10-10
  841                           
  842                           IOCON_SWCLK_PIO0_10      EQU  0x40044068
  843                           ;`IOCON_SWCLK_PIO0_10.FUNC` 0x40044068,        4, base=16,    bitRange=0-2
  844                           ;`IOCON_SWCLK_PIO0_10.MODE` 0x40044068,        4, base=16,    bitRange=3-4
  845                           ;`IOCON_SWCLK_PIO0_10.HYS`  0x40044068,        4, base=16,    bitRange=5-5
  846                           ;`IOCON_SWCLK_PIO0_10.OD`   0x40044068,        4, base=16,    bitRange=10-10
  847                           
  848                           IOCON_PIO1_10            EQU  0x4004406C
  849                           ;`IOCON_PIO1_10.FUNC`       0x4004406C,        4, base=16,    bitRange=0-2
  850                           ;`IOCON_PIO1_10.MODE`       0x4004406C,        4, base=16,    bitRange=3-4
  851                           ;`IOCON_PIO1_10.HYS`        0x4004406C,        4, base=16,    bitRange=5-5
  852                           ;`IOCON_PIO1_10.ADMODE`     0x4004406C,        4, base=16,    bitRange=7-7
  853                           ;`IOCON_PIO1_10.OD`         0x4004406C,        4, base=16,    bitRange=10-10
  854                           
  855                           IOCON_PIO2_11            EQU  0x40044070
  856                           ;`IOCON_PIO2_11.FUNC`       0x40044070,        4, base=16,    bitRange=0-2
  857                           ;`IOCON_PIO2_11.MODE`       0x40044070,        4, base=16,    bitRange=3-4
  858                           ;`IOCON_PIO2_11.HYS`        0x40044070,        4, base=16,    bitRange=5-5
  859                           ;`IOCON_PIO2_11.OD`         0x40044070,        4, base=16,    bitRange=10-10
  860                           
  861                           IOCON_R_PIO0_11          EQU  0x40044074
  862                           ;`IOCON_R_PIO0_11.FUNC`     0x40044074,        4, base=16,    bitRange=0-2
  863                           ;`IOCON_R_PIO0_11.MODE`     0x40044074,        4, base=16,    bitRange=3-4
  864                           ;`IOCON_R_PIO0_11.HYS`      0x40044074,        4, base=16,    bitRange=5-5
  865                           ;`IOCON_R_PIO0_11.ADMODE`   0x40044074,        4, base=16,    bitRange=7-7
  866                           ;`IOCON_R_PIO0_11.OD`       0x40044074,        4, base=16,    bitRange=10-10
  867                           
  868                           IOCON_R_PIO1_0           EQU  0x40044078
  869                           ;`IOCON_R_PIO1_0.FUNC`      0x40044078,        4, base=16,    bitRange=0-2
  870                           ;`IOCON_R_PIO1_0.MODE`      0x40044078,        4, base=16,    bitRange=3-4
  871                           ;`IOCON_R_PIO1_0.HYS`       0x40044078,        4, base=16,    bitRange=5-5
  872                           ;`IOCON_R_PIO1_0.ADMODE`    0x40044078,        4, base=16,    bitRange=7-7
  873                           ;`IOCON_R_PIO1_0.OD`        0x40044078,        4, base=16,    bitRange=10-10
  874                           
  875                           IOCON_R_PIO1_1           EQU  0x4004407C
  876                           ;`IOCON_R_PIO1_1.FUNC`      0x4004407C,        4, base=16,    bitRange=0-2
  877                           ;`IOCON_R_PIO1_1.MODE`      0x4004407C,        4, base=16,    bitRange=3-4
  878                           ;`IOCON_R_PIO1_1.HYS`       0x4004407C,        4, base=16,    bitRange=5-5
  879                           ;`IOCON_R_PIO1_1.ADMODE`    0x4004407C,        4, base=16,    bitRange=7-7
  880                           ;`IOCON_R_PIO1_1.OD`        0x4004407C,        4, base=16,    bitRange=10-10
  881                           
  882                           IOCON_R_PIO1_2           EQU  0x40044080
  883                           ;`IOCON_R_PIO1_2.FUNC`      0x40044080,        4, base=16,    bitRange=0-2
  884                           ;`IOCON_R_PIO1_2.MODE`      0x40044080,        4, base=16,    bitRange=3-4
  885                           ;`IOCON_R_PIO1_2.HYS`       0x40044080,        4, base=16,    bitRange=5-5
  886                           ;`IOCON_R_PIO1_2.ADMODE`    0x40044080,        4, base=16,    bitRange=7-7
  887                           ;`IOCON_R_PIO1_2.OD`        0x40044080,        4, base=16,    bitRange=10-10
  888                           
  889                           IOCON_PIO3_0             EQU  0x40044084
  890                           ;`IOCON_PIO3_0.FUNC`        0x40044084,        4, base=16,    bitRange=0-2
  891                           ;`IOCON_PIO3_0.MODE`        0x40044084,        4, base=16,    bitRange=3-4
  892                           ;`IOCON_PIO3_0.HYS`         0x40044084,        4, base=16,    bitRange=5-5
  893                           ;`IOCON_PIO3_0.OD`          0x40044084,        4, base=16,    bitRange=10-10
  894                           
  895                           IOCON_PIO3_1             EQU  0x40044088
  896                           ;`IOCON_PIO3_1.FUNC`        0x40044088,        4, base=16,    bitRange=0-2
  897                           ;`IOCON_PIO3_1.MODE`        0x40044088,        4, base=16,    bitRange=3-4
  898                           ;`IOCON_PIO3_1.HYS`         0x40044088,        4, base=16,    bitRange=5-5
  899                           ;`IOCON_PIO3_1.OD`          0x40044088,        4, base=16,    bitRange=10-10
  900                           
  901                           IOCON_PIO2_3             EQU  0x4004408C
  902                           ;`IOCON_PIO2_3.FUNC`        0x4004408C,        4, base=16,    bitRange=0-2
  903                           ;`IOCON_PIO2_3.MODE`        0x4004408C,        4, base=16,    bitRange=3-4
  904                           ;`IOCON_PIO2_3.HYS`         0x4004408C,        4, base=16,    bitRange=5-5
  905                           ;`IOCON_PIO2_3.OD`          0x4004408C,        4, base=16,    bitRange=10-10
  906                           
  907                           IOCON_SWDIO_PIO1_3       EQU  0x40044090
  908                           ;`IOCON_SWDIO_PIO1_3.FUNC`  0x40044090,        4, base=16,    bitRange=0-2
  909                           ;`IOCON_SWDIO_PIO1_3.MODE`  0x40044090,        4, base=16,    bitRange=3-4
  910                           ;`IOCON_SWDIO_PIO1_3.HYS`   0x40044090,        4, base=16,    bitRange=5-5
  911                           ;`IOCON_SWDIO_PIO1_3.ADMODE` 0x40044090,        4, base=16,    bitRange=7-7
  912                           ;`IOCON_SWDIO_PIO1_3.OD`    0x40044090,        4, base=16,    bitRange=10-10
  913                           
  914                           IOCON_PIO1_4             EQU  0x40044094
  915                           ;`IOCON_PIO1_4.FUNC`        0x40044094,        4, base=16,    bitRange=0-2
  916                           ;`IOCON_PIO1_4.MODE`        0x40044094,        4, base=16,    bitRange=3-4
  917                           ;`IOCON_PIO1_4.HYS`         0x40044094,        4, base=16,    bitRange=5-5
  918                           ;`IOCON_PIO1_4.ADMODE`      0x40044094,        4, base=16,    bitRange=7-7
  919                           ;`IOCON_PIO1_4.OD`          0x40044094,        4, base=16,    bitRange=10-10
  920                           
  921                           IOCON_PIO1_11            EQU  0x40044098
  922                           ;`IOCON_PIO1_11.FUNC`       0x40044098,        4, base=16,    bitRange=0-2
  923                           ;`IOCON_PIO1_11.MODE`       0x40044098,        4, base=16,    bitRange=3-4
  924                           ;`IOCON_PIO1_11.HYS`        0x40044098,        4, base=16,    bitRange=5-5
  925                           ;`IOCON_PIO1_11.ADMODE`     0x40044098,        4, base=16,    bitRange=7-7
  926                           ;`IOCON_PIO1_11.OD`         0x40044098,        4, base=16,    bitRange=10-10
  927                           
  928                           IOCON_PIO3_2             EQU  0x4004409C
  929                           ;`IOCON_PIO3_2.FUNC`        0x4004409C,        4, base=16,    bitRange=0-2
  930                           ;`IOCON_PIO3_2.MODE`        0x4004409C,        4, base=16,    bitRange=3-4
  931                           ;`IOCON_PIO3_2.HYS`         0x4004409C,        4, base=16,    bitRange=5-5
  932                           ;`IOCON_PIO3_2.OD`          0x4004409C,        4, base=16,    bitRange=10-10
  933                           
  934                           IOCON_PIO1_5             EQU  0x400440A0
  935                           ;`IOCON_PIO1_5.FUNC`        0x400440A0,        4, base=16,    bitRange=0-2
  936                           ;`IOCON_PIO1_5.MODE`        0x400440A0,        4, base=16,    bitRange=3-4
  937                           ;`IOCON_PIO1_5.HYS`         0x400440A0,        4, base=16,    bitRange=5-5
  938                           ;`IOCON_PIO1_5.OD`          0x400440A0,        4, base=16,    bitRange=10-10
  939                           
  940                           IOCON_PIO1_6             EQU  0x400440A4
  941                           ;`IOCON_PIO1_6.FUNC`        0x400440A4,        4, base=16,    bitRange=0-2
  942                           ;`IOCON_PIO1_6.MODE`        0x400440A4,        4, base=16,    bitRange=3-4
  943                           ;`IOCON_PIO1_6.HYS`         0x400440A4,        4, base=16,    bitRange=5-5
  944                           ;`IOCON_PIO1_6.OD`          0x400440A4,        4, base=16,    bitRange=10-10
  945                           
  946                           IOCON_PIO1_7             EQU  0x400440A8
  947                           ;`IOCON_PIO1_7.FUNC`        0x400440A8,        4, base=16,    bitRange=0-2
  948                           ;`IOCON_PIO1_7.MODE`        0x400440A8,        4, base=16,    bitRange=3-4
  949                           ;`IOCON_PIO1_7.HYS`         0x400440A8,        4, base=16,    bitRange=5-5
  950                           ;`IOCON_PIO1_7.OD`          0x400440A8,        4, base=16,    bitRange=10-10
  951                           
  952                           IOCON_PIO3_3             EQU  0x400440AC
  953                           ;`IOCON_PIO3_3.FUNC`        0x400440AC,        4, base=16,    bitRange=0-2
  954                           ;`IOCON_PIO3_3.MODE`        0x400440AC,        4, base=16,    bitRange=3-4
  955                           ;`IOCON_PIO3_3.HYS`         0x400440AC,        4, base=16,    bitRange=5-5
  956                           ;`IOCON_PIO3_3.OD`          0x400440AC,        4, base=16,    bitRange=10-10
  957                           
  958                           IOCON_SCK_LOC            EQU  0x400440B0
  959                           ;`IOCON_SCK_LOC.SCKLOC`     0x400440B0,        4, base=16,    bitRange=0-1
  960                           
  961                           IOCON_DSR_LOC            EQU  0x400440B4
  962                           ;`IOCON_DSR_LOC.DSRLOC`     0x400440B4,        4, base=16,    bitRange=0-1
  963                           
  964                           IOCON_DCD_LOC            EQU  0x400440B8
  965                           ;`IOCON_DCD_LOC.DCDLOC`     0x400440B8,        4, base=16,    bitRange=0-1
  966                           
  967                           IOCON_RI_LOC             EQU  0x400440BC
  968                           ;`IOCON_RI_LOC.RILOC`       0x400440BC,        4, base=16,    bitRange=0-1
  969                           
  970                           
  971                           ;
  972                           ;               CPIO
  973                           ;
  974                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
  975                           ;     ----                        ----      -------     --------  ----------- --------
  976                           
  977                           
  978                           GPIO0DATA                EQU  0x50003FFC
  979                           ;`GPIO0DATA.P0_0`           0x50003FFC,        4, base=16,    bitRange=0-0
  980                           ;`GPIO0DATA.P0_1`           0x50003FFC,        4, base=16,    bitRange=1-1
  981                           ;`GPIO0DATA.P0_2`           0x50003FFC,        4, base=16,    bitRange=2-2
  982                           ;`GPIO0DATA.P0_3`           0x50003FFC,        4, base=16,    bitRange=3-3
  983                           ;`GPIO0DATA.P0_4`           0x50003FFC,        4, base=16,    bitRange=4-4
  984                           ;`GPIO0DATA.P0_5`           0x50003FFC,        4, base=16,    bitRange=5-5
  985                           ;`GPIO0DATA.P0_6`           0x50003FFC,        4, base=16,    bitRange=6-6
  986                           ;`GPIO0DATA.P0_7`           0x50003FFC,        4, base=16,    bitRange=7-7
  987                           ;`GPIO0DATA.P0_8`           0x50003FFC,        4, base=16,    bitRange=8-8
  988                           ;`GPIO0DATA.P0_9`           0x50003FFC,        4, base=16,    bitRange=9-9
  989                           ;`GPIO0DATA.P0_10`          0x50003FFC,        4, base=16,    bitRange=10-10
  990                           ;`GPIO0DATA.P0_11`          0x50003FFC,        4, base=16,    bitRange=11-11
  991                           
  992                           GPIO0DATA0               EQU  0x50003FFC
  993                           ;`GPIO0DATA0.P0_0`          0x50003FFC,        1, base=16,    bitRange=0-0
  994                           ;`GPIO0DATA0.P0_1`          0x50003FFC,        1, base=16,    bitRange=1-1
  995                           ;`GPIO0DATA0.P0_2`          0x50003FFC,        1, base=16,    bitRange=2-2
  996                           ;`GPIO0DATA0.P0_3`          0x50003FFC,        1, base=16,    bitRange=3-3
  997                           ;`GPIO0DATA0.P0_4`          0x50003FFC,        1, base=16,    bitRange=4-4
  998                           ;`GPIO0DATA0.P0_5`          0x50003FFC,        1, base=16,    bitRange=5-5
  999                           ;`GPIO0DATA0.P0_6`          0x50003FFC,        1, base=16,    bitRange=6-6
 1000                           ;`GPIO0DATA0.P0_7`          0x50003FFC,        1, base=16,    bitRange=7-7
 1001                           
 1002                           GPIO0DATA1               EQU  0x50003FFD
 1003                           ;`GPIO0DATA1.P0_8`          0x50003FFD,        1, base=16,    bitRange=0-0
 1004                           ;`GPIO0DATA1.P0_9`          0x50003FFD,        1, base=16,    bitRange=1-1
 1005                           ;`GPIO0DATA1.P0_10`         0x50003FFD,        1, base=16,    bitRange=2-2
 1006                           ;`GPIO0DATA1.P0_11`         0x50003FFD,        1, base=16,    bitRange=3-3
 1007                           
 1008                           GPIO0DATAL               EQU  0x50003FFC
 1009                           ;`GPIO0DATAL.P0_0`          0x50003FFC,        2, base=16,    bitRange=0-0
 1010                           ;`GPIO0DATAL.P0_1`          0x50003FFC,        2, base=16,    bitRange=1-1
 1011                           ;`GPIO0DATAL.P0_2`          0x50003FFC,        2, base=16,    bitRange=2-2
 1012                           ;`GPIO0DATAL.P0_3`          0x50003FFC,        2, base=16,    bitRange=3-3
 1013                           ;`GPIO0DATAL.P0_4`          0x50003FFC,        2, base=16,    bitRange=4-4
 1014                           ;`GPIO0DATAL.P0_5`          0x50003FFC,        2, base=16,    bitRange=5-5
 1015                           ;`GPIO0DATAL.P0_6`          0x50003FFC,        2, base=16,    bitRange=6-6
 1016                           ;`GPIO0DATAL.P0_7`          0x50003FFC,        2, base=16,    bitRange=7-7
 1017                           ;`GPIO0DATAL.P0_8`          0x50003FFC,        2, base=16,    bitRange=8-8
 1018                           ;`GPIO0DATAL.P0_9`          0x50003FFC,        2, base=16,    bitRange=9-9
 1019                           ;`GPIO0DATAL.P0_10`         0x50003FFC,        2, base=16,    bitRange=10-10
 1020                           ;`GPIO0DATAL.P0_11`         0x50003FFC,        2, base=16,    bitRange=11-11
 1021                           
 1022                           GPIO0DIR                 EQU  0x50008000
 1023                           ;`GPIO0DIR.P0_0`            0x50008000,        4, base=16,    bitRange=0-0
 1024                           ;`GPIO0DIR.P0_1`            0x50008000,        4, base=16,    bitRange=1-1
 1025                           ;`GPIO0DIR.P0_2`            0x50008000,        4, base=16,    bitRange=2-2
 1026                           ;`GPIO0DIR.P0_3`            0x50008000,        4, base=16,    bitRange=3-3
 1027                           ;`GPIO0DIR.P0_4`            0x50008000,        4, base=16,    bitRange=4-4
 1028                           ;`GPIO0DIR.P0_5`            0x50008000,        4, base=16,    bitRange=5-5
 1029                           ;`GPIO0DIR.P0_6`            0x50008000,        4, base=16,    bitRange=6-6
 1030                           ;`GPIO0DIR.P0_7`            0x50008000,        4, base=16,    bitRange=7-7
 1031                           ;`GPIO0DIR.P0_8`            0x50008000,        4, base=16,    bitRange=8-8
 1032                           ;`GPIO0DIR.P0_9`            0x50008000,        4, base=16,    bitRange=9-9
 1033                           ;`GPIO0DIR.P0_10`           0x50008000,        4, base=16,    bitRange=10-10
 1034                           ;`GPIO0DIR.P0_11`           0x50008000,        4, base=16,    bitRange=11-11
 1035                           
 1036                           GPIO0DIR0                EQU  0x50008000
 1037                           ;`GPIO0DIR0.P0_0`           0x50008000,        1, base=16,    bitRange=0-0
 1038                           ;`GPIO0DIR0.P0_1`           0x50008000,        1, base=16,    bitRange=1-1
 1039                           ;`GPIO0DIR0.P0_2`           0x50008000,        1, base=16,    bitRange=2-2
 1040                           ;`GPIO0DIR0.P0_3`           0x50008000,        1, base=16,    bitRange=3-3
 1041                           ;`GPIO0DIR0.P0_4`           0x50008000,        1, base=16,    bitRange=4-4
 1042                           ;`GPIO0DIR0.P0_5`           0x50008000,        1, base=16,    bitRange=5-5
 1043                           ;`GPIO0DIR0.P0_6`           0x50008000,        1, base=16,    bitRange=6-6
 1044                           ;`GPIO0DIR0.P0_7`           0x50008000,        1, base=16,    bitRange=7-7
 1045                           
 1046                           GPIO0DIR1                EQU  0x50008001
 1047                           ;`GPIO0DIR1.P0_8`           0x50008001,        1, base=16,    bitRange=0-0
 1048                           ;`GPIO0DIR1.P0_9`           0x50008001,        1, base=16,    bitRange=1-1
 1049                           ;`GPIO0DIR1.P0_10`          0x50008001,        1, base=16,    bitRange=2-2
 1050                           ;`GPIO0DIR1.P0_11`          0x50008001,        1, base=16,    bitRange=3-3
 1051                           
 1052                           GPIO0DIRL                EQU  0x50008000
 1053                           ;`GPIO0DIRL.P0_0`           0x50008000,        2, base=16,    bitRange=0-0
 1054                           ;`GPIO0DIRL.P0_1`           0x50008000,        2, base=16,    bitRange=1-1
 1055                           ;`GPIO0DIRL.P0_2`           0x50008000,        2, base=16,    bitRange=2-2
 1056                           ;`GPIO0DIRL.P0_3`           0x50008000,        2, base=16,    bitRange=3-3
 1057                           ;`GPIO0DIRL.P0_4`           0x50008000,        2, base=16,    bitRange=4-4
 1058                           ;`GPIO0DIRL.P0_5`           0x50008000,        2, base=16,    bitRange=5-5
 1059                           ;`GPIO0DIRL.P0_6`           0x50008000,        2, base=16,    bitRange=6-6
 1060                           ;`GPIO0DIRL.P0_7`           0x50008000,        2, base=16,    bitRange=7-7
 1061                           ;`GPIO0DIRL.P0_8`           0x50008000,        2, base=16,    bitRange=8-8
 1062                           ;`GPIO0DIRL.P0_9`           0x50008000,        2, base=16,    bitRange=9-9
 1063                           ;`GPIO0DIRL.P0_10`          0x50008000,        2, base=16,    bitRange=10-10
 1064                           ;`GPIO0DIRL.P0_11`          0x50008000,        2, base=16,    bitRange=11-11
 1065                           
 1066                           GPIO0IS                  EQU  0x50008004
 1067                           ;`GPIO0IS.P0_0`             0x50008004,        4, base=16,    bitRange=0-0
 1068                           ;`GPIO0IS.P0_1`             0x50008004,        4, base=16,    bitRange=1-1
 1069                           ;`GPIO0IS.P0_2`             0x50008004,        4, base=16,    bitRange=2-2
 1070                           ;`GPIO0IS.P0_3`             0x50008004,        4, base=16,    bitRange=3-3
 1071                           ;`GPIO0IS.P0_4`             0x50008004,        4, base=16,    bitRange=4-4
 1072                           ;`GPIO0IS.P0_5`             0x50008004,        4, base=16,    bitRange=5-5
 1073                           ;`GPIO0IS.P0_6`             0x50008004,        4, base=16,    bitRange=6-6
 1074                           ;`GPIO0IS.P0_7`             0x50008004,        4, base=16,    bitRange=7-7
 1075                           ;`GPIO0IS.P0_8`             0x50008004,        4, base=16,    bitRange=8-8
 1076                           ;`GPIO0IS.P0_9`             0x50008004,        4, base=16,    bitRange=9-9
 1077                           ;`GPIO0IS.P0_10`            0x50008004,        4, base=16,    bitRange=10-10
 1078                           ;`GPIO0IS.P0_11`            0x50008004,        4, base=16,    bitRange=11-11
 1079                           
 1080                           GPIO0IS0                 EQU  0x50008004
 1081                           ;`GPIO0IS0.P0_0`            0x50008004,        1, base=16,    bitRange=0-0
 1082                           ;`GPIO0IS0.P0_1`            0x50008004,        1, base=16,    bitRange=1-1
 1083                           ;`GPIO0IS0.P0_2`            0x50008004,        1, base=16,    bitRange=2-2
 1084                           ;`GPIO0IS0.P0_3`            0x50008004,        1, base=16,    bitRange=3-3
 1085                           ;`GPIO0IS0.P0_4`            0x50008004,        1, base=16,    bitRange=4-4
 1086                           ;`GPIO0IS0.P0_5`            0x50008004,        1, base=16,    bitRange=5-5
 1087                           ;`GPIO0IS0.P0_6`            0x50008004,        1, base=16,    bitRange=6-6
 1088                           ;`GPIO0IS0.P0_7`            0x50008004,        1, base=16,    bitRange=7-7
 1089                           
 1090                           GPIO0IS1                 EQU  0x50008005
 1091                           ;`GPIO0IS1.P0_8`            0x50008005,        1, base=16,    bitRange=0-0
 1092                           ;`GPIO0IS1.P0_9`            0x50008005,        1, base=16,    bitRange=1-1
 1093                           ;`GPIO0IS1.P0_10`           0x50008005,        1, base=16,    bitRange=2-2
 1094                           ;`GPIO0IS1.P0_11`           0x50008005,        1, base=16,    bitRange=3-3
 1095                           
 1096                           GPIO0ISL                 EQU  0x50008004
 1097                           ;`GPIO0ISL.P0_0`            0x50008004,        2, base=16,    bitRange=0-0
 1098                           ;`GPIO0ISL.P0_1`            0x50008004,        2, base=16,    bitRange=1-1
 1099                           ;`GPIO0ISL.P0_2`            0x50008004,        2, base=16,    bitRange=2-2
 1100                           ;`GPIO0ISL.P0_3`            0x50008004,        2, base=16,    bitRange=3-3
 1101                           ;`GPIO0ISL.P0_4`            0x50008004,        2, base=16,    bitRange=4-4
 1102                           ;`GPIO0ISL.P0_5`            0x50008004,        2, base=16,    bitRange=5-5
 1103                           ;`GPIO0ISL.P0_6`            0x50008004,        2, base=16,    bitRange=6-6
 1104                           ;`GPIO0ISL.P0_7`            0x50008004,        2, base=16,    bitRange=7-7
 1105                           ;`GPIO0ISL.P0_8`            0x50008004,        2, base=16,    bitRange=8-8
 1106                           ;`GPIO0ISL.P0_9`            0x50008004,        2, base=16,    bitRange=9-9
 1107                           ;`GPIO0ISL.P0_10`           0x50008004,        2, base=16,    bitRange=10-10
 1108                           ;`GPIO0ISL.P0_11`           0x50008004,        2, base=16,    bitRange=11-11
 1109                           
 1110                           GPIO0IBE                 EQU  0x50008008
 1111                           ;`GPIO0IBE.P0_0`            0x50008008,        4, base=16,    bitRange=0-0
 1112                           ;`GPIO0IBE.P0_1`            0x50008008,        4, base=16,    bitRange=1-1
 1113                           ;`GPIO0IBE.P0_2`            0x50008008,        4, base=16,    bitRange=2-2
 1114                           ;`GPIO0IBE.P0_3`            0x50008008,        4, base=16,    bitRange=3-3
 1115                           ;`GPIO0IBE.P0_4`            0x50008008,        4, base=16,    bitRange=4-4
 1116                           ;`GPIO0IBE.P0_5`            0x50008008,        4, base=16,    bitRange=5-5
 1117                           ;`GPIO0IBE.P0_6`            0x50008008,        4, base=16,    bitRange=6-6
 1118                           ;`GPIO0IBE.P0_7`            0x50008008,        4, base=16,    bitRange=7-7
 1119                           ;`GPIO0IBE.P0_8`            0x50008008,        4, base=16,    bitRange=8-8
 1120                           ;`GPIO0IBE.P0_9`            0x50008008,        4, base=16,    bitRange=9-9
 1121                           ;`GPIO0IBE.P0_10`           0x50008008,        4, base=16,    bitRange=10-10
 1122                           ;`GPIO0IBE.P0_11`           0x50008008,        4, base=16,    bitRange=11-11
 1123                           
 1124                           GPIO0IBE0                EQU  0x50008008
 1125                           ;`GPIO0IBE0.P0_0`           0x50008008,        1, base=16,    bitRange=0-0
 1126                           ;`GPIO0IBE0.P0_1`           0x50008008,        1, base=16,    bitRange=1-1
 1127                           ;`GPIO0IBE0.P0_2`           0x50008008,        1, base=16,    bitRange=2-2
 1128                           ;`GPIO0IBE0.P0_3`           0x50008008,        1, base=16,    bitRange=3-3
 1129                           ;`GPIO0IBE0.P0_4`           0x50008008,        1, base=16,    bitRange=4-4
 1130                           ;`GPIO0IBE0.P0_5`           0x50008008,        1, base=16,    bitRange=5-5
 1131                           ;`GPIO0IBE0.P0_6`           0x50008008,        1, base=16,    bitRange=6-6
 1132                           ;`GPIO0IBE0.P0_7`           0x50008008,        1, base=16,    bitRange=7-7
 1133                           
 1134                           GPIO0IBE1                EQU  0x50008009
 1135                           ;`GPIO0IBE1.P0_8`           0x50008009,        1, base=16,    bitRange=0-0
 1136                           ;`GPIO0IBE1.P0_9`           0x50008009,        1, base=16,    bitRange=1-1
 1137                           ;`GPIO0IBE1.P0_10`          0x50008009,        1, base=16,    bitRange=2-2
 1138                           ;`GPIO0IBE1.P0_11`          0x50008009,        1, base=16,    bitRange=3-3
 1139                           
 1140                           GPIO0IBEL                EQU  0x50008008
 1141                           ;`GPIO0IBEL.P0_0`           0x50008008,        2, base=16,    bitRange=0-0
 1142                           ;`GPIO0IBEL.P0_1`           0x50008008,        2, base=16,    bitRange=1-1
 1143                           ;`GPIO0IBEL.P0_2`           0x50008008,        2, base=16,    bitRange=2-2
 1144                           ;`GPIO0IBEL.P0_3`           0x50008008,        2, base=16,    bitRange=3-3
 1145                           ;`GPIO0IBEL.P0_4`           0x50008008,        2, base=16,    bitRange=4-4
 1146                           ;`GPIO0IBEL.P0_5`           0x50008008,        2, base=16,    bitRange=5-5
 1147                           ;`GPIO0IBEL.P0_6`           0x50008008,        2, base=16,    bitRange=6-6
 1148                           ;`GPIO0IBEL.P0_7`           0x50008008,        2, base=16,    bitRange=7-7
 1149                           ;`GPIO0IBEL.P0_8`           0x50008008,        2, base=16,    bitRange=8-8
 1150                           ;`GPIO0IBEL.P0_9`           0x50008008,        2, base=16,    bitRange=9-9
 1151                           ;`GPIO0IBEL.P0_10`          0x50008008,        2, base=16,    bitRange=10-10
 1152                           ;`GPIO0IBEL.P0_11`          0x50008008,        2, base=16,    bitRange=11-11
 1153                           
 1154                           GPIO0IEV                 EQU  0x5000800C
 1155                           ;`GPIO0IEV.P0_0`            0x5000800C,        4, base=16,    bitRange=0-0
 1156                           ;`GPIO0IEV.P0_1`            0x5000800C,        4, base=16,    bitRange=1-1
 1157                           ;`GPIO0IEV.P0_2`            0x5000800C,        4, base=16,    bitRange=2-2
 1158                           ;`GPIO0IEV.P0_3`            0x5000800C,        4, base=16,    bitRange=3-3
 1159                           ;`GPIO0IEV.P0_4`            0x5000800C,        4, base=16,    bitRange=4-4
 1160                           ;`GPIO0IEV.P0_5`            0x5000800C,        4, base=16,    bitRange=5-5
 1161                           ;`GPIO0IEV.P0_6`            0x5000800C,        4, base=16,    bitRange=6-6
 1162                           ;`GPIO0IEV.P0_7`            0x5000800C,        4, base=16,    bitRange=7-7
 1163                           ;`GPIO0IEV.P0_8`            0x5000800C,        4, base=16,    bitRange=8-8
 1164                           ;`GPIO0IEV.P0_9`            0x5000800C,        4, base=16,    bitRange=9-9
 1165                           ;`GPIO0IEV.P0_10`           0x5000800C,        4, base=16,    bitRange=10-10
 1166                           ;`GPIO0IEV.P0_11`           0x5000800C,        4, base=16,    bitRange=11-11
 1167                           
 1168                           GPIO0IEV0                EQU  0x5000800C
 1169                           ;`GPIO0IEV0.P0_0`           0x5000800C,        1, base=16,    bitRange=0-0
 1170                           ;`GPIO0IEV0.P0_1`           0x5000800C,        1, base=16,    bitRange=1-1
 1171                           ;`GPIO0IEV0.P0_2`           0x5000800C,        1, base=16,    bitRange=2-2
 1172                           ;`GPIO0IEV0.P0_3`           0x5000800C,        1, base=16,    bitRange=3-3
 1173                           ;`GPIO0IEV0.P0_4`           0x5000800C,        1, base=16,    bitRange=4-4
 1174                           ;`GPIO0IEV0.P0_5`           0x5000800C,        1, base=16,    bitRange=5-5
 1175                           ;`GPIO0IEV0.P0_6`           0x5000800C,        1, base=16,    bitRange=6-6
 1176                           ;`GPIO0IEV0.P0_7`           0x5000800C,        1, base=16,    bitRange=7-7
 1177                           
 1178                           GPIO0IEV1                EQU  0x5000800D
 1179                           ;`GPIO0IEV1.P0_8`           0x5000800D,        1, base=16,    bitRange=0-0
 1180                           ;`GPIO0IEV1.P0_9`           0x5000800D,        1, base=16,    bitRange=1-1
 1181                           ;`GPIO0IEV1.P0_10`          0x5000800D,        1, base=16,    bitRange=2-2
 1182                           ;`GPIO0IEV1.P0_11`          0x5000800D,        1, base=16,    bitRange=3-3
 1183                           
 1184                           GPIO0IEVL                EQU  0x5000800C
 1185                           ;`GPIO0IEVL.P0_0`           0x5000800C,        2, base=16,    bitRange=0-0
 1186                           ;`GPIO0IEVL.P0_1`           0x5000800C,        2, base=16,    bitRange=1-1
 1187                           ;`GPIO0IEVL.P0_2`           0x5000800C,        2, base=16,    bitRange=2-2
 1188                           ;`GPIO0IEVL.P0_3`           0x5000800C,        2, base=16,    bitRange=3-3
 1189                           ;`GPIO0IEVL.P0_4`           0x5000800C,        2, base=16,    bitRange=4-4
 1190                           ;`GPIO0IEVL.P0_5`           0x5000800C,        2, base=16,    bitRange=5-5
 1191                           ;`GPIO0IEVL.P0_6`           0x5000800C,        2, base=16,    bitRange=6-6
 1192                           ;`GPIO0IEVL.P0_7`           0x5000800C,        2, base=16,    bitRange=7-7
 1193                           ;`GPIO0IEVL.P0_8`           0x5000800C,        2, base=16,    bitRange=8-8
 1194                           ;`GPIO0IEVL.P0_9`           0x5000800C,        2, base=16,    bitRange=9-9
 1195                           ;`GPIO0IEVL.P0_10`          0x5000800C,        2, base=16,    bitRange=10-10
 1196                           ;`GPIO0IEVL.P0_11`          0x5000800C,        2, base=16,    bitRange=11-11
 1197                           
 1198                           GPIO0IE                  EQU  0x50008010
 1199                           ;`GPIO0IE.P0_0`             0x50008010,        4, base=16,    bitRange=0-0
 1200                           ;`GPIO0IE.P0_1`             0x50008010,        4, base=16,    bitRange=1-1
 1201                           ;`GPIO0IE.P0_2`             0x50008010,        4, base=16,    bitRange=2-2
 1202                           ;`GPIO0IE.P0_3`             0x50008010,        4, base=16,    bitRange=3-3
 1203                           ;`GPIO0IE.P0_4`             0x50008010,        4, base=16,    bitRange=4-4
 1204                           ;`GPIO0IE.P0_5`             0x50008010,        4, base=16,    bitRange=5-5
 1205                           ;`GPIO0IE.P0_6`             0x50008010,        4, base=16,    bitRange=6-6
 1206                           ;`GPIO0IE.P0_7`             0x50008010,        4, base=16,    bitRange=7-7
 1207                           ;`GPIO0IE.P0_8`             0x50008010,        4, base=16,    bitRange=8-8
 1208                           ;`GPIO0IE.P0_9`             0x50008010,        4, base=16,    bitRange=9-9
 1209                           ;`GPIO0IE.P0_10`            0x50008010,        4, base=16,    bitRange=10-10
 1210                           ;`GPIO0IE.P0_11`            0x50008010,        4, base=16,    bitRange=11-11
 1211                           
 1212                           GPIO0IE0                 EQU  0x50008010
 1213                           ;`GPIO0IE0.P0_0`            0x50008010,        1, base=16,    bitRange=0-0
 1214                           ;`GPIO0IE0.P0_1`            0x50008010,        1, base=16,    bitRange=1-1
 1215                           ;`GPIO0IE0.P0_2`            0x50008010,        1, base=16,    bitRange=2-2
 1216                           ;`GPIO0IE0.P0_3`            0x50008010,        1, base=16,    bitRange=3-3
 1217                           ;`GPIO0IE0.P0_4`            0x50008010,        1, base=16,    bitRange=4-4
 1218                           ;`GPIO0IE0.P0_5`            0x50008010,        1, base=16,    bitRange=5-5
 1219                           ;`GPIO0IE0.P0_6`            0x50008010,        1, base=16,    bitRange=6-6
 1220                           ;`GPIO0IE0.P0_7`            0x50008010,        1, base=16,    bitRange=7-7
 1221                           
 1222                           GPIO0IE1                 EQU  0x50008011
 1223                           ;`GPIO0IE1.P0_8`            0x50008011,        1, base=16,    bitRange=0-0
 1224                           ;`GPIO0IE1.P0_9`            0x50008011,        1, base=16,    bitRange=1-1
 1225                           ;`GPIO0IE1.P0_10`           0x50008011,        1, base=16,    bitRange=2-2
 1226                           ;`GPIO0IE1.P0_11`           0x50008011,        1, base=16,    bitRange=3-3
 1227                           
 1228                           GPIO0IEL                 EQU  0x50008010
 1229                           ;`GPIO0IEL.P0_0`            0x50008010,        2, base=16,    bitRange=0-0
 1230                           ;`GPIO0IEL.P0_1`            0x50008010,        2, base=16,    bitRange=1-1
 1231                           ;`GPIO0IEL.P0_2`            0x50008010,        2, base=16,    bitRange=2-2
 1232                           ;`GPIO0IEL.P0_3`            0x50008010,        2, base=16,    bitRange=3-3
 1233                           ;`GPIO0IEL.P0_4`            0x50008010,        2, base=16,    bitRange=4-4
 1234                           ;`GPIO0IEL.P0_5`            0x50008010,        2, base=16,    bitRange=5-5
 1235                           ;`GPIO0IEL.P0_6`            0x50008010,        2, base=16,    bitRange=6-6
 1236                           ;`GPIO0IEL.P0_7`            0x50008010,        2, base=16,    bitRange=7-7
 1237                           ;`GPIO0IEL.P0_8`            0x50008010,        2, base=16,    bitRange=8-8
 1238                           ;`GPIO0IEL.P0_9`            0x50008010,        2, base=16,    bitRange=9-9
 1239                           ;`GPIO0IEL.P0_10`           0x50008010,        2, base=16,    bitRange=10-10
 1240                           ;`GPIO0IEL.P0_11`           0x50008010,        2, base=16,    bitRange=11-11
 1241                           
 1242                           GPIO0RIS                 EQU  0x50008014
 1243                           ;`GPIO0RIS.P0_0`            0x50008014,        4, base=16,    bitRange=0-0
 1244                           ;`GPIO0RIS.P0_1`            0x50008014,        4, base=16,    bitRange=1-1
 1245                           ;`GPIO0RIS.P0_2`            0x50008014,        4, base=16,    bitRange=2-2
 1246                           ;`GPIO0RIS.P0_3`            0x50008014,        4, base=16,    bitRange=3-3
 1247                           ;`GPIO0RIS.P0_4`            0x50008014,        4, base=16,    bitRange=4-4
 1248                           ;`GPIO0RIS.P0_5`            0x50008014,        4, base=16,    bitRange=5-5
 1249                           ;`GPIO0RIS.P0_6`            0x50008014,        4, base=16,    bitRange=6-6
 1250                           ;`GPIO0RIS.P0_7`            0x50008014,        4, base=16,    bitRange=7-7
 1251                           ;`GPIO0RIS.P0_8`            0x50008014,        4, base=16,    bitRange=8-8
 1252                           ;`GPIO0RIS.P0_9`            0x50008014,        4, base=16,    bitRange=9-9
 1253                           ;`GPIO0RIS.P0_10`           0x50008014,        4, base=16,    bitRange=10-10
 1254                           ;`GPIO0RIS.P0_11`           0x50008014,        4, base=16,    bitRange=11-11
 1255                           
 1256                           GPIO0RIS0                EQU  0x50008014
 1257                           ;`GPIO0RIS0.P0_0`           0x50008014,        1, base=16,    bitRange=0-0
 1258                           ;`GPIO0RIS0.P0_1`           0x50008014,        1, base=16,    bitRange=1-1
 1259                           ;`GPIO0RIS0.P0_2`           0x50008014,        1, base=16,    bitRange=2-2
 1260                           ;`GPIO0RIS0.P0_3`           0x50008014,        1, base=16,    bitRange=3-3
 1261                           ;`GPIO0RIS0.P0_4`           0x50008014,        1, base=16,    bitRange=4-4
 1262                           ;`GPIO0RIS0.P0_5`           0x50008014,        1, base=16,    bitRange=5-5
 1263                           ;`GPIO0RIS0.P0_6`           0x50008014,        1, base=16,    bitRange=6-6
 1264                           ;`GPIO0RIS0.P0_7`           0x50008014,        1, base=16,    bitRange=7-7
 1265                           
 1266                           GPIO0RIS1                EQU  0x50008015
 1267                           ;`GPIO0RIS1.P0_8`           0x50008015,        1, base=16,    bitRange=0-0
 1268                           ;`GPIO0RIS1.P0_9`           0x50008015,        1, base=16,    bitRange=1-1
 1269                           ;`GPIO0RIS1.P0_10`          0x50008015,        1, base=16,    bitRange=2-2
 1270                           ;`GPIO0RIS1.P0_11`          0x50008015,        1, base=16,    bitRange=3-3
 1271                           
 1272                           GPIO0RISL                EQU  0x50008014
 1273                           ;`GPIO0RISL.P0_0`           0x50008014,        2, base=16,    bitRange=0-0
 1274                           ;`GPIO0RISL.P0_1`           0x50008014,        2, base=16,    bitRange=1-1
 1275                           ;`GPIO0RISL.P0_2`           0x50008014,        2, base=16,    bitRange=2-2
 1276                           ;`GPIO0RISL.P0_3`           0x50008014,        2, base=16,    bitRange=3-3
 1277                           ;`GPIO0RISL.P0_4`           0x50008014,        2, base=16,    bitRange=4-4
 1278                           ;`GPIO0RISL.P0_5`           0x50008014,        2, base=16,    bitRange=5-5
 1279                           ;`GPIO0RISL.P0_6`           0x50008014,        2, base=16,    bitRange=6-6
 1280                           ;`GPIO0RISL.P0_7`           0x50008014,        2, base=16,    bitRange=7-7
 1281                           ;`GPIO0RISL.P0_8`           0x50008014,        2, base=16,    bitRange=8-8
 1282                           ;`GPIO0RISL.P0_9`           0x50008014,        2, base=16,    bitRange=9-9
 1283                           ;`GPIO0RISL.P0_10`          0x50008014,        2, base=16,    bitRange=10-10
 1284                           ;`GPIO0RISL.P0_11`          0x50008014,        2, base=16,    bitRange=11-11
 1285                           
 1286                           GPIO0MIS                 EQU  0x50008018
 1287                           ;`GPIO0MIS.P0_0`            0x50008018,        4, base=16,    bitRange=0-0
 1288                           ;`GPIO0MIS.P0_1`            0x50008018,        4, base=16,    bitRange=1-1
 1289                           ;`GPIO0MIS.P0_2`            0x50008018,        4, base=16,    bitRange=2-2
 1290                           ;`GPIO0MIS.P0_3`            0x50008018,        4, base=16,    bitRange=3-3
 1291                           ;`GPIO0MIS.P0_4`            0x50008018,        4, base=16,    bitRange=4-4
 1292                           ;`GPIO0MIS.P0_5`            0x50008018,        4, base=16,    bitRange=5-5
 1293                           ;`GPIO0MIS.P0_6`            0x50008018,        4, base=16,    bitRange=6-6
 1294                           ;`GPIO0MIS.P0_7`            0x50008018,        4, base=16,    bitRange=7-7
 1295                           ;`GPIO0MIS.P0_8`            0x50008018,        4, base=16,    bitRange=8-8
 1296                           ;`GPIO0MIS.P0_9`            0x50008018,        4, base=16,    bitRange=9-9
 1297                           ;`GPIO0MIS.P0_10`           0x50008018,        4, base=16,    bitRange=10-10
 1298                           ;`GPIO0MIS.P0_11`           0x50008018,        4, base=16,    bitRange=11-11
 1299                           
 1300                           GPIO0MIS0                EQU  0x50008018
 1301                           ;`GPIO0MIS0.P0_0`           0x50008018,        1, base=16,    bitRange=0-0
 1302                           ;`GPIO0MIS0.P0_1`           0x50008018,        1, base=16,    bitRange=1-1
 1303                           ;`GPIO0MIS0.P0_2`           0x50008018,        1, base=16,    bitRange=2-2
 1304                           ;`GPIO0MIS0.P0_3`           0x50008018,        1, base=16,    bitRange=3-3
 1305                           ;`GPIO0MIS0.P0_4`           0x50008018,        1, base=16,    bitRange=4-4
 1306                           ;`GPIO0MIS0.P0_5`           0x50008018,        1, base=16,    bitRange=5-5
 1307                           ;`GPIO0MIS0.P0_6`           0x50008018,        1, base=16,    bitRange=6-6
 1308                           ;`GPIO0MIS0.P0_7`           0x50008018,        1, base=16,    bitRange=7-7
 1309                           
 1310                           GPIO0MIS1                EQU  0x50008019
 1311                           ;`GPIO0MIS1.P0_8`           0x50008019,        1, base=16,    bitRange=0-0
 1312                           ;`GPIO0MIS1.P0_9`           0x50008019,        1, base=16,    bitRange=1-1
 1313                           ;`GPIO0MIS1.P0_10`          0x50008019,        1, base=16,    bitRange=2-2
 1314                           ;`GPIO0MIS1.P0_11`          0x50008019,        1, base=16,    bitRange=3-3
 1315                           
 1316                           GPIO0MISL                EQU  0x50008018
 1317                           ;`GPIO0MISL.P0_0`           0x50008018,        2, base=16,    bitRange=0-0
 1318                           ;`GPIO0MISL.P0_1`           0x50008018,        2, base=16,    bitRange=1-1
 1319                           ;`GPIO0MISL.P0_2`           0x50008018,        2, base=16,    bitRange=2-2
 1320                           ;`GPIO0MISL.P0_3`           0x50008018,        2, base=16,    bitRange=3-3
 1321                           ;`GPIO0MISL.P0_4`           0x50008018,        2, base=16,    bitRange=4-4
 1322                           ;`GPIO0MISL.P0_5`           0x50008018,        2, base=16,    bitRange=5-5
 1323                           ;`GPIO0MISL.P0_6`           0x50008018,        2, base=16,    bitRange=6-6
 1324                           ;`GPIO0MISL.P0_7`           0x50008018,        2, base=16,    bitRange=7-7
 1325                           ;`GPIO0MISL.P0_8`           0x50008018,        2, base=16,    bitRange=8-8
 1326                           ;`GPIO0MISL.P0_9`           0x50008018,        2, base=16,    bitRange=9-9
 1327                           ;`GPIO0MISL.P0_10`          0x50008018,        2, base=16,    bitRange=10-10
 1328                           ;`GPIO0MISL.P0_11`          0x50008018,        2, base=16,    bitRange=11-11
 1329                           
 1330                           GPIO0IC                  EQU  0x5000801C
 1331                           
 1332                           GPIO1DATA                EQU  0x50013FFC
 1333                           ;`GPIO1DATA.P1_0`           0x50013FFC,        4, base=16,    bitRange=0-0
 1334                           ;`GPIO1DATA.P1_1`           0x50013FFC,        4, base=16,    bitRange=1-1
 1335                           ;`GPIO1DATA.P1_2`           0x50013FFC,        4, base=16,    bitRange=2-2
 1336                           ;`GPIO1DATA.P1_3`           0x50013FFC,        4, base=16,    bitRange=3-3
 1337                           ;`GPIO1DATA.P1_4`           0x50013FFC,        4, base=16,    bitRange=4-4
 1338                           ;`GPIO1DATA.P1_5`           0x50013FFC,        4, base=16,    bitRange=5-5
 1339                           ;`GPIO1DATA.P1_6`           0x50013FFC,        4, base=16,    bitRange=6-6
 1340                           ;`GPIO1DATA.P1_7`           0x50013FFC,        4, base=16,    bitRange=7-7
 1341                           ;`GPIO1DATA.P1_8`           0x50013FFC,        4, base=16,    bitRange=8-8
 1342                           ;`GPIO1DATA.P1_9`           0x50013FFC,        4, base=16,    bitRange=9-9
 1343                           ;`GPIO1DATA.P1_10`          0x50013FFC,        4, base=16,    bitRange=10-10
 1344                           ;`GPIO1DATA.P1_11`          0x50013FFC,        4, base=16,    bitRange=11-11
 1345                           
 1346                           GPIO1DATA0               EQU  0x50013FFC
 1347                           ;`GPIO1DATA0.P1_0`          0x50013FFC,        1, base=16,    bitRange=0-0
 1348                           ;`GPIO1DATA0.P1_1`          0x50013FFC,        1, base=16,    bitRange=1-1
 1349                           ;`GPIO1DATA0.P1_2`          0x50013FFC,        1, base=16,    bitRange=2-2
 1350                           ;`GPIO1DATA0.P1_3`          0x50013FFC,        1, base=16,    bitRange=3-3
 1351                           ;`GPIO1DATA0.P1_4`          0x50013FFC,        1, base=16,    bitRange=4-4
 1352                           ;`GPIO1DATA0.P1_5`          0x50013FFC,        1, base=16,    bitRange=5-5
 1353                           ;`GPIO1DATA0.P1_6`          0x50013FFC,        1, base=16,    bitRange=6-6
 1354                           ;`GPIO1DATA0.P1_7`          0x50013FFC,        1, base=16,    bitRange=7-7
 1355                           
 1356                           GPIO1DATA1               EQU  0x50013FFD
 1357                           ;`GPIO1DATA1.P1_8`          0x50013FFD,        1, base=16,    bitRange=0-0
 1358                           ;`GPIO1DATA1.P1_9`          0x50013FFD,        1, base=16,    bitRange=1-1
 1359                           ;`GPIO1DATA1.P1_10`         0x50013FFD,        1, base=16,    bitRange=2-2
 1360                           ;`GPIO1DATA1.P1_11`         0x50013FFD,        1, base=16,    bitRange=3-3
 1361                           
 1362                           GPIO1DATAL               EQU  0x50013FFC
 1363                           ;`GPIO1DATAL.P1_0`          0x50013FFC,        2, base=16,    bitRange=0-0
 1364                           ;`GPIO1DATAL.P1_1`          0x50013FFC,        2, base=16,    bitRange=1-1
 1365                           ;`GPIO1DATAL.P1_2`          0x50013FFC,        2, base=16,    bitRange=2-2
 1366                           ;`GPIO1DATAL.P1_3`          0x50013FFC,        2, base=16,    bitRange=3-3
 1367                           ;`GPIO1DATAL.P1_4`          0x50013FFC,        2, base=16,    bitRange=4-4
 1368                           ;`GPIO1DATAL.P1_5`          0x50013FFC,        2, base=16,    bitRange=5-5
 1369                           ;`GPIO1DATAL.P1_6`          0x50013FFC,        2, base=16,    bitRange=6-6
 1370                           ;`GPIO1DATAL.P1_7`          0x50013FFC,        2, base=16,    bitRange=7-7
 1371                           ;`GPIO1DATAL.P1_8`          0x50013FFC,        2, base=16,    bitRange=8-8
 1372                           ;`GPIO1DATAL.P1_9`          0x50013FFC,        2, base=16,    bitRange=9-9
 1373                           ;`GPIO1DATAL.P1_10`         0x50013FFC,        2, base=16,    bitRange=10-10
 1374                           ;`GPIO1DATAL.P1_11`         0x50013FFC,        2, base=16,    bitRange=11-11
 1375                           
 1376                           GPIO1DIR                 EQU  0x50018000
 1377                           ;`GPIO1DIR.P1_0`            0x50018000,        4, base=16,    bitRange=0-0
 1378                           ;`GPIO1DIR.P1_1`            0x50018000,        4, base=16,    bitRange=1-1
 1379                           ;`GPIO1DIR.P1_2`            0x50018000,        4, base=16,    bitRange=2-2
 1380                           ;`GPIO1DIR.P1_3`            0x50018000,        4, base=16,    bitRange=3-3
 1381                           ;`GPIO1DIR.P1_4`            0x50018000,        4, base=16,    bitRange=4-4
 1382                           ;`GPIO1DIR.P1_5`            0x50018000,        4, base=16,    bitRange=5-5
 1383                           ;`GPIO1DIR.P1_6`            0x50018000,        4, base=16,    bitRange=6-6
 1384                           ;`GPIO1DIR.P1_7`            0x50018000,        4, base=16,    bitRange=7-7
 1385                           ;`GPIO1DIR.P1_8`            0x50018000,        4, base=16,    bitRange=8-8
 1386                           ;`GPIO1DIR.P1_9`            0x50018000,        4, base=16,    bitRange=9-9
 1387                           ;`GPIO1DIR.P1_10`           0x50018000,        4, base=16,    bitRange=10-10
 1388                           ;`GPIO1DIR.P1_11`           0x50018000,        4, base=16,    bitRange=11-11
 1389                           
 1390                           GPIO1DIR0                EQU  0x50018000
 1391                           ;`GPIO1DIR0.P1_0`           0x50018000,        1, base=16,    bitRange=0-0
 1392                           ;`GPIO1DIR0.P1_1`           0x50018000,        1, base=16,    bitRange=1-1
 1393                           ;`GPIO1DIR0.P1_2`           0x50018000,        1, base=16,    bitRange=2-2
 1394                           ;`GPIO1DIR0.P1_3`           0x50018000,        1, base=16,    bitRange=3-3
 1395                           ;`GPIO1DIR0.P1_4`           0x50018000,        1, base=16,    bitRange=4-4
 1396                           ;`GPIO1DIR0.P1_5`           0x50018000,        1, base=16,    bitRange=5-5
 1397                           ;`GPIO1DIR0.P1_6`           0x50018000,        1, base=16,    bitRange=6-6
 1398                           ;`GPIO1DIR0.P1_7`           0x50018000,        1, base=16,    bitRange=7-7
 1399                           
 1400                           GPIO1DIR1                EQU  0x50018001
 1401                           ;`GPIO1DIR1.P1_8`           0x50018001,        1, base=16,    bitRange=0-0
 1402                           ;`GPIO1DIR1.P1_9`           0x50018001,        1, base=16,    bitRange=1-1
 1403                           ;`GPIO1DIR1.P1_10`          0x50018001,        1, base=16,    bitRange=2-2
 1404                           ;`GPIO1DIR1.P1_11`          0x50018001,        1, base=16,    bitRange=3-3
 1405                           
 1406                           GPIO1DIRL                EQU  0x50018000
 1407                           ;`GPIO1DIRL.P1_0`           0x50018000,        2, base=16,    bitRange=0-0
 1408                           ;`GPIO1DIRL.P1_1`           0x50018000,        2, base=16,    bitRange=1-1
 1409                           ;`GPIO1DIRL.P1_2`           0x50018000,        2, base=16,    bitRange=2-2
 1410                           ;`GPIO1DIRL.P1_3`           0x50018000,        2, base=16,    bitRange=3-3
 1411                           ;`GPIO1DIRL.P1_4`           0x50018000,        2, base=16,    bitRange=4-4
 1412                           ;`GPIO1DIRL.P1_5`           0x50018000,        2, base=16,    bitRange=5-5
 1413                           ;`GPIO1DIRL.P1_6`           0x50018000,        2, base=16,    bitRange=6-6
 1414                           ;`GPIO1DIRL.P1_7`           0x50018000,        2, base=16,    bitRange=7-7
 1415                           ;`GPIO1DIRL.P1_8`           0x50018000,        2, base=16,    bitRange=8-8
 1416                           ;`GPIO1DIRL.P1_9`           0x50018000,        2, base=16,    bitRange=9-9
 1417                           ;`GPIO1DIRL.P1_10`          0x50018000,        2, base=16,    bitRange=10-10
 1418                           ;`GPIO1DIRL.P1_11`          0x50018000,        2, base=16,    bitRange=11-11
 1419                           
 1420                           GPIO1IS                  EQU  0x50018004
 1421                           ;`GPIO1IS.P1_0`             0x50018004,        4, base=16,    bitRange=0-0
 1422                           ;`GPIO1IS.P1_1`             0x50018004,        4, base=16,    bitRange=1-1
 1423                           ;`GPIO1IS.P1_2`             0x50018004,        4, base=16,    bitRange=2-2
 1424                           ;`GPIO1IS.P1_3`             0x50018004,        4, base=16,    bitRange=3-3
 1425                           ;`GPIO1IS.P1_4`             0x50018004,        4, base=16,    bitRange=4-4
 1426                           ;`GPIO1IS.P1_5`             0x50018004,        4, base=16,    bitRange=5-5
 1427                           ;`GPIO1IS.P1_6`             0x50018004,        4, base=16,    bitRange=6-6
 1428                           ;`GPIO1IS.P1_7`             0x50018004,        4, base=16,    bitRange=7-7
 1429                           ;`GPIO1IS.P1_8`             0x50018004,        4, base=16,    bitRange=8-8
 1430                           ;`GPIO1IS.P1_9`             0x50018004,        4, base=16,    bitRange=9-9
 1431                           ;`GPIO1IS.P1_10`            0x50018004,        4, base=16,    bitRange=10-10
 1432                           ;`GPIO1IS.P1_11`            0x50018004,        4, base=16,    bitRange=11-11
 1433                           
 1434                           GPIO1IS0                 EQU  0x50018004
 1435                           ;`GPIO1IS0.P1_0`            0x50018004,        1, base=16,    bitRange=0-0
 1436                           ;`GPIO1IS0.P1_1`            0x50018004,        1, base=16,    bitRange=1-1
 1437                           ;`GPIO1IS0.P1_2`            0x50018004,        1, base=16,    bitRange=2-2
 1438                           ;`GPIO1IS0.P1_3`            0x50018004,        1, base=16,    bitRange=3-3
 1439                           ;`GPIO1IS0.P1_4`            0x50018004,        1, base=16,    bitRange=4-4
 1440                           ;`GPIO1IS0.P1_5`            0x50018004,        1, base=16,    bitRange=5-5
 1441                           ;`GPIO1IS0.P1_6`            0x50018004,        1, base=16,    bitRange=6-6
 1442                           ;`GPIO1IS0.P1_7`            0x50018004,        1, base=16,    bitRange=7-7
 1443                           
 1444                           GPIO1IS1                 EQU  0x50018005
 1445                           ;`GPIO1IS1.P1_8`            0x50018005,        1, base=16,    bitRange=0-0
 1446                           ;`GPIO1IS1.P1_9`            0x50018005,        1, base=16,    bitRange=1-1
 1447                           ;`GPIO1IS1.P1_10`           0x50018005,        1, base=16,    bitRange=2-2
 1448                           ;`GPIO1IS1.P1_11`           0x50018005,        1, base=16,    bitRange=3-3
 1449                           
 1450                           GPIO1ISL                 EQU  0x50018004
 1451                           ;`GPIO1ISL.P1_0`            0x50018004,        2, base=16,    bitRange=0-0
 1452                           ;`GPIO1ISL.P1_1`            0x50018004,        2, base=16,    bitRange=1-1
 1453                           ;`GPIO1ISL.P1_2`            0x50018004,        2, base=16,    bitRange=2-2
 1454                           ;`GPIO1ISL.P1_3`            0x50018004,        2, base=16,    bitRange=3-3
 1455                           ;`GPIO1ISL.P1_4`            0x50018004,        2, base=16,    bitRange=4-4
 1456                           ;`GPIO1ISL.P1_5`            0x50018004,        2, base=16,    bitRange=5-5
 1457                           ;`GPIO1ISL.P1_6`            0x50018004,        2, base=16,    bitRange=6-6
 1458                           ;`GPIO1ISL.P1_7`            0x50018004,        2, base=16,    bitRange=7-7
 1459                           ;`GPIO1ISL.P1_8`            0x50018004,        2, base=16,    bitRange=8-8
 1460                           ;`GPIO1ISL.P1_9`            0x50018004,        2, base=16,    bitRange=9-9
 1461                           ;`GPIO1ISL.P1_10`           0x50018004,        2, base=16,    bitRange=10-10
 1462                           ;`GPIO1ISL.P1_11`           0x50018004,        2, base=16,    bitRange=11-11
 1463                           
 1464                           GPIO1IBE                 EQU  0x50018008
 1465                           ;`GPIO1IBE.P1_0`            0x50018008,        4, base=16,    bitRange=0-0
 1466                           ;`GPIO1IBE.P1_1`            0x50018008,        4, base=16,    bitRange=1-1
 1467                           ;`GPIO1IBE.P1_2`            0x50018008,        4, base=16,    bitRange=2-2
 1468                           ;`GPIO1IBE.P1_3`            0x50018008,        4, base=16,    bitRange=3-3
 1469                           ;`GPIO1IBE.P1_4`            0x50018008,        4, base=16,    bitRange=4-4
 1470                           ;`GPIO1IBE.P1_5`            0x50018008,        4, base=16,    bitRange=5-5
 1471                           ;`GPIO1IBE.P1_6`            0x50018008,        4, base=16,    bitRange=6-6
 1472                           ;`GPIO1IBE.P1_7`            0x50018008,        4, base=16,    bitRange=7-7
 1473                           ;`GPIO1IBE.P1_8`            0x50018008,        4, base=16,    bitRange=8-8
 1474                           ;`GPIO1IBE.P1_9`            0x50018008,        4, base=16,    bitRange=9-9
 1475                           ;`GPIO1IBE.P1_10`           0x50018008,        4, base=16,    bitRange=10-10
 1476                           ;`GPIO1IBE.P1_11`           0x50018008,        4, base=16,    bitRange=11-11
 1477                           
 1478                           GPIO1IBE0                EQU  0x50018008
 1479                           ;`GPIO1IBE0.P1_0`           0x50018008,        1, base=16,    bitRange=0-0
 1480                           ;`GPIO1IBE0.P1_1`           0x50018008,        1, base=16,    bitRange=1-1
 1481                           ;`GPIO1IBE0.P1_2`           0x50018008,        1, base=16,    bitRange=2-2
 1482                           ;`GPIO1IBE0.P1_3`           0x50018008,        1, base=16,    bitRange=3-3
 1483                           ;`GPIO1IBE0.P1_4`           0x50018008,        1, base=16,    bitRange=4-4
 1484                           ;`GPIO1IBE0.P1_5`           0x50018008,        1, base=16,    bitRange=5-5
 1485                           ;`GPIO1IBE0.P1_6`           0x50018008,        1, base=16,    bitRange=6-6
 1486                           ;`GPIO1IBE0.P1_7`           0x50018008,        1, base=16,    bitRange=7-7
 1487                           
 1488                           GPIO1IBE1                EQU  0x50018009
 1489                           ;`GPIO1IBE1.P1_8`           0x50018009,        1, base=16,    bitRange=0-0
 1490                           ;`GPIO1IBE1.P1_9`           0x50018009,        1, base=16,    bitRange=1-1
 1491                           ;`GPIO1IBE1.P1_10`          0x50018009,        1, base=16,    bitRange=2-2
 1492                           ;`GPIO1IBE1.P1_11`          0x50018009,        1, base=16,    bitRange=3-3
 1493                           
 1494                           GPIO1IBEL                EQU  0x50018008
 1495                           ;`GPIO1IBEL.P1_0`           0x50018008,        2, base=16,    bitRange=0-0
 1496                           ;`GPIO1IBEL.P1_1`           0x50018008,        2, base=16,    bitRange=1-1
 1497                           ;`GPIO1IBEL.P1_2`           0x50018008,        2, base=16,    bitRange=2-2
 1498                           ;`GPIO1IBEL.P1_3`           0x50018008,        2, base=16,    bitRange=3-3
 1499                           ;`GPIO1IBEL.P1_4`           0x50018008,        2, base=16,    bitRange=4-4
 1500                           ;`GPIO1IBEL.P1_5`           0x50018008,        2, base=16,    bitRange=5-5
 1501                           ;`GPIO1IBEL.P1_6`           0x50018008,        2, base=16,    bitRange=6-6
 1502                           ;`GPIO1IBEL.P1_7`           0x50018008,        2, base=16,    bitRange=7-7
 1503                           ;`GPIO1IBEL.P1_8`           0x50018008,        2, base=16,    bitRange=8-8
 1504                           ;`GPIO1IBEL.P1_9`           0x50018008,        2, base=16,    bitRange=9-9
 1505                           ;`GPIO1IBEL.P1_10`          0x50018008,        2, base=16,    bitRange=10-10
 1506                           ;`GPIO1IBEL.P1_11`          0x50018008,        2, base=16,    bitRange=11-11
 1507                           
 1508                           GPIO1IEV                 EQU  0x5001800C
 1509                           ;`GPIO1IEV.P1_0`            0x5001800C,        4, base=16,    bitRange=0-0
 1510                           ;`GPIO1IEV.P1_1`            0x5001800C,        4, base=16,    bitRange=1-1
 1511                           ;`GPIO1IEV.P1_2`            0x5001800C,        4, base=16,    bitRange=2-2
 1512                           ;`GPIO1IEV.P1_3`            0x5001800C,        4, base=16,    bitRange=3-3
 1513                           ;`GPIO1IEV.P1_4`            0x5001800C,        4, base=16,    bitRange=4-4
 1514                           ;`GPIO1IEV.P1_5`            0x5001800C,        4, base=16,    bitRange=5-5
 1515                           ;`GPIO1IEV.P1_6`            0x5001800C,        4, base=16,    bitRange=6-6
 1516                           ;`GPIO1IEV.P1_7`            0x5001800C,        4, base=16,    bitRange=7-7
 1517                           ;`GPIO1IEV.P1_8`            0x5001800C,        4, base=16,    bitRange=8-8
 1518                           ;`GPIO1IEV.P1_9`            0x5001800C,        4, base=16,    bitRange=9-9
 1519                           ;`GPIO1IEV.P1_10`           0x5001800C,        4, base=16,    bitRange=10-10
 1520                           ;`GPIO1IEV.P1_11`           0x5001800C,        4, base=16,    bitRange=11-11
 1521                           
 1522                           GPIO1IEV0                EQU  0x5001800C
 1523                           ;`GPIO1IEV0.P1_0`           0x5001800C,        1, base=16,    bitRange=0-0
 1524                           ;`GPIO1IEV0.P1_1`           0x5001800C,        1, base=16,    bitRange=1-1
 1525                           ;`GPIO1IEV0.P1_2`           0x5001800C,        1, base=16,    bitRange=2-2
 1526                           ;`GPIO1IEV0.P1_3`           0x5001800C,        1, base=16,    bitRange=3-3
 1527                           ;`GPIO1IEV0.P1_4`           0x5001800C,        1, base=16,    bitRange=4-4
 1528                           ;`GPIO1IEV0.P1_5`           0x5001800C,        1, base=16,    bitRange=5-5
 1529                           ;`GPIO1IEV0.P1_6`           0x5001800C,        1, base=16,    bitRange=6-6
 1530                           ;`GPIO1IEV0.P1_7`           0x5001800C,        1, base=16,    bitRange=7-7
 1531                           
 1532                           GPIO1IEV1                EQU  0x5001800D
 1533                           ;`GPIO1IEV1.P1_8`           0x5001800D,        1, base=16,    bitRange=0-0
 1534                           ;`GPIO1IEV1.P1_9`           0x5001800D,        1, base=16,    bitRange=1-1
 1535                           ;`GPIO1IEV1.P1_10`          0x5001800D,        1, base=16,    bitRange=2-2
 1536                           ;`GPIO1IEV1.P1_11`          0x5001800D,        1, base=16,    bitRange=3-3
 1537                           
 1538                           GPIO1IEVL                EQU  0x5001800C
 1539                           ;`GPIO1IEVL.P1_0`           0x5001800C,        2, base=16,    bitRange=0-0
 1540                           ;`GPIO1IEVL.P1_1`           0x5001800C,        2, base=16,    bitRange=1-1
 1541                           ;`GPIO1IEVL.P1_2`           0x5001800C,        2, base=16,    bitRange=2-2
 1542                           ;`GPIO1IEVL.P1_3`           0x5001800C,        2, base=16,    bitRange=3-3
 1543                           ;`GPIO1IEVL.P1_4`           0x5001800C,        2, base=16,    bitRange=4-4
 1544                           ;`GPIO1IEVL.P1_5`           0x5001800C,        2, base=16,    bitRange=5-5
 1545                           ;`GPIO1IEVL.P1_6`           0x5001800C,        2, base=16,    bitRange=6-6
 1546                           ;`GPIO1IEVL.P1_7`           0x5001800C,        2, base=16,    bitRange=7-7
 1547                           ;`GPIO1IEVL.P1_8`           0x5001800C,        2, base=16,    bitRange=8-8
 1548                           ;`GPIO1IEVL.P1_9`           0x5001800C,        2, base=16,    bitRange=9-9
 1549                           ;`GPIO1IEVL.P1_10`          0x5001800C,        2, base=16,    bitRange=10-10
 1550                           ;`GPIO1IEVL.P1_11`          0x5001800C,        2, base=16,    bitRange=11-11
 1551                           
 1552                           GPIO1IE                  EQU  0x50018010
 1553                           ;`GPIO1IE.P1_0`             0x50018010,        4, base=16,    bitRange=0-0
 1554                           ;`GPIO1IE.P1_1`             0x50018010,        4, base=16,    bitRange=1-1
 1555                           ;`GPIO1IE.P1_2`             0x50018010,        4, base=16,    bitRange=2-2
 1556                           ;`GPIO1IE.P1_3`             0x50018010,        4, base=16,    bitRange=3-3
 1557                           ;`GPIO1IE.P1_4`             0x50018010,        4, base=16,    bitRange=4-4
 1558                           ;`GPIO1IE.P1_5`             0x50018010,        4, base=16,    bitRange=5-5
 1559                           ;`GPIO1IE.P1_6`             0x50018010,        4, base=16,    bitRange=6-6
 1560                           ;`GPIO1IE.P1_7`             0x50018010,        4, base=16,    bitRange=7-7
 1561                           ;`GPIO1IE.P1_8`             0x50018010,        4, base=16,    bitRange=8-8
 1562                           ;`GPIO1IE.P1_9`             0x50018010,        4, base=16,    bitRange=9-9
 1563                           ;`GPIO1IE.P1_10`            0x50018010,        4, base=16,    bitRange=10-10
 1564                           ;`GPIO1IE.P1_11`            0x50018010,        4, base=16,    bitRange=11-11
 1565                           
 1566                           GPIO1IE0                 EQU  0x50018010
 1567                           ;`GPIO1IE0.P1_0`            0x50018010,        1, base=16,    bitRange=0-0
 1568                           ;`GPIO1IE0.P1_1`            0x50018010,        1, base=16,    bitRange=1-1
 1569                           ;`GPIO1IE0.P1_2`            0x50018010,        1, base=16,    bitRange=2-2
 1570                           ;`GPIO1IE0.P1_3`            0x50018010,        1, base=16,    bitRange=3-3
 1571                           ;`GPIO1IE0.P1_4`            0x50018010,        1, base=16,    bitRange=4-4
 1572                           ;`GPIO1IE0.P1_5`            0x50018010,        1, base=16,    bitRange=5-5
 1573                           ;`GPIO1IE0.P1_6`            0x50018010,        1, base=16,    bitRange=6-6
 1574                           ;`GPIO1IE0.P1_7`            0x50018010,        1, base=16,    bitRange=7-7
 1575                           
 1576                           GPIO1IE1                 EQU  0x50018011
 1577                           ;`GPIO1IE1.P1_8`            0x50018011,        1, base=16,    bitRange=0-0
 1578                           ;`GPIO1IE1.P1_9`            0x50018011,        1, base=16,    bitRange=1-1
 1579                           ;`GPIO1IE1.P1_10`           0x50018011,        1, base=16,    bitRange=2-2
 1580                           ;`GPIO1IE1.P1_11`           0x50018011,        1, base=16,    bitRange=3-3
 1581                           
 1582                           GPIO1IEL                 EQU  0x50018010
 1583                           ;`GPIO1IEL.P1_0`            0x50018010,        2, base=16,    bitRange=0-0
 1584                           ;`GPIO1IEL.P1_1`            0x50018010,        2, base=16,    bitRange=1-1
 1585                           ;`GPIO1IEL.P1_2`            0x50018010,        2, base=16,    bitRange=2-2
 1586                           ;`GPIO1IEL.P1_3`            0x50018010,        2, base=16,    bitRange=3-3
 1587                           ;`GPIO1IEL.P1_4`            0x50018010,        2, base=16,    bitRange=4-4
 1588                           ;`GPIO1IEL.P1_5`            0x50018010,        2, base=16,    bitRange=5-5
 1589                           ;`GPIO1IEL.P1_6`            0x50018010,        2, base=16,    bitRange=6-6
 1590                           ;`GPIO1IEL.P1_7`            0x50018010,        2, base=16,    bitRange=7-7
 1591                           ;`GPIO1IEL.P1_8`            0x50018010,        2, base=16,    bitRange=8-8
 1592                           ;`GPIO1IEL.P1_9`            0x50018010,        2, base=16,    bitRange=9-9
 1593                           ;`GPIO1IEL.P1_10`           0x50018010,        2, base=16,    bitRange=10-10
 1594                           ;`GPIO1IEL.P1_11`           0x50018010,        2, base=16,    bitRange=11-11
 1595                           
 1596                           GPIO1RIS                 EQU  0x50018014
 1597                           ;`GPIO1RIS.P1_0`            0x50018014,        4, base=16,    bitRange=0-0
 1598                           ;`GPIO1RIS.P1_1`            0x50018014,        4, base=16,    bitRange=1-1
 1599                           ;`GPIO1RIS.P1_2`            0x50018014,        4, base=16,    bitRange=2-2
 1600                           ;`GPIO1RIS.P1_3`            0x50018014,        4, base=16,    bitRange=3-3
 1601                           ;`GPIO1RIS.P1_4`            0x50018014,        4, base=16,    bitRange=4-4
 1602                           ;`GPIO1RIS.P1_5`            0x50018014,        4, base=16,    bitRange=5-5
 1603                           ;`GPIO1RIS.P1_6`            0x50018014,        4, base=16,    bitRange=6-6
 1604                           ;`GPIO1RIS.P1_7`            0x50018014,        4, base=16,    bitRange=7-7
 1605                           ;`GPIO1RIS.P1_8`            0x50018014,        4, base=16,    bitRange=8-8
 1606                           ;`GPIO1RIS.P1_9`            0x50018014,        4, base=16,    bitRange=9-9
 1607                           ;`GPIO1RIS.P1_10`           0x50018014,        4, base=16,    bitRange=10-10
 1608                           ;`GPIO1RIS.P1_11`           0x50018014,        4, base=16,    bitRange=11-11
 1609                           
 1610                           GPIO1RIS0                EQU  0x50018014
 1611                           ;`GPIO1RIS0.P1_0`           0x50018014,        1, base=16,    bitRange=0-0
 1612                           ;`GPIO1RIS0.P1_1`           0x50018014,        1, base=16,    bitRange=1-1
 1613                           ;`GPIO1RIS0.P1_2`           0x50018014,        1, base=16,    bitRange=2-2
 1614                           ;`GPIO1RIS0.P1_3`           0x50018014,        1, base=16,    bitRange=3-3
 1615                           ;`GPIO1RIS0.P1_4`           0x50018014,        1, base=16,    bitRange=4-4
 1616                           ;`GPIO1RIS0.P1_5`           0x50018014,        1, base=16,    bitRange=5-5
 1617                           ;`GPIO1RIS0.P1_6`           0x50018014,        1, base=16,    bitRange=6-6
 1618                           ;`GPIO1RIS0.P1_7`           0x50018014,        1, base=16,    bitRange=7-7
 1619                           
 1620                           GPIO1RIS1                EQU  0x50018015
 1621                           ;`GPIO1RIS1.P1_8`           0x50018015,        1, base=16,    bitRange=0-0
 1622                           ;`GPIO1RIS1.P1_9`           0x50018015,        1, base=16,    bitRange=1-1
 1623                           ;`GPIO1RIS1.P1_10`          0x50018015,        1, base=16,    bitRange=2-2
 1624                           ;`GPIO1RIS1.P1_11`          0x50018015,        1, base=16,    bitRange=3-3
 1625                           
 1626                           GPIO1RISL                EQU  0x50018014
 1627                           ;`GPIO1RISL.P1_0`           0x50018014,        2, base=16,    bitRange=0-0
 1628                           ;`GPIO1RISL.P1_1`           0x50018014,        2, base=16,    bitRange=1-1
 1629                           ;`GPIO1RISL.P1_2`           0x50018014,        2, base=16,    bitRange=2-2
 1630                           ;`GPIO1RISL.P1_3`           0x50018014,        2, base=16,    bitRange=3-3
 1631                           ;`GPIO1RISL.P1_4`           0x50018014,        2, base=16,    bitRange=4-4
 1632                           ;`GPIO1RISL.P1_5`           0x50018014,        2, base=16,    bitRange=5-5
 1633                           ;`GPIO1RISL.P1_6`           0x50018014,        2, base=16,    bitRange=6-6
 1634                           ;`GPIO1RISL.P1_7`           0x50018014,        2, base=16,    bitRange=7-7
 1635                           ;`GPIO1RISL.P1_8`           0x50018014,        2, base=16,    bitRange=8-8
 1636                           ;`GPIO1RISL.P1_9`           0x50018014,        2, base=16,    bitRange=9-9
 1637                           ;`GPIO1RISL.P1_10`          0x50018014,        2, base=16,    bitRange=10-10
 1638                           ;`GPIO1RISL.P1_11`          0x50018014,        2, base=16,    bitRange=11-11
 1639                           
 1640                           GPIO1MIS                 EQU  0x50018018
 1641                           ;`GPIO1MIS.P1_0`            0x50018018,        4, base=16,    bitRange=0-0
 1642                           ;`GPIO1MIS.P1_1`            0x50018018,        4, base=16,    bitRange=1-1
 1643                           ;`GPIO1MIS.P1_2`            0x50018018,        4, base=16,    bitRange=2-2
 1644                           ;`GPIO1MIS.P1_3`            0x50018018,        4, base=16,    bitRange=3-3
 1645                           ;`GPIO1MIS.P1_4`            0x50018018,        4, base=16,    bitRange=4-4
 1646                           ;`GPIO1MIS.P1_5`            0x50018018,        4, base=16,    bitRange=5-5
 1647                           ;`GPIO1MIS.P1_6`            0x50018018,        4, base=16,    bitRange=6-6
 1648                           ;`GPIO1MIS.P1_7`            0x50018018,        4, base=16,    bitRange=7-7
 1649                           ;`GPIO1MIS.P1_8`            0x50018018,        4, base=16,    bitRange=8-8
 1650                           ;`GPIO1MIS.P1_9`            0x50018018,        4, base=16,    bitRange=9-9
 1651                           ;`GPIO1MIS.P1_10`           0x50018018,        4, base=16,    bitRange=10-10
 1652                           ;`GPIO1MIS.P1_11`           0x50018018,        4, base=16,    bitRange=11-11
 1653                           
 1654                           GPIO1MIS0                EQU  0x50018018
 1655                           ;`GPIO1MIS0.P1_0`           0x50018018,        1, base=16,    bitRange=0-0
 1656                           ;`GPIO1MIS0.P1_1`           0x50018018,        1, base=16,    bitRange=1-1
 1657                           ;`GPIO1MIS0.P1_2`           0x50018018,        1, base=16,    bitRange=2-2
 1658                           ;`GPIO1MIS0.P1_3`           0x50018018,        1, base=16,    bitRange=3-3
 1659                           ;`GPIO1MIS0.P1_4`           0x50018018,        1, base=16,    bitRange=4-4
 1660                           ;`GPIO1MIS0.P1_5`           0x50018018,        1, base=16,    bitRange=5-5
 1661                           ;`GPIO1MIS0.P1_6`           0x50018018,        1, base=16,    bitRange=6-6
 1662                           ;`GPIO1MIS0.P1_7`           0x50018018,        1, base=16,    bitRange=7-7
 1663                           
 1664                           GPIO1MIS1                EQU  0x50018019
 1665                           ;`GPIO1MIS1.P1_8`           0x50018019,        1, base=16,    bitRange=0-0
 1666                           ;`GPIO1MIS1.P1_9`           0x50018019,        1, base=16,    bitRange=1-1
 1667                           ;`GPIO1MIS1.P1_10`          0x50018019,        1, base=16,    bitRange=2-2
 1668                           ;`GPIO1MIS1.P1_11`          0x50018019,        1, base=16,    bitRange=3-3
 1669                           
 1670                           GPIO1MISL                EQU  0x50018018
 1671                           ;`GPIO1MISL.P1_0`           0x50018018,        2, base=16,    bitRange=0-0
 1672                           ;`GPIO1MISL.P1_1`           0x50018018,        2, base=16,    bitRange=1-1
 1673                           ;`GPIO1MISL.P1_2`           0x50018018,        2, base=16,    bitRange=2-2
 1674                           ;`GPIO1MISL.P1_3`           0x50018018,        2, base=16,    bitRange=3-3
 1675                           ;`GPIO1MISL.P1_4`           0x50018018,        2, base=16,    bitRange=4-4
 1676                           ;`GPIO1MISL.P1_5`           0x50018018,        2, base=16,    bitRange=5-5
 1677                           ;`GPIO1MISL.P1_6`           0x50018018,        2, base=16,    bitRange=6-6
 1678                           ;`GPIO1MISL.P1_7`           0x50018018,        2, base=16,    bitRange=7-7
 1679                           ;`GPIO1MISL.P1_8`           0x50018018,        2, base=16,    bitRange=8-8
 1680                           ;`GPIO1MISL.P1_9`           0x50018018,        2, base=16,    bitRange=9-9
 1681                           ;`GPIO1MISL.P1_10`          0x50018018,        2, base=16,    bitRange=10-10
 1682                           ;`GPIO1MISL.P1_11`          0x50018018,        2, base=16,    bitRange=11-11
 1683                           
 1684                           GPIO1IC                  EQU  0x5001801C
 1685                           
 1686                           GPIO2DATA                EQU  0x50023FFC
 1687                           ;`GPIO2DATA.P2_0`           0x50023FFC,        4, base=16,    bitRange=0-0
 1688                           ;`GPIO2DATA.P2_1`           0x50023FFC,        4, base=16,    bitRange=1-1
 1689                           ;`GPIO2DATA.P2_2`           0x50023FFC,        4, base=16,    bitRange=2-2
 1690                           ;`GPIO2DATA.P2_3`           0x50023FFC,        4, base=16,    bitRange=3-3
 1691                           ;`GPIO2DATA.P2_4`           0x50023FFC,        4, base=16,    bitRange=4-4
 1692                           ;`GPIO2DATA.P2_5`           0x50023FFC,        4, base=16,    bitRange=5-5
 1693                           ;`GPIO2DATA.P2_6`           0x50023FFC,        4, base=16,    bitRange=6-6
 1694                           ;`GPIO2DATA.P2_7`           0x50023FFC,        4, base=16,    bitRange=7-7
 1695                           ;`GPIO2DATA.P2_8`           0x50023FFC,        4, base=16,    bitRange=8-8
 1696                           ;`GPIO2DATA.P2_9`           0x50023FFC,        4, base=16,    bitRange=9-9
 1697                           ;`GPIO2DATA.P2_10`          0x50023FFC,        4, base=16,    bitRange=10-10
 1698                           ;`GPIO2DATA.P2_11`          0x50023FFC,        4, base=16,    bitRange=11-11
 1699                           
 1700                           GPIO2DATA0               EQU  0x50023FFC
 1701                           ;`GPIO2DATA0.P2_0`          0x50023FFC,        1, base=16,    bitRange=0-0
 1702                           ;`GPIO2DATA0.P2_1`          0x50023FFC,        1, base=16,    bitRange=1-1
 1703                           ;`GPIO2DATA0.P2_2`          0x50023FFC,        1, base=16,    bitRange=2-2
 1704                           ;`GPIO2DATA0.P2_3`          0x50023FFC,        1, base=16,    bitRange=3-3
 1705                           ;`GPIO2DATA0.P2_4`          0x50023FFC,        1, base=16,    bitRange=4-4
 1706                           ;`GPIO2DATA0.P2_5`          0x50023FFC,        1, base=16,    bitRange=5-5
 1707                           ;`GPIO2DATA0.P2_6`          0x50023FFC,        1, base=16,    bitRange=6-6
 1708                           ;`GPIO2DATA0.P2_7`          0x50023FFC,        1, base=16,    bitRange=7-7
 1709                           
 1710                           GPIO2DATA1               EQU  0x50023FFD
 1711                           ;`GPIO2DATA1.P2_8`          0x50023FFD,        1, base=16,    bitRange=0-0
 1712                           ;`GPIO2DATA1.P2_9`          0x50023FFD,        1, base=16,    bitRange=1-1
 1713                           ;`GPIO2DATA1.P2_10`         0x50023FFD,        1, base=16,    bitRange=2-2
 1714                           ;`GPIO2DATA1.P2_11`         0x50023FFD,        1, base=16,    bitRange=3-3
 1715                           
 1716                           GPIO2DATAL               EQU  0x50023FFC
 1717                           ;`GPIO2DATAL.P2_0`          0x50023FFC,        2, base=16,    bitRange=0-0
 1718                           ;`GPIO2DATAL.P2_1`          0x50023FFC,        2, base=16,    bitRange=1-1
 1719                           ;`GPIO2DATAL.P2_2`          0x50023FFC,        2, base=16,    bitRange=2-2
 1720                           ;`GPIO2DATAL.P2_3`          0x50023FFC,        2, base=16,    bitRange=3-3
 1721                           ;`GPIO2DATAL.P2_4`          0x50023FFC,        2, base=16,    bitRange=4-4
 1722                           ;`GPIO2DATAL.P2_5`          0x50023FFC,        2, base=16,    bitRange=5-5
 1723                           ;`GPIO2DATAL.P2_6`          0x50023FFC,        2, base=16,    bitRange=6-6
 1724                           ;`GPIO2DATAL.P2_7`          0x50023FFC,        2, base=16,    bitRange=7-7
 1725                           ;`GPIO2DATAL.P2_8`          0x50023FFC,        2, base=16,    bitRange=8-8
 1726                           ;`GPIO2DATAL.P2_9`          0x50023FFC,        2, base=16,    bitRange=9-9
 1727                           ;`GPIO2DATAL.P2_10`         0x50023FFC,        2, base=16,    bitRange=10-10
 1728                           ;`GPIO2DATAL.P2_11`         0x50023FFC,        2, base=16,    bitRange=11-11
 1729                           
 1730                           GPIO2DIR                 EQU  0x50028000
 1731                           ;`GPIO2DIR.P2_0`            0x50028000,        4, base=16,    bitRange=0-0
 1732                           ;`GPIO2DIR.P2_1`            0x50028000,        4, base=16,    bitRange=1-1
 1733                           ;`GPIO2DIR.P2_2`            0x50028000,        4, base=16,    bitRange=2-2
 1734                           ;`GPIO2DIR.P2_3`            0x50028000,        4, base=16,    bitRange=3-3
 1735                           ;`GPIO2DIR.P2_4`            0x50028000,        4, base=16,    bitRange=4-4
 1736                           ;`GPIO2DIR.P2_5`            0x50028000,        4, base=16,    bitRange=5-5
 1737                           ;`GPIO2DIR.P2_6`            0x50028000,        4, base=16,    bitRange=6-6
 1738                           ;`GPIO2DIR.P2_7`            0x50028000,        4, base=16,    bitRange=7-7
 1739                           ;`GPIO2DIR.P2_8`            0x50028000,        4, base=16,    bitRange=8-8
 1740                           ;`GPIO2DIR.P2_9`            0x50028000,        4, base=16,    bitRange=9-9
 1741                           ;`GPIO2DIR.P2_10`           0x50028000,        4, base=16,    bitRange=10-10
 1742                           ;`GPIO2DIR.P2_11`           0x50028000,        4, base=16,    bitRange=11-11
 1743                           
 1744                           GPIO2DIR0                EQU  0x50028000
 1745                           ;`GPIO2DIR0.P2_0`           0x50028000,        1, base=16,    bitRange=0-0
 1746                           ;`GPIO2DIR0.P2_1`           0x50028000,        1, base=16,    bitRange=1-1
 1747                           ;`GPIO2DIR0.P2_2`           0x50028000,        1, base=16,    bitRange=2-2
 1748                           ;`GPIO2DIR0.P2_3`           0x50028000,        1, base=16,    bitRange=3-3
 1749                           ;`GPIO2DIR0.P2_4`           0x50028000,        1, base=16,    bitRange=4-4
 1750                           ;`GPIO2DIR0.P2_5`           0x50028000,        1, base=16,    bitRange=5-5
 1751                           ;`GPIO2DIR0.P2_6`           0x50028000,        1, base=16,    bitRange=6-6
 1752                           ;`GPIO2DIR0.P2_7`           0x50028000,        1, base=16,    bitRange=7-7
 1753                           
 1754                           GPIO2DIR1                EQU  0x50028001
 1755                           ;`GPIO2DIR1.P2_8`           0x50028001,        1, base=16,    bitRange=0-0
 1756                           ;`GPIO2DIR1.P2_9`           0x50028001,        1, base=16,    bitRange=1-1
 1757                           ;`GPIO2DIR1.P2_10`          0x50028001,        1, base=16,    bitRange=2-2
 1758                           ;`GPIO2DIR1.P2_11`          0x50028001,        1, base=16,    bitRange=3-3
 1759                           
 1760                           GPIO2DIRL                EQU  0x50028000
 1761                           ;`GPIO2DIRL.P2_0`           0x50028000,        2, base=16,    bitRange=0-0
 1762                           ;`GPIO2DIRL.P2_1`           0x50028000,        2, base=16,    bitRange=1-1
 1763                           ;`GPIO2DIRL.P2_2`           0x50028000,        2, base=16,    bitRange=2-2
 1764                           ;`GPIO2DIRL.P2_3`           0x50028000,        2, base=16,    bitRange=3-3
 1765                           ;`GPIO2DIRL.P2_4`           0x50028000,        2, base=16,    bitRange=4-4
 1766                           ;`GPIO2DIRL.P2_5`           0x50028000,        2, base=16,    bitRange=5-5
 1767                           ;`GPIO2DIRL.P2_6`           0x50028000,        2, base=16,    bitRange=6-6
 1768                           ;`GPIO2DIRL.P2_7`           0x50028000,        2, base=16,    bitRange=7-7
 1769                           ;`GPIO2DIRL.P2_8`           0x50028000,        2, base=16,    bitRange=8-8
 1770                           ;`GPIO2DIRL.P2_9`           0x50028000,        2, base=16,    bitRange=9-9
 1771                           ;`GPIO2DIRL.P2_10`          0x50028000,        2, base=16,    bitRange=10-10
 1772                           ;`GPIO2DIRL.P2_11`          0x50028000,        2, base=16,    bitRange=11-11
 1773                           
 1774                           GPIO2IS                  EQU  0x50028004
 1775                           ;`GPIO2IS.P2_0`             0x50028004,        4, base=16,    bitRange=0-0
 1776                           ;`GPIO2IS.P2_1`             0x50028004,        4, base=16,    bitRange=1-1
 1777                           ;`GPIO2IS.P2_2`             0x50028004,        4, base=16,    bitRange=2-2
 1778                           ;`GPIO2IS.P2_3`             0x50028004,        4, base=16,    bitRange=3-3
 1779                           ;`GPIO2IS.P2_4`             0x50028004,        4, base=16,    bitRange=4-4
 1780                           ;`GPIO2IS.P2_5`             0x50028004,        4, base=16,    bitRange=5-5
 1781                           ;`GPIO2IS.P2_6`             0x50028004,        4, base=16,    bitRange=6-6
 1782                           ;`GPIO2IS.P2_7`             0x50028004,        4, base=16,    bitRange=7-7
 1783                           ;`GPIO2IS.P2_8`             0x50028004,        4, base=16,    bitRange=8-8
 1784                           ;`GPIO2IS.P2_9`             0x50028004,        4, base=16,    bitRange=9-9
 1785                           ;`GPIO2IS.P2_10`            0x50028004,        4, base=16,    bitRange=10-10
 1786                           ;`GPIO2IS.P2_11`            0x50028004,        4, base=16,    bitRange=11-11
 1787                           
 1788                           GPIO2IS0                 EQU  0x50028004
 1789                           ;`GPIO2IS0.P2_0`            0x50028004,        1, base=16,    bitRange=0-0
 1790                           ;`GPIO2IS0.P2_1`            0x50028004,        1, base=16,    bitRange=1-1
 1791                           ;`GPIO2IS0.P2_2`            0x50028004,        1, base=16,    bitRange=2-2
 1792                           ;`GPIO2IS0.P2_3`            0x50028004,        1, base=16,    bitRange=3-3
 1793                           ;`GPIO2IS0.P2_4`            0x50028004,        1, base=16,    bitRange=4-4
 1794                           ;`GPIO2IS0.P2_5`            0x50028004,        1, base=16,    bitRange=5-5
 1795                           ;`GPIO2IS0.P2_6`            0x50028004,        1, base=16,    bitRange=6-6
 1796                           ;`GPIO2IS0.P2_7`            0x50028004,        1, base=16,    bitRange=7-7
 1797                           
 1798                           GPIO2IS1                 EQU  0x50028005
 1799                           ;`GPIO2IS1.P2_8`            0x50028005,        1, base=16,    bitRange=0-0
 1800                           ;`GPIO2IS1.P2_9`            0x50028005,        1, base=16,    bitRange=1-1
 1801                           ;`GPIO2IS1.P2_10`           0x50028005,        1, base=16,    bitRange=2-2
 1802                           ;`GPIO2IS1.P2_11`           0x50028005,        1, base=16,    bitRange=3-3
 1803                           
 1804                           GPIO2ISL                 EQU  0x50028004
 1805                           ;`GPIO2ISL.P2_0`            0x50028004,        2, base=16,    bitRange=0-0
 1806                           ;`GPIO2ISL.P2_1`            0x50028004,        2, base=16,    bitRange=1-1
 1807                           ;`GPIO2ISL.P2_2`            0x50028004,        2, base=16,    bitRange=2-2
 1808                           ;`GPIO2ISL.P2_3`            0x50028004,        2, base=16,    bitRange=3-3
 1809                           ;`GPIO2ISL.P2_4`            0x50028004,        2, base=16,    bitRange=4-4
 1810                           ;`GPIO2ISL.P2_5`            0x50028004,        2, base=16,    bitRange=5-5
 1811                           ;`GPIO2ISL.P2_6`            0x50028004,        2, base=16,    bitRange=6-6
 1812                           ;`GPIO2ISL.P2_7`            0x50028004,        2, base=16,    bitRange=7-7
 1813                           ;`GPIO2ISL.P2_8`            0x50028004,        2, base=16,    bitRange=8-8
 1814                           ;`GPIO2ISL.P2_9`            0x50028004,        2, base=16,    bitRange=9-9
 1815                           ;`GPIO2ISL.P2_10`           0x50028004,        2, base=16,    bitRange=10-10
 1816                           ;`GPIO2ISL.P2_11`           0x50028004,        2, base=16,    bitRange=11-11
 1817                           
 1818                           GPIO2IBE                 EQU  0x50028008
 1819                           ;`GPIO2IBE.P2_0`            0x50028008,        4, base=16,    bitRange=0-0
 1820                           ;`GPIO2IBE.P2_1`            0x50028008,        4, base=16,    bitRange=1-1
 1821                           ;`GPIO2IBE.P2_2`            0x50028008,        4, base=16,    bitRange=2-2
 1822                           ;`GPIO2IBE.P2_3`            0x50028008,        4, base=16,    bitRange=3-3
 1823                           ;`GPIO2IBE.P2_4`            0x50028008,        4, base=16,    bitRange=4-4
 1824                           ;`GPIO2IBE.P2_5`            0x50028008,        4, base=16,    bitRange=5-5
 1825                           ;`GPIO2IBE.P2_6`            0x50028008,        4, base=16,    bitRange=6-6
 1826                           ;`GPIO2IBE.P2_7`            0x50028008,        4, base=16,    bitRange=7-7
 1827                           ;`GPIO2IBE.P2_8`            0x50028008,        4, base=16,    bitRange=8-8
 1828                           ;`GPIO2IBE.P2_9`            0x50028008,        4, base=16,    bitRange=9-9
 1829                           ;`GPIO2IBE.P2_10`           0x50028008,        4, base=16,    bitRange=10-10
 1830                           ;`GPIO2IBE.P2_11`           0x50028008,        4, base=16,    bitRange=11-11
 1831                           
 1832                           GPIO2IBE0                EQU  0x50028008
 1833                           ;`GPIO2IBE0.P2_0`           0x50028008,        1, base=16,    bitRange=0-0
 1834                           ;`GPIO2IBE0.P2_1`           0x50028008,        1, base=16,    bitRange=1-1
 1835                           ;`GPIO2IBE0.P2_2`           0x50028008,        1, base=16,    bitRange=2-2
 1836                           ;`GPIO2IBE0.P2_3`           0x50028008,        1, base=16,    bitRange=3-3
 1837                           ;`GPIO2IBE0.P2_4`           0x50028008,        1, base=16,    bitRange=4-4
 1838                           ;`GPIO2IBE0.P2_5`           0x50028008,        1, base=16,    bitRange=5-5
 1839                           ;`GPIO2IBE0.P2_6`           0x50028008,        1, base=16,    bitRange=6-6
 1840                           ;`GPIO2IBE0.P2_7`           0x50028008,        1, base=16,    bitRange=7-7
 1841                           
 1842                           GPIO2IBE1                EQU  0x50028009
 1843                           ;`GPIO2IBE1.P2_8`           0x50028009,        1, base=16,    bitRange=0-0
 1844                           ;`GPIO2IBE1.P2_9`           0x50028009,        1, base=16,    bitRange=1-1
 1845                           ;`GPIO2IBE1.P2_10`          0x50028009,        1, base=16,    bitRange=2-2
 1846                           ;`GPIO2IBE1.P2_11`          0x50028009,        1, base=16,    bitRange=3-3
 1847                           
 1848                           GPIO2IBEL                EQU  0x50028008
 1849                           ;`GPIO2IBEL.P2_0`           0x50028008,        2, base=16,    bitRange=0-0
 1850                           ;`GPIO2IBEL.P2_1`           0x50028008,        2, base=16,    bitRange=1-1
 1851                           ;`GPIO2IBEL.P2_2`           0x50028008,        2, base=16,    bitRange=2-2
 1852                           ;`GPIO2IBEL.P2_3`           0x50028008,        2, base=16,    bitRange=3-3
 1853                           ;`GPIO2IBEL.P2_4`           0x50028008,        2, base=16,    bitRange=4-4
 1854                           ;`GPIO2IBEL.P2_5`           0x50028008,        2, base=16,    bitRange=5-5
 1855                           ;`GPIO2IBEL.P2_6`           0x50028008,        2, base=16,    bitRange=6-6
 1856                           ;`GPIO2IBEL.P2_7`           0x50028008,        2, base=16,    bitRange=7-7
 1857                           ;`GPIO2IBEL.P2_8`           0x50028008,        2, base=16,    bitRange=8-8
 1858                           ;`GPIO2IBEL.P2_9`           0x50028008,        2, base=16,    bitRange=9-9
 1859                           ;`GPIO2IBEL.P2_10`          0x50028008,        2, base=16,    bitRange=10-10
 1860                           ;`GPIO2IBEL.P2_11`          0x50028008,        2, base=16,    bitRange=11-11
 1861                           
 1862                           GPIO2IEV                 EQU  0x5002800C
 1863                           ;`GPIO2IEV.P2_0`            0x5002800C,        4, base=16,    bitRange=0-0
 1864                           ;`GPIO2IEV.P2_1`            0x5002800C,        4, base=16,    bitRange=1-1
 1865                           ;`GPIO2IEV.P2_2`            0x5002800C,        4, base=16,    bitRange=2-2
 1866                           ;`GPIO2IEV.P2_3`            0x5002800C,        4, base=16,    bitRange=3-3
 1867                           ;`GPIO2IEV.P2_4`            0x5002800C,        4, base=16,    bitRange=4-4
 1868                           ;`GPIO2IEV.P2_5`            0x5002800C,        4, base=16,    bitRange=5-5
 1869                           ;`GPIO2IEV.P2_6`            0x5002800C,        4, base=16,    bitRange=6-6
 1870                           ;`GPIO2IEV.P2_7`            0x5002800C,        4, base=16,    bitRange=7-7
 1871                           ;`GPIO2IEV.P2_8`            0x5002800C,        4, base=16,    bitRange=8-8
 1872                           ;`GPIO2IEV.P2_9`            0x5002800C,        4, base=16,    bitRange=9-9
 1873                           ;`GPIO2IEV.P2_10`           0x5002800C,        4, base=16,    bitRange=10-10
 1874                           ;`GPIO2IEV.P2_11`           0x5002800C,        4, base=16,    bitRange=11-11
 1875                           
 1876                           GPIO2IEV0                EQU  0x5002800C
 1877                           ;`GPIO2IEV0.P2_0`           0x5002800C,        1, base=16,    bitRange=0-0
 1878                           ;`GPIO2IEV0.P2_1`           0x5002800C,        1, base=16,    bitRange=1-1
 1879                           ;`GPIO2IEV0.P2_2`           0x5002800C,        1, base=16,    bitRange=2-2
 1880                           ;`GPIO2IEV0.P2_3`           0x5002800C,        1, base=16,    bitRange=3-3
 1881                           ;`GPIO2IEV0.P2_4`           0x5002800C,        1, base=16,    bitRange=4-4
 1882                           ;`GPIO2IEV0.P2_5`           0x5002800C,        1, base=16,    bitRange=5-5
 1883                           ;`GPIO2IEV0.P2_6`           0x5002800C,        1, base=16,    bitRange=6-6
 1884                           ;`GPIO2IEV0.P2_7`           0x5002800C,        1, base=16,    bitRange=7-7
 1885                           
 1886                           GPIO2IEV1                EQU  0x5002800D
 1887                           ;`GPIO2IEV1.P2_8`           0x5002800D,        1, base=16,    bitRange=0-0
 1888                           ;`GPIO2IEV1.P2_9`           0x5002800D,        1, base=16,    bitRange=1-1
 1889                           ;`GPIO2IEV1.P2_10`          0x5002800D,        1, base=16,    bitRange=2-2
 1890                           ;`GPIO2IEV1.P2_11`          0x5002800D,        1, base=16,    bitRange=3-3
 1891                           
 1892                           GPIO2IEVL                EQU  0x5002800C
 1893                           ;`GPIO2IEVL.P2_0`           0x5002800C,        2, base=16,    bitRange=0-0
 1894                           ;`GPIO2IEVL.P2_1`           0x5002800C,        2, base=16,    bitRange=1-1
 1895                           ;`GPIO2IEVL.P2_2`           0x5002800C,        2, base=16,    bitRange=2-2
 1896                           ;`GPIO2IEVL.P2_3`           0x5002800C,        2, base=16,    bitRange=3-3
 1897                           ;`GPIO2IEVL.P2_4`           0x5002800C,        2, base=16,    bitRange=4-4
 1898                           ;`GPIO2IEVL.P2_5`           0x5002800C,        2, base=16,    bitRange=5-5
 1899                           ;`GPIO2IEVL.P2_6`           0x5002800C,        2, base=16,    bitRange=6-6
 1900                           ;`GPIO2IEVL.P2_7`           0x5002800C,        2, base=16,    bitRange=7-7
 1901                           ;`GPIO2IEVL.P2_8`           0x5002800C,        2, base=16,    bitRange=8-8
 1902                           ;`GPIO2IEVL.P2_9`           0x5002800C,        2, base=16,    bitRange=9-9
 1903                           ;`GPIO2IEVL.P2_10`          0x5002800C,        2, base=16,    bitRange=10-10
 1904                           ;`GPIO2IEVL.P2_11`          0x5002800C,        2, base=16,    bitRange=11-11
 1905                           
 1906                           GPIO2IE                  EQU  0x50028010
 1907                           ;`GPIO2IE.P2_0`             0x50028010,        4, base=16,    bitRange=0-0
 1908                           ;`GPIO2IE.P2_1`             0x50028010,        4, base=16,    bitRange=1-1
 1909                           ;`GPIO2IE.P2_2`             0x50028010,        4, base=16,    bitRange=2-2
 1910                           ;`GPIO2IE.P2_3`             0x50028010,        4, base=16,    bitRange=3-3
 1911                           ;`GPIO2IE.P2_4`             0x50028010,        4, base=16,    bitRange=4-4
 1912                           ;`GPIO2IE.P2_5`             0x50028010,        4, base=16,    bitRange=5-5
 1913                           ;`GPIO2IE.P2_6`             0x50028010,        4, base=16,    bitRange=6-6
 1914                           ;`GPIO2IE.P2_7`             0x50028010,        4, base=16,    bitRange=7-7
 1915                           ;`GPIO2IE.P2_8`             0x50028010,        4, base=16,    bitRange=8-8
 1916                           ;`GPIO2IE.P2_9`             0x50028010,        4, base=16,    bitRange=9-9
 1917                           ;`GPIO2IE.P2_10`            0x50028010,        4, base=16,    bitRange=10-10
 1918                           ;`GPIO2IE.P2_11`            0x50028010,        4, base=16,    bitRange=11-11
 1919                           
 1920                           GPIO2IE0                 EQU  0x50028010
 1921                           ;`GPIO2IE0.P2_0`            0x50028010,        1, base=16,    bitRange=0-0
 1922                           ;`GPIO2IE0.P2_1`            0x50028010,        1, base=16,    bitRange=1-1
 1923                           ;`GPIO2IE0.P2_2`            0x50028010,        1, base=16,    bitRange=2-2
 1924                           ;`GPIO2IE0.P2_3`            0x50028010,        1, base=16,    bitRange=3-3
 1925                           ;`GPIO2IE0.P2_4`            0x50028010,        1, base=16,    bitRange=4-4
 1926                           ;`GPIO2IE0.P2_5`            0x50028010,        1, base=16,    bitRange=5-5
 1927                           ;`GPIO2IE0.P2_6`            0x50028010,        1, base=16,    bitRange=6-6
 1928                           ;`GPIO2IE0.P2_7`            0x50028010,        1, base=16,    bitRange=7-7
 1929                           
 1930                           GPIO2IE1                 EQU  0x50028011
 1931                           ;`GPIO2IE1.P2_8`            0x50028011,        1, base=16,    bitRange=0-0
 1932                           ;`GPIO2IE1.P2_9`            0x50028011,        1, base=16,    bitRange=1-1
 1933                           ;`GPIO2IE1.P2_10`           0x50028011,        1, base=16,    bitRange=2-2
 1934                           ;`GPIO2IE1.P2_11`           0x50028011,        1, base=16,    bitRange=3-3
 1935                           
 1936                           GPIO2IEL                 EQU  0x50028010
 1937                           ;`GPIO2IEL.P2_0`            0x50028010,        2, base=16,    bitRange=0-0
 1938                           ;`GPIO2IEL.P2_1`            0x50028010,        2, base=16,    bitRange=1-1
 1939                           ;`GPIO2IEL.P2_2`            0x50028010,        2, base=16,    bitRange=2-2
 1940                           ;`GPIO2IEL.P2_3`            0x50028010,        2, base=16,    bitRange=3-3
 1941                           ;`GPIO2IEL.P2_4`            0x50028010,        2, base=16,    bitRange=4-4
 1942                           ;`GPIO2IEL.P2_5`            0x50028010,        2, base=16,    bitRange=5-5
 1943                           ;`GPIO2IEL.P2_6`            0x50028010,        2, base=16,    bitRange=6-6
 1944                           ;`GPIO2IEL.P2_7`            0x50028010,        2, base=16,    bitRange=7-7
 1945                           ;`GPIO2IEL.P2_8`            0x50028010,        2, base=16,    bitRange=8-8
 1946                           ;`GPIO2IEL.P2_9`            0x50028010,        2, base=16,    bitRange=9-9
 1947                           ;`GPIO2IEL.P2_10`           0x50028010,        2, base=16,    bitRange=10-10
 1948                           ;`GPIO2IEL.P2_11`           0x50028010,        2, base=16,    bitRange=11-11
 1949                           
 1950                           GPIO2RIS                 EQU  0x50028014
 1951                           ;`GPIO2RIS.P2_0`            0x50028014,        4, base=16,    bitRange=0-0
 1952                           ;`GPIO2RIS.P2_1`            0x50028014,        4, base=16,    bitRange=1-1
 1953                           ;`GPIO2RIS.P2_2`            0x50028014,        4, base=16,    bitRange=2-2
 1954                           ;`GPIO2RIS.P2_3`            0x50028014,        4, base=16,    bitRange=3-3
 1955                           ;`GPIO2RIS.P2_4`            0x50028014,        4, base=16,    bitRange=4-4
 1956                           ;`GPIO2RIS.P2_5`            0x50028014,        4, base=16,    bitRange=5-5
 1957                           ;`GPIO2RIS.P2_6`            0x50028014,        4, base=16,    bitRange=6-6
 1958                           ;`GPIO2RIS.P2_7`            0x50028014,        4, base=16,    bitRange=7-7
 1959                           ;`GPIO2RIS.P2_8`            0x50028014,        4, base=16,    bitRange=8-8
 1960                           ;`GPIO2RIS.P2_9`            0x50028014,        4, base=16,    bitRange=9-9
 1961                           ;`GPIO2RIS.P2_10`           0x50028014,        4, base=16,    bitRange=10-10
 1962                           ;`GPIO2RIS.P2_11`           0x50028014,        4, base=16,    bitRange=11-11
 1963                           
 1964                           GPIO2RIS0                EQU  0x50028014
 1965                           ;`GPIO2RIS0.P2_0`           0x50028014,        1, base=16,    bitRange=0-0
 1966                           ;`GPIO2RIS0.P2_1`           0x50028014,        1, base=16,    bitRange=1-1
 1967                           ;`GPIO2RIS0.P2_2`           0x50028014,        1, base=16,    bitRange=2-2
 1968                           ;`GPIO2RIS0.P2_3`           0x50028014,        1, base=16,    bitRange=3-3
 1969                           ;`GPIO2RIS0.P2_4`           0x50028014,        1, base=16,    bitRange=4-4
 1970                           ;`GPIO2RIS0.P2_5`           0x50028014,        1, base=16,    bitRange=5-5
 1971                           ;`GPIO2RIS0.P2_6`           0x50028014,        1, base=16,    bitRange=6-6
 1972                           ;`GPIO2RIS0.P2_7`           0x50028014,        1, base=16,    bitRange=7-7
 1973                           
 1974                           GPIO2RIS1                EQU  0x50028015
 1975                           ;`GPIO2RIS1.P2_8`           0x50028015,        1, base=16,    bitRange=0-0
 1976                           ;`GPIO2RIS1.P2_9`           0x50028015,        1, base=16,    bitRange=1-1
 1977                           ;`GPIO2RIS1.P2_10`          0x50028015,        1, base=16,    bitRange=2-2
 1978                           ;`GPIO2RIS1.P2_11`          0x50028015,        1, base=16,    bitRange=3-3
 1979                           
 1980                           GPIO2RISL                EQU  0x50028014
 1981                           ;`GPIO2RISL.P2_0`           0x50028014,        2, base=16,    bitRange=0-0
 1982                           ;`GPIO2RISL.P2_1`           0x50028014,        2, base=16,    bitRange=1-1
 1983                           ;`GPIO2RISL.P2_2`           0x50028014,        2, base=16,    bitRange=2-2
 1984                           ;`GPIO2RISL.P2_3`           0x50028014,        2, base=16,    bitRange=3-3
 1985                           ;`GPIO2RISL.P2_4`           0x50028014,        2, base=16,    bitRange=4-4
 1986                           ;`GPIO2RISL.P2_5`           0x50028014,        2, base=16,    bitRange=5-5
 1987                           ;`GPIO2RISL.P2_6`           0x50028014,        2, base=16,    bitRange=6-6
 1988                           ;`GPIO2RISL.P2_7`           0x50028014,        2, base=16,    bitRange=7-7
 1989                           ;`GPIO2RISL.P2_8`           0x50028014,        2, base=16,    bitRange=8-8
 1990                           ;`GPIO2RISL.P2_9`           0x50028014,        2, base=16,    bitRange=9-9
 1991                           ;`GPIO2RISL.P2_10`          0x50028014,        2, base=16,    bitRange=10-10
 1992                           ;`GPIO2RISL.P2_11`          0x50028014,        2, base=16,    bitRange=11-11
 1993                           
 1994                           GPIO2MIS                 EQU  0x50028018
 1995                           ;`GPIO2MIS.P2_0`            0x50028018,        4, base=16,    bitRange=0-0
 1996                           ;`GPIO2MIS.P2_1`            0x50028018,        4, base=16,    bitRange=1-1
 1997                           ;`GPIO2MIS.P2_2`            0x50028018,        4, base=16,    bitRange=2-2
 1998                           ;`GPIO2MIS.P2_3`            0x50028018,        4, base=16,    bitRange=3-3
 1999                           ;`GPIO2MIS.P2_4`            0x50028018,        4, base=16,    bitRange=4-4
 2000                           ;`GPIO2MIS.P2_5`            0x50028018,        4, base=16,    bitRange=5-5
 2001                           ;`GPIO2MIS.P2_6`            0x50028018,        4, base=16,    bitRange=6-6
 2002                           ;`GPIO2MIS.P2_7`            0x50028018,        4, base=16,    bitRange=7-7
 2003                           ;`GPIO2MIS.P2_8`            0x50028018,        4, base=16,    bitRange=8-8
 2004                           ;`GPIO2MIS.P2_9`            0x50028018,        4, base=16,    bitRange=9-9
 2005                           ;`GPIO2MIS.P2_10`           0x50028018,        4, base=16,    bitRange=10-10
 2006                           ;`GPIO2MIS.P2_11`           0x50028018,        4, base=16,    bitRange=11-11
 2007                           
 2008                           GPIO2MIS0                EQU  0x50028018
 2009                           ;`GPIO2MIS0.P2_0`           0x50028018,        1, base=16,    bitRange=0-0
 2010                           ;`GPIO2MIS0.P2_1`           0x50028018,        1, base=16,    bitRange=1-1
 2011                           ;`GPIO2MIS0.P2_2`           0x50028018,        1, base=16,    bitRange=2-2
 2012                           ;`GPIO2MIS0.P2_3`           0x50028018,        1, base=16,    bitRange=3-3
 2013                           ;`GPIO2MIS0.P2_4`           0x50028018,        1, base=16,    bitRange=4-4
 2014                           ;`GPIO2MIS0.P2_5`           0x50028018,        1, base=16,    bitRange=5-5
 2015                           ;`GPIO2MIS0.P2_6`           0x50028018,        1, base=16,    bitRange=6-6
 2016                           ;`GPIO2MIS0.P2_7`           0x50028018,        1, base=16,    bitRange=7-7
 2017                           
 2018                           GPIO2MIS1                EQU  0x50028019
 2019                           ;`GPIO2MIS1.P2_8`           0x50028019,        1, base=16,    bitRange=0-0
 2020                           ;`GPIO2MIS1.P2_9`           0x50028019,        1, base=16,    bitRange=1-1
 2021                           ;`GPIO2MIS1.P2_10`          0x50028019,        1, base=16,    bitRange=2-2
 2022                           ;`GPIO2MIS1.P2_11`          0x50028019,        1, base=16,    bitRange=3-3
 2023                           
 2024                           GPIO2MISL                EQU  0x50028018
 2025                           ;`GPIO2MISL.P2_0`           0x50028018,        2, base=16,    bitRange=0-0
 2026                           ;`GPIO2MISL.P2_1`           0x50028018,        2, base=16,    bitRange=1-1
 2027                           ;`GPIO2MISL.P2_2`           0x50028018,        2, base=16,    bitRange=2-2
 2028                           ;`GPIO2MISL.P2_3`           0x50028018,        2, base=16,    bitRange=3-3
 2029                           ;`GPIO2MISL.P2_4`           0x50028018,        2, base=16,    bitRange=4-4
 2030                           ;`GPIO2MISL.P2_5`           0x50028018,        2, base=16,    bitRange=5-5
 2031                           ;`GPIO2MISL.P2_6`           0x50028018,        2, base=16,    bitRange=6-6
 2032                           ;`GPIO2MISL.P2_7`           0x50028018,        2, base=16,    bitRange=7-7
 2033                           ;`GPIO2MISL.P2_8`           0x50028018,        2, base=16,    bitRange=8-8
 2034                           ;`GPIO2MISL.P2_9`           0x50028018,        2, base=16,    bitRange=9-9
 2035                           ;`GPIO2MISL.P2_10`          0x50028018,        2, base=16,    bitRange=10-10
 2036                           ;`GPIO2MISL.P2_11`          0x50028018,        2, base=16,    bitRange=11-11
 2037                           
 2038                           GPIO2IC                  EQU  0x5002801C
 2039                           
 2040                           GPIO3DATA                EQU  0x50033FFC
 2041                           ;`GPIO3DATA.P3_0`           0x50033FFC,        4, base=16,    bitRange=0-0
 2042                           ;`GPIO3DATA.P3_1`           0x50033FFC,        4, base=16,    bitRange=1-1
 2043                           ;`GPIO3DATA.P3_2`           0x50033FFC,        4, base=16,    bitRange=2-2
 2044                           ;`GPIO3DATA.P3_3`           0x50033FFC,        4, base=16,    bitRange=3-3
 2045                           ;`GPIO3DATA.P3_4`           0x50033FFC,        4, base=16,    bitRange=4-4
 2046                           ;`GPIO3DATA.P3_5`           0x50033FFC,        4, base=16,    bitRange=5-5
 2047                           
 2048                           GPIO3DATA0               EQU  0x50033FFC
 2049                           ;`GPIO3DATA0.P3_0`          0x50033FFC,        1, base=16,    bitRange=0-0
 2050                           ;`GPIO3DATA0.P3_1`          0x50033FFC,        1, base=16,    bitRange=1-1
 2051                           ;`GPIO3DATA0.P3_2`          0x50033FFC,        1, base=16,    bitRange=2-2
 2052                           ;`GPIO3DATA0.P3_3`          0x50033FFC,        1, base=16,    bitRange=3-3
 2053                           ;`GPIO3DATA0.P3_4`          0x50033FFC,        1, base=16,    bitRange=4-4
 2054                           ;`GPIO3DATA0.P3_5`          0x50033FFC,        1, base=16,    bitRange=5-5
 2055                           
 2056                           GPIO3DATAL               EQU  0x50033FFC
 2057                           ;`GPIO3DATAL.P3_0`          0x50033FFC,        2, base=16,    bitRange=0-0
 2058                           ;`GPIO3DATAL.P3_1`          0x50033FFC,        2, base=16,    bitRange=1-1
 2059                           ;`GPIO3DATAL.P3_2`          0x50033FFC,        2, base=16,    bitRange=2-2
 2060                           ;`GPIO3DATAL.P3_3`          0x50033FFC,        2, base=16,    bitRange=3-3
 2061                           ;`GPIO3DATAL.P3_4`          0x50033FFC,        2, base=16,    bitRange=4-4
 2062                           ;`GPIO3DATAL.P3_5`          0x50033FFC,        2, base=16,    bitRange=5-5
 2063                           
 2064                           GPIO3DIR                 EQU  0x50038000
 2065                           ;`GPIO3DIR.P3_0`            0x50038000,        4, base=16,    bitRange=0-0
 2066                           ;`GPIO3DIR.P3_1`            0x50038000,        4, base=16,    bitRange=1-1
 2067                           ;`GPIO3DIR.P3_2`            0x50038000,        4, base=16,    bitRange=2-2
 2068                           ;`GPIO3DIR.P3_3`            0x50038000,        4, base=16,    bitRange=3-3
 2069                           ;`GPIO3DIR.P3_4`            0x50038000,        4, base=16,    bitRange=4-4
 2070                           ;`GPIO3DIR.P3_5`            0x50038000,        4, base=16,    bitRange=5-5
 2071                           
 2072                           GPIO3DIR0                EQU  0x50038000
 2073                           ;`GPIO3DIR0.P3_0`           0x50038000,        1, base=16,    bitRange=0-0
 2074                           ;`GPIO3DIR0.P3_1`           0x50038000,        1, base=16,    bitRange=1-1
 2075                           ;`GPIO3DIR0.P3_2`           0x50038000,        1, base=16,    bitRange=2-2
 2076                           ;`GPIO3DIR0.P3_3`           0x50038000,        1, base=16,    bitRange=3-3
 2077                           ;`GPIO3DIR0.P3_4`           0x50038000,        1, base=16,    bitRange=4-4
 2078                           ;`GPIO3DIR0.P3_5`           0x50038000,        1, base=16,    bitRange=5-5
 2079                           
 2080                           GPIO3DIRL                EQU  0x50038000
 2081                           ;`GPIO3DIRL.P3_0`           0x50038000,        2, base=16,    bitRange=0-0
 2082                           ;`GPIO3DIRL.P3_1`           0x50038000,        2, base=16,    bitRange=1-1
 2083                           ;`GPIO3DIRL.P3_2`           0x50038000,        2, base=16,    bitRange=2-2
 2084                           ;`GPIO3DIRL.P3_3`           0x50038000,        2, base=16,    bitRange=3-3
 2085                           ;`GPIO3DIRL.P3_4`           0x50038000,        2, base=16,    bitRange=4-4
 2086                           ;`GPIO3DIRL.P3_5`           0x50038000,        2, base=16,    bitRange=5-5
 2087                           
 2088                           GPIO3IS                  EQU  0x50038004
 2089                           ;`GPIO3IS.P3_0`             0x50038004,        4, base=16,    bitRange=0-0
 2090                           ;`GPIO3IS.P3_1`             0x50038004,        4, base=16,    bitRange=1-1
 2091                           ;`GPIO3IS.P3_2`             0x50038004,        4, base=16,    bitRange=2-2
 2092                           ;`GPIO3IS.P3_3`             0x50038004,        4, base=16,    bitRange=3-3
 2093                           ;`GPIO3IS.P3_4`             0x50038004,        4, base=16,    bitRange=4-4
 2094                           ;`GPIO3IS.P3_5`             0x50038004,        4, base=16,    bitRange=5-5
 2095                           
 2096                           GPIO3IS0                 EQU  0x50038004
 2097                           ;`GPIO3IS0.P3_0`            0x50038004,        1, base=16,    bitRange=0-0
 2098                           ;`GPIO3IS0.P3_1`            0x50038004,        1, base=16,    bitRange=1-1
 2099                           ;`GPIO3IS0.P3_2`            0x50038004,        1, base=16,    bitRange=2-2
 2100                           ;`GPIO3IS0.P3_3`            0x50038004,        1, base=16,    bitRange=3-3
 2101                           ;`GPIO3IS0.P3_4`            0x50038004,        1, base=16,    bitRange=4-4
 2102                           ;`GPIO3IS0.P3_5`            0x50038004,        1, base=16,    bitRange=5-5
 2103                           
 2104                           GPIO3ISL                 EQU  0x50038004
 2105                           ;`GPIO3ISL.P3_0`            0x50038004,        2, base=16,    bitRange=0-0
 2106                           ;`GPIO3ISL.P3_1`            0x50038004,        2, base=16,    bitRange=1-1
 2107                           ;`GPIO3ISL.P3_2`            0x50038004,        2, base=16,    bitRange=2-2
 2108                           ;`GPIO3ISL.P3_3`            0x50038004,        2, base=16,    bitRange=3-3
 2109                           ;`GPIO3ISL.P3_4`            0x50038004,        2, base=16,    bitRange=4-4
 2110                           ;`GPIO3ISL.P3_5`            0x50038004,        2, base=16,    bitRange=5-5
 2111                           
 2112                           GPIO3IBE                 EQU  0x50038008
 2113                           ;`GPIO3IBE.P3_0`            0x50038008,        4, base=16,    bitRange=0-0
 2114                           ;`GPIO3IBE.P3_1`            0x50038008,        4, base=16,    bitRange=1-1
 2115                           ;`GPIO3IBE.P3_2`            0x50038008,        4, base=16,    bitRange=2-2
 2116                           ;`GPIO3IBE.P3_3`            0x50038008,        4, base=16,    bitRange=3-3
 2117                           ;`GPIO3IBE.P3_4`            0x50038008,        4, base=16,    bitRange=4-4
 2118                           ;`GPIO3IBE.P3_5`            0x50038008,        4, base=16,    bitRange=5-5
 2119                           
 2120                           GPIO3IBE0                EQU  0x50038008
 2121                           ;`GPIO3IBE0.P3_0`           0x50038008,        1, base=16,    bitRange=0-0
 2122                           ;`GPIO3IBE0.P3_1`           0x50038008,        1, base=16,    bitRange=1-1
 2123                           ;`GPIO3IBE0.P3_2`           0x50038008,        1, base=16,    bitRange=2-2
 2124                           ;`GPIO3IBE0.P3_3`           0x50038008,        1, base=16,    bitRange=3-3
 2125                           ;`GPIO3IBE0.P3_4`           0x50038008,        1, base=16,    bitRange=4-4
 2126                           ;`GPIO3IBE0.P3_5`           0x50038008,        1, base=16,    bitRange=5-5
 2127                           
 2128                           GPIO3IBEL                EQU  0x50038008
 2129                           ;`GPIO3IBEL.P3_0`           0x50038008,        2, base=16,    bitRange=0-0
 2130                           ;`GPIO3IBEL.P3_1`           0x50038008,        2, base=16,    bitRange=1-1
 2131                           ;`GPIO3IBEL.P3_2`           0x50038008,        2, base=16,    bitRange=2-2
 2132                           ;`GPIO3IBEL.P3_3`           0x50038008,        2, base=16,    bitRange=3-3
 2133                           ;`GPIO3IBEL.P3_4`           0x50038008,        2, base=16,    bitRange=4-4
 2134                           ;`GPIO3IBEL.P3_5`           0x50038008,        2, base=16,    bitRange=5-5
 2135                           
 2136                           GPIO3IEV                 EQU  0x5003800C
 2137                           ;`GPIO3IEV.P3_0`            0x5003800C,        4, base=16,    bitRange=0-0
 2138                           ;`GPIO3IEV.P3_1`            0x5003800C,        4, base=16,    bitRange=1-1
 2139                           ;`GPIO3IEV.P3_2`            0x5003800C,        4, base=16,    bitRange=2-2
 2140                           ;`GPIO3IEV.P3_3`            0x5003800C,        4, base=16,    bitRange=3-3
 2141                           ;`GPIO3IEV.P3_4`            0x5003800C,        4, base=16,    bitRange=4-4
 2142                           ;`GPIO3IEV.P3_5`            0x5003800C,        4, base=16,    bitRange=5-5
 2143                           
 2144                           GPIO3IEV0                EQU  0x5003800C
 2145                           ;`GPIO3IEV0.P3_0`           0x5003800C,        1, base=16,    bitRange=0-0
 2146                           ;`GPIO3IEV0.P3_1`           0x5003800C,        1, base=16,    bitRange=1-1
 2147                           ;`GPIO3IEV0.P3_2`           0x5003800C,        1, base=16,    bitRange=2-2
 2148                           ;`GPIO3IEV0.P3_3`           0x5003800C,        1, base=16,    bitRange=3-3
 2149                           ;`GPIO3IEV0.P3_4`           0x5003800C,        1, base=16,    bitRange=4-4
 2150                           ;`GPIO3IEV0.P3_5`           0x5003800C,        1, base=16,    bitRange=5-5
 2151                           
 2152                           GPIO3IEVL                EQU  0x5003800C
 2153                           ;`GPIO3IEVL.P3_0`           0x5003800C,        2, base=16,    bitRange=0-0
 2154                           ;`GPIO3IEVL.P3_1`           0x5003800C,        2, base=16,    bitRange=1-1
 2155                           ;`GPIO3IEVL.P3_2`           0x5003800C,        2, base=16,    bitRange=2-2
 2156                           ;`GPIO3IEVL.P3_3`           0x5003800C,        2, base=16,    bitRange=3-3
 2157                           ;`GPIO3IEVL.P3_4`           0x5003800C,        2, base=16,    bitRange=4-4
 2158                           ;`GPIO3IEVL.P3_5`           0x5003800C,        2, base=16,    bitRange=5-5
 2159                           
 2160                           GPIO3IE                  EQU  0x50038010
 2161                           ;`GPIO3IE.P3_0`             0x50038010,        4, base=16,    bitRange=0-0
 2162                           ;`GPIO3IE.P3_1`             0x50038010,        4, base=16,    bitRange=1-1
 2163                           ;`GPIO3IE.P3_2`             0x50038010,        4, base=16,    bitRange=2-2
 2164                           ;`GPIO3IE.P3_3`             0x50038010,        4, base=16,    bitRange=3-3
 2165                           ;`GPIO3IE.P3_4`             0x50038010,        4, base=16,    bitRange=4-4
 2166                           ;`GPIO3IE.P3_5`             0x50038010,        4, base=16,    bitRange=5-5
 2167                           
 2168                           GPIO3IE0                 EQU  0x50038010
 2169                           ;`GPIO3IE0.P3_0`            0x50038010,        1, base=16,    bitRange=0-0
 2170                           ;`GPIO3IE0.P3_1`            0x50038010,        1, base=16,    bitRange=1-1
 2171                           ;`GPIO3IE0.P3_2`            0x50038010,        1, base=16,    bitRange=2-2
 2172                           ;`GPIO3IE0.P3_3`            0x50038010,        1, base=16,    bitRange=3-3
 2173                           ;`GPIO3IE0.P3_4`            0x50038010,        1, base=16,    bitRange=4-4
 2174                           ;`GPIO3IE0.P3_5`            0x50038010,        1, base=16,    bitRange=5-5
 2175                           
 2176                           GPIO3IEL                 EQU  0x50038010
 2177                           ;`GPIO3IEL.P3_0`            0x50038010,        2, base=16,    bitRange=0-0
 2178                           ;`GPIO3IEL.P3_1`            0x50038010,        2, base=16,    bitRange=1-1
 2179                           ;`GPIO3IEL.P3_2`            0x50038010,        2, base=16,    bitRange=2-2
 2180                           ;`GPIO3IEL.P3_3`            0x50038010,        2, base=16,    bitRange=3-3
 2181                           ;`GPIO3IEL.P3_4`            0x50038010,        2, base=16,    bitRange=4-4
 2182                           ;`GPIO3IEL.P3_5`            0x50038010,        2, base=16,    bitRange=5-5
 2183                           
 2184                           GPIO3RIS                 EQU  0x50038014
 2185                           ;`GPIO3RIS.P3_0`            0x50038014,        4, base=16,    bitRange=0-0
 2186                           ;`GPIO3RIS.P3_1`            0x50038014,        4, base=16,    bitRange=1-1
 2187                           ;`GPIO3RIS.P3_2`            0x50038014,        4, base=16,    bitRange=2-2
 2188                           ;`GPIO3RIS.P3_3`            0x50038014,        4, base=16,    bitRange=3-3
 2189                           ;`GPIO3RIS.P3_4`            0x50038014,        4, base=16,    bitRange=4-4
 2190                           ;`GPIO3RIS.P3_5`            0x50038014,        4, base=16,    bitRange=5-5
 2191                           
 2192                           GPIO3RIS0                EQU  0x50038014
 2193                           ;`GPIO3RIS0.P3_0`           0x50038014,        1, base=16,    bitRange=0-0
 2194                           ;`GPIO3RIS0.P3_1`           0x50038014,        1, base=16,    bitRange=1-1
 2195                           ;`GPIO3RIS0.P3_2`           0x50038014,        1, base=16,    bitRange=2-2
 2196                           ;`GPIO3RIS0.P3_3`           0x50038014,        1, base=16,    bitRange=3-3
 2197                           ;`GPIO3RIS0.P3_4`           0x50038014,        1, base=16,    bitRange=4-4
 2198                           ;`GPIO3RIS0.P3_5`           0x50038014,        1, base=16,    bitRange=5-5
 2199                           
 2200                           GPIO3RISL                EQU  0x50038014
 2201                           ;`GPIO3RISL.P3_0`           0x50038014,        2, base=16,    bitRange=0-0
 2202                           ;`GPIO3RISL.P3_1`           0x50038014,        2, base=16,    bitRange=1-1
 2203                           ;`GPIO3RISL.P3_2`           0x50038014,        2, base=16,    bitRange=2-2
 2204                           ;`GPIO3RISL.P3_3`           0x50038014,        2, base=16,    bitRange=3-3
 2205                           ;`GPIO3RISL.P3_4`           0x50038014,        2, base=16,    bitRange=4-4
 2206                           ;`GPIO3RISL.P3_5`           0x50038014,        2, base=16,    bitRange=5-5
 2207                           
 2208                           GPIO3MIS                 EQU  0x50038018
 2209                           ;`GPIO3MIS.P3_0`            0x50038018,        4, base=16,    bitRange=0-0
 2210                           ;`GPIO3MIS.P3_1`            0x50038018,        4, base=16,    bitRange=1-1
 2211                           ;`GPIO3MIS.P3_2`            0x50038018,        4, base=16,    bitRange=2-2
 2212                           ;`GPIO3MIS.P3_3`            0x50038018,        4, base=16,    bitRange=3-3
 2213                           ;`GPIO3MIS.P3_4`            0x50038018,        4, base=16,    bitRange=4-4
 2214                           ;`GPIO3MIS.P3_5`            0x50038018,        4, base=16,    bitRange=5-5
 2215                           
 2216                           GPIO3MIS0                EQU  0x50038018
 2217                           ;`GPIO3MIS0.P3_0`           0x50038018,        1, base=16,    bitRange=0-0
 2218                           ;`GPIO3MIS0.P3_1`           0x50038018,        1, base=16,    bitRange=1-1
 2219                           ;`GPIO3MIS0.P3_2`           0x50038018,        1, base=16,    bitRange=2-2
 2220                           ;`GPIO3MIS0.P3_3`           0x50038018,        1, base=16,    bitRange=3-3
 2221                           ;`GPIO3MIS0.P3_4`           0x50038018,        1, base=16,    bitRange=4-4
 2222                           ;`GPIO3MIS0.P3_5`           0x50038018,        1, base=16,    bitRange=5-5
 2223                           
 2224                           GPIO3MISL                EQU  0x50038018
 2225                           ;`GPIO3MISL.P3_0`           0x50038018,        2, base=16,    bitRange=0-0
 2226                           ;`GPIO3MISL.P3_1`           0x50038018,        2, base=16,    bitRange=1-1
 2227                           ;`GPIO3MISL.P3_2`           0x50038018,        2, base=16,    bitRange=2-2
 2228                           ;`GPIO3MISL.P3_3`           0x50038018,        2, base=16,    bitRange=3-3
 2229                           ;`GPIO3MISL.P3_4`           0x50038018,        2, base=16,    bitRange=4-4
 2230                           ;`GPIO3MISL.P3_5`           0x50038018,        2, base=16,    bitRange=5-5
 2231                           
 2232                           GPIO3IC                  EQU  0x5003801C
 2233                           
 2234                           
 2235                           ;
 2236                           ;               UART
 2237                           ;
 2238                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2239                           ;     ----                        ----      -------     --------  ----------- --------
 2240                           
 2241                           
 2242                           U0RBRTHR                 EQU  0x40008000
 2243                           
 2244                           U0RBR                    EQU  0x40008000
 2245                           
 2246                           U0THR                    EQU  0x40008000
 2247                           
 2248                           U0DLL                    EQU  0x40008000
 2249                           
 2250                           U0DLM                    EQU  0x40008004
 2251                           
 2252                           U0IER                    EQU  0x40008004
 2253                           ;`U0IER.RDAIE`              0x40008004,        4, base=16,    bitRange=0-0
 2254                           ;`U0IER.THREIE`             0x40008004,        4, base=16,    bitRange=1-1
 2255                           ;`U0IER.RXLSIE`             0x40008004,        4, base=16,    bitRange=2-2
 2256                           ;`U0IER.ABEOINTEN`          0x40008004,        4, base=16,    bitRange=8-8
 2257                           ;`U0IER.ABTOINTEN`          0x40008004,        4, base=16,    bitRange=9-9
 2258                           
 2259                           U0FCR                    EQU  0x40008008
 2260                           ;`U0FCR.FCRFE`              0x40008008,        4, base=16,    bitRange=0-0
 2261                           ;`U0FCR.RFR`                0x40008008,        4, base=16,    bitRange=1-1
 2262                           ;`U0FCR.TFR`                0x40008008,        4, base=16,    bitRange=2-2
 2263                           ;`U0FCR.RTLS`               0x40008008,        4, base=16,    bitRange=6-7
 2264                           
 2265                           U0IIR                    EQU  0x40008008
 2266                           ;`U0IIR.IP`                 0x40008008,        4, base=16,    bitRange=0-0
 2267                           ;`U0IIR.IID`                0x40008008,        4, base=16,    bitRange=1-3
 2268                           ;`U0IIR.IIRFE`              0x40008008,        4, base=16,    bitRange=6-7
 2269                           ;`U0IIR.ABEOINT`            0x40008008,        4, base=16,    bitRange=8-8
 2270                           ;`U0IIR.ABTOINT`            0x40008008,        4, base=16,    bitRange=9-9
 2271                           
 2272                           U0LCR                    EQU  0x4000800C
 2273                           ;`U0LCR.WLS`                0x4000800C,        1, base=16,    bitRange=0-1
 2274                           ;`U0LCR.SBS`                0x4000800C,        1, base=16,    bitRange=2-2
 2275                           ;`U0LCR.PE`                 0x4000800C,        1, base=16,    bitRange=3-3
 2276                           ;`U0LCR.PS`                 0x4000800C,        1, base=16,    bitRange=4-5
 2277                           ;`U0LCR.BC`                 0x4000800C,        1, base=16,    bitRange=6-6
 2278                           ;`U0LCR.DLAB`               0x4000800C,        1, base=16,    bitRange=7-7
 2279                           
 2280                           U0MCR                    EQU  0x40008010
 2281                           ;`U0MCR.DTR`                0x40008010,        1, base=16,    bitRange=0-0
 2282                           ;`U0MCR.RTS`                0x40008010,        1, base=16,    bitRange=1-1
 2283                           ;`U0MCR.LMS`                0x40008010,        1, base=16,    bitRange=4-4
 2284                           ;`U0MCR.RTSEN`              0x40008010,        1, base=16,    bitRange=6-6
 2285                           ;`U0MCR.CTSEN`              0x40008010,        1, base=16,    bitRange=7-7
 2286                           
 2287                           U0LSR                    EQU  0x40008014
 2288                           ;`U0LSR.DR`                 0x40008014,        1, base=16,    bitRange=0-0
 2289                           ;`U0LSR.OE`                 0x40008014,        1, base=16,    bitRange=1-1
 2290                           ;`U0LSR.PE`                 0x40008014,        1, base=16,    bitRange=2-2
 2291                           ;`U0LSR.FE`                 0x40008014,        1, base=16,    bitRange=3-3
 2292                           ;`U0LSR.BI`                 0x40008014,        1, base=16,    bitRange=4-4
 2293                           ;`U0LSR.THRE`               0x40008014,        1, base=16,    bitRange=5-5
 2294                           ;`U0LSR.TEMT`               0x40008014,        1, base=16,    bitRange=6-6
 2295                           ;`U0LSR.RXFE`               0x40008014,        1, base=16,    bitRange=7-7
 2296                           
 2297                           U0MSR                    EQU  0x40008018
 2298                           ;`U0MSR.DCTS`               0x40008018,        1, base=16,    bitRange=0-0
 2299                           ;`U0MSR.DDSR`               0x40008018,        1, base=16,    bitRange=1-1
 2300                           ;`U0MSR.TERI`               0x40008018,        1, base=16,    bitRange=2-2
 2301                           ;`U0MSR.DDCD`               0x40008018,        1, base=16,    bitRange=3-3
 2302                           ;`U0MSR.CTS`                0x40008018,        1, base=16,    bitRange=4-4
 2303                           ;`U0MSR.DSR`                0x40008018,        1, base=16,    bitRange=5-5
 2304                           ;`U0MSR.RI`                 0x40008018,        1, base=16,    bitRange=6-6
 2305                           ;`U0MSR.DCD`                0x40008018,        1, base=16,    bitRange=7-7
 2306                           
 2307                           U0SCR                    EQU  0x4000801C
 2308                           
 2309                           U0ACR                    EQU  0x40008020
 2310                           ;`U0ACR.START`              0x40008020,        4, base=16,    bitRange=0-0
 2311                           ;`U0ACR.MODE`               0x40008020,        4, base=16,    bitRange=1-1
 2312                           ;`U0ACR.AUTORESTART`        0x40008020,        4, base=16,    bitRange=2-2
 2313                           ;`U0ACR.ABEOINTCLR`         0x40008020,        4, base=16,    bitRange=8-8
 2314                           ;`U0ACR.ABTOINTCLR`         0x40008020,        4, base=16,    bitRange=9-9
 2315                           
 2316                           U0FDR                    EQU  0x40008028
 2317                           ;`U0FDR.DIVADDVAL`          0x40008028,        4, base=16,    bitRange=0-3
 2318                           ;`U0FDR.MULVAL`             0x40008028,        4, base=16,    bitRange=4-7
 2319                           
 2320                           U0TER                    EQU  0x40008030
 2321                           ;`U0TER.TXEN`               0x40008030,        1, base=16,    bitRange=7-7
 2322                           
 2323                           U0RS485CTRL              EQU  0x4000804C
 2324                           ;`U0RS485CTRL.NMMEN`        0x4000804C,        4, base=16,    bitRange=0-0
 2325                           ;`U0RS485CTRL.RXDIS`        0x4000804C,        4, base=16,    bitRange=1-1
 2326                           ;`U0RS485CTRL.AADEN`        0x4000804C,        4, base=16,    bitRange=2-2
 2327                           ;`U0RS485CTRL.SEL`          0x4000804C,        4, base=16,    bitRange=3-3
 2328                           ;`U0RS485CTRL.DCTRL`        0x4000804C,        4, base=16,    bitRange=4-4
 2329                           ;`U0RS485CTRL.OINV`         0x4000804C,        4, base=16,    bitRange=5-5
 2330                           
 2331                           U0ADRMATCH               EQU  0x40008050
 2332                           
 2333                           U0RS485DLY               EQU  0x40008054
 2334                           
 2335                           
 2336                           ;
 2337                           ;               SSP0
 2338                           ;
 2339                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2340                           ;     ----                        ----      -------     --------  ----------- --------
 2341                           
 2342                           
 2343                           SSP0CR0                  EQU  0x40040000
 2344                           ;`SSP0CR0.DSS`              0x40040000,        4, base=16,    bitRange=0-3
 2345                           ;`SSP0CR0.FRF`              0x40040000,        4, base=16,    bitRange=4-5
 2346                           ;`SSP0CR0.CPOL`             0x40040000,        4, base=16,    bitRange=6-6
 2347                           ;`SSP0CR0.CPHA`             0x40040000,        4, base=16,    bitRange=7-7
 2348                           ;`SSP0CR0.SCR`              0x40040000,        4, base=16,    bitRange=8-15
 2349                           
 2350                           SSP0CR1                  EQU  0x40040004
 2351                           ;`SSP0CR1.LBM`              0x40040004,        4, base=16,    bitRange=0-0
 2352                           ;`SSP0CR1.SSE`              0x40040004,        4, base=16,    bitRange=1-1
 2353                           ;`SSP0CR1.MS`               0x40040004,        4, base=16,    bitRange=2-2
 2354                           ;`SSP0CR1.SOD`              0x40040004,        4, base=16,    bitRange=3-3
 2355                           
 2356                           SSP0DR                   EQU  0x40040008
 2357                           ;`SSP0DR.DATA`              0x40040008,        4, base=16,    bitRange=0-15
 2358                           
 2359                           SSP0SR                   EQU  0x4004000C
 2360                           ;`SSP0SR.TFE`               0x4004000C,        4, base=16,    bitRange=0-0
 2361                           ;`SSP0SR.TNF`               0x4004000C,        4, base=16,    bitRange=1-1
 2362                           ;`SSP0SR.RNE`               0x4004000C,        4, base=16,    bitRange=2-2
 2363                           ;`SSP0SR.RFF`               0x4004000C,        4, base=16,    bitRange=3-3
 2364                           ;`SSP0SR.BSY`               0x4004000C,        4, base=16,    bitRange=4-4
 2365                           
 2366                           SSP0CPSR                 EQU  0x40040010
 2367                           ;`SSP0CPSR.CPSDVSR`         0x40040010,        4, base=16,    bitRange=0-7
 2368                           
 2369                           SSP0IMSC                 EQU  0x40040014
 2370                           ;`SSP0IMSC.RORIM`           0x40040014,        4, base=16,    bitRange=0-0
 2371                           ;`SSP0IMSC.RTIM`            0x40040014,        4, base=16,    bitRange=1-1
 2372                           ;`SSP0IMSC.RXIM`            0x40040014,        4, base=16,    bitRange=2-2
 2373                           ;`SSP0IMSC.TXIM`            0x40040014,        4, base=16,    bitRange=3-3
 2374                           
 2375                           SSP0RIS                  EQU  0x40040018
 2376                           ;`SSP0RIS.RORRIS`           0x40040018,        4, base=16,    bitRange=0-0
 2377                           ;`SSP0RIS.RTRIS`            0x40040018,        4, base=16,    bitRange=1-1
 2378                           ;`SSP0RIS.RXRIS`            0x40040018,        4, base=16,    bitRange=2-2
 2379                           ;`SSP0RIS.TXRIS`            0x40040018,        4, base=16,    bitRange=3-3
 2380                           
 2381                           SSP0MIS                  EQU  0x4004001C
 2382                           ;`SSP0MIS.RORMIS`           0x4004001C,        4, base=16,    bitRange=0-0
 2383                           ;`SSP0MIS.RTMIS`            0x4004001C,        4, base=16,    bitRange=1-1
 2384                           ;`SSP0MIS.RXMIS`            0x4004001C,        4, base=16,    bitRange=2-2
 2385                           ;`SSP0MIS.TXMIS`            0x4004001C,        4, base=16,    bitRange=3-3
 2386                           
 2387                           SSP0ICR                  EQU  0x40040020
 2388                           ;`SSP0ICR.RORIC`            0x40040020,        4, base=16,    bitRange=0-0
 2389                           ;`SSP0ICR.RTIC`             0x40040020,        4, base=16,    bitRange=1-1
 2390                           
 2391                           
 2392                           ;
 2393                           ;               SSP1
 2394                           ;
 2395                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2396                           ;     ----                        ----      -------     --------  ----------- --------
 2397                           
 2398                           
 2399                           SSP1CR0                  EQU  0x40058000
 2400                           ;`SSP1CR0.DSS`              0x40058000,        4, base=16,    bitRange=0-3
 2401                           ;`SSP1CR0.FRF`              0x40058000,        4, base=16,    bitRange=4-5
 2402                           ;`SSP1CR0.CPOL`             0x40058000,        4, base=16,    bitRange=6-6
 2403                           ;`SSP1CR0.CPHA`             0x40058000,        4, base=16,    bitRange=7-7
 2404                           ;`SSP1CR0.SCR`              0x40058000,        4, base=16,    bitRange=8-15
 2405                           
 2406                           SSP1CR1                  EQU  0x40058004
 2407                           ;`SSP1CR1.LBM`              0x40058004,        4, base=16,    bitRange=0-0
 2408                           ;`SSP1CR1.SSE`              0x40058004,        4, base=16,    bitRange=1-1
 2409                           ;`SSP1CR1.MS`               0x40058004,        4, base=16,    bitRange=2-2
 2410                           ;`SSP1CR1.SOD`              0x40058004,        4, base=16,    bitRange=3-3
 2411                           
 2412                           SSP1DR                   EQU  0x40058008
 2413                           ;`SSP1DR.DATA`              0x40058008,        4, base=16,    bitRange=0-15
 2414                           
 2415                           SSP1SR                   EQU  0x4005800C
 2416                           ;`SSP1SR.TFE`               0x4005800C,        4, base=16,    bitRange=0-0
 2417                           ;`SSP1SR.TNF`               0x4005800C,        4, base=16,    bitRange=1-1
 2418                           ;`SSP1SR.RNE`               0x4005800C,        4, base=16,    bitRange=2-2
 2419                           ;`SSP1SR.RFF`               0x4005800C,        4, base=16,    bitRange=3-3
 2420                           ;`SSP1SR.BSY`               0x4005800C,        4, base=16,    bitRange=4-4
 2421                           
 2422                           SSP1CPSR                 EQU  0x40058010
 2423                           ;`SSP1CPSR.CPSDVSR`         0x40058010,        4, base=16,    bitRange=0-7
 2424                           
 2425                           SSP1IMSC                 EQU  0x40058014
 2426                           ;`SSP1IMSC.RORIM`           0x40058014,        4, base=16,    bitRange=0-0
 2427                           ;`SSP1IMSC.RTIM`            0x40058014,        4, base=16,    bitRange=1-1
 2428                           ;`SSP1IMSC.RXIM`            0x40058014,        4, base=16,    bitRange=2-2
 2429                           ;`SSP1IMSC.TXIM`            0x40058014,        4, base=16,    bitRange=3-3
 2430                           
 2431                           SSP1RIS                  EQU  0x40058018
 2432                           ;`SSP1RIS.RORRIS`           0x40058018,        4, base=16,    bitRange=0-0
 2433                           ;`SSP1RIS.RTRIS`            0x40058018,        4, base=16,    bitRange=1-1
 2434                           ;`SSP1RIS.RXRIS`            0x40058018,        4, base=16,    bitRange=2-2
 2435                           ;`SSP1RIS.TXRIS`            0x40058018,        4, base=16,    bitRange=3-3
 2436                           
 2437                           SSP1MIS                  EQU  0x4005801C
 2438                           ;`SSP1MIS.RORMIS`           0x4005801C,        4, base=16,    bitRange=0-0
 2439                           ;`SSP1MIS.RTMIS`            0x4005801C,        4, base=16,    bitRange=1-1
 2440                           ;`SSP1MIS.RXMIS`            0x4005801C,        4, base=16,    bitRange=2-2
 2441                           ;`SSP1MIS.TXMIS`            0x4005801C,        4, base=16,    bitRange=3-3
 2442                           
 2443                           SSP1ICR                  EQU  0x40058020
 2444                           ;`SSP1ICR.RORIC`            0x40058020,        4, base=16,    bitRange=0-0
 2445                           ;`SSP1ICR.RTIC`             0x40058020,        4, base=16,    bitRange=1-1
 2446                           
 2447                           
 2448                           ;
 2449                           ;               I2C
 2450                           ;
 2451                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2452                           ;     ----                        ----      -------     --------  ----------- --------
 2453                           
 2454                           
 2455                           I2C0CONSET               EQU  0x40000000
 2456                           ;`I2C0CONSET.AA`            0x40000000,        4, base=16,    bitRange=2-2
 2457                           ;`I2C0CONSET.SI`            0x40000000,        4, base=16,    bitRange=3-3
 2458                           ;`I2C0CONSET.STO`           0x40000000,        4, base=16,    bitRange=4-4
 2459                           ;`I2C0CONSET.STA`           0x40000000,        4, base=16,    bitRange=5-5
 2460                           ;`I2C0CONSET.I2EN`          0x40000000,        4, base=16,    bitRange=6-6
 2461                           
 2462                           I2C0STAT                 EQU  0x40000004
 2463                           ;`I2C0STAT.STATUS`          0x40000004,        4, base=16,    bitRange=0-7
 2464                           
 2465                           I2C0DAT                  EQU  0x40000008
 2466                           ;`I2C0DAT.DATA`             0x40000008,        4, base=16,    bitRange=0-7
 2467                           
 2468                           I2C0ADR                  EQU  0x4000000C
 2469                           ;`I2C0ADR.GC`               0x4000000C,        4, base=16,    bitRange=0-0
 2470                           ;`I2C0ADR.ADDR`             0x4000000C,        4, base=16,    bitRange=1-7
 2471                           
 2472                           I2C0SCLH                 EQU  0x40000010
 2473                           ;`I2C0SCLH.SCLH`            0x40000010,        4, base=16,    bitRange=0-15
 2474                           
 2475                           I2C0SCLL                 EQU  0x40000014
 2476                           ;`I2C0SCLL.SCLL`            0x40000014,        4, base=16,    bitRange=0-15
 2477                           
 2478                           I2C0CONCLR               EQU  0x40000018
 2479                           
 2480                           I2C0MMCTRL               EQU  0x4000001C
 2481                           ;`I2C0MMCTRL.MM_ENA`        0x4000001C,        4, base=16,    bitRange=0-0
 2482                           ;`I2C0MMCTRL.ENA_SCL`       0x4000001C,        4, base=16,    bitRange=1-1
 2483                           ;`I2C0MMCTRL.MATCH_ALL`     0x4000001C,        4, base=16,    bitRange=2-2
 2484                           
 2485                           I2C0ADR1                 EQU  0x40000020
 2486                           ;`I2C0ADR1.GC`              0x40000020,        4, base=16,    bitRange=0-0
 2487                           ;`I2C0ADR1.ADDR`            0x40000020,        4, base=16,    bitRange=1-7
 2488                           
 2489                           I2C0ADR2                 EQU  0x40000024
 2490                           ;`I2C0ADR2.GC`              0x40000024,        4, base=16,    bitRange=0-0
 2491                           ;`I2C0ADR2.ADDR`            0x40000024,        4, base=16,    bitRange=1-7
 2492                           
 2493                           I2C0ADR3                 EQU  0x40000028
 2494                           ;`I2C0ADR3.GC`              0x40000028,        4, base=16,    bitRange=0-0
 2495                           ;`I2C0ADR3.ADDR`            0x40000028,        4, base=16,    bitRange=1-7
 2496                           
 2497                           I2C0DATABUFFER           EQU  0x4000002C
 2498                           ;`I2C0DATABUFFER.DATA`      0x4000002C,        4, base=16,    bitRange=0-7
 2499                           
 2500                           I2C0MASK0                EQU  0x40000030
 2501                           ;`I2C0MASK0.MASK`           0x40000030,        4, base=16,    bitRange=1-7
 2502                           
 2503                           I2C0MASK1                EQU  0x40000034
 2504                           ;`I2C0MASK1.MASK`           0x40000034,        4, base=16,    bitRange=1-7
 2505                           
 2506                           I2C0MASK2                EQU  0x40000038
 2507                           ;`I2C0MASK2.MASK`           0x40000038,        4, base=16,    bitRange=1-7
 2508                           
 2509                           I2C0MASK3                EQU  0x4000003C
 2510                           ;`I2C0MASK3.MASK`           0x4000003C,        4, base=16,    bitRange=1-7
 2511                           
 2512                           
 2513                           ;
 2514                           ;               CT16B0
 2515                           ;
 2516                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2517                           ;     ----                        ----      -------     --------  ----------- --------
 2518                           
 2519                           
 2520                           TMR16B0IR                EQU  0x4000C000
 2521                           ;`TMR16B0IR.MR0INT`         0x4000C000,        4, base=16,    bitRange=0-0
 2522                           ;`TMR16B0IR.MR1INT`         0x4000C000,        4, base=16,    bitRange=1-1
 2523                           ;`TMR16B0IR.MR2INT`         0x4000C000,        4, base=16,    bitRange=2-2
 2524                           ;`TMR16B0IR.MR3INT`         0x4000C000,        4, base=16,    bitRange=3-3
 2525                           ;`TMR16B0IR.CR0INT`         0x4000C000,        4, base=16,    bitRange=4-4
 2526                           
 2527                           TMR16B0TCR               EQU  0x4000C004
 2528                           ;`TMR16B0TCR.CE`            0x4000C004,        4, base=16,    bitRange=0-0
 2529                           ;`TMR16B0TCR.CR`            0x4000C004,        4, base=16,    bitRange=1-1
 2530                           
 2531                           TMR16B0TC                EQU  0x4000C008
 2532                           
 2533                           TMR16B0PR                EQU  0x4000C00C
 2534                           
 2535                           TMR16B0PC                EQU  0x4000C010
 2536                           
 2537                           TMR16B0MCR               EQU  0x4000C014
 2538                           ;`TMR16B0MCR.MR0I`          0x4000C014,        4, base=16,    bitRange=0-0
 2539                           ;`TMR16B0MCR.MR0R`          0x4000C014,        4, base=16,    bitRange=1-1
 2540                           ;`TMR16B0MCR.MR0S`          0x4000C014,        4, base=16,    bitRange=2-2
 2541                           ;`TMR16B0MCR.MR1I`          0x4000C014,        4, base=16,    bitRange=3-3
 2542                           ;`TMR16B0MCR.MR1R`          0x4000C014,        4, base=16,    bitRange=4-4
 2543                           ;`TMR16B0MCR.MR1S`          0x4000C014,        4, base=16,    bitRange=5-5
 2544                           ;`TMR16B0MCR.MR2I`          0x4000C014,        4, base=16,    bitRange=6-6
 2545                           ;`TMR16B0MCR.MR2R`          0x4000C014,        4, base=16,    bitRange=7-7
 2546                           ;`TMR16B0MCR.MR2S`          0x4000C014,        4, base=16,    bitRange=8-8
 2547                           ;`TMR16B0MCR.MR3I`          0x4000C014,        4, base=16,    bitRange=9-9
 2548                           ;`TMR16B0MCR.MR3R`          0x4000C014,        4, base=16,    bitRange=10-10
 2549                           ;`TMR16B0MCR.MR3S`          0x4000C014,        4, base=16,    bitRange=11-11
 2550                           
 2551                           TMR16B0MR0               EQU  0x4000C018
 2552                           
 2553                           TMR16B0MR1               EQU  0x4000C01C
 2554                           
 2555                           TMR16B0MR2               EQU  0x4000C020
 2556                           
 2557                           TMR16B0MR3               EQU  0x4000C024
 2558                           
 2559                           TMR16B0CCR               EQU  0x4000C028
 2560                           ;`TMR16B0CCR.CAP0RE`        0x4000C028,        4, base=16,    bitRange=0-0
 2561                           ;`TMR16B0CCR.CAP0FE`        0x4000C028,        4, base=16,    bitRange=1-1
 2562                           ;`TMR16B0CCR.CAP0I`         0x4000C028,        4, base=16,    bitRange=2-2
 2563                           
 2564                           TMR16B0CR0               EQU  0x4000C02C
 2565                           
 2566                           TMR16B0EMR               EQU  0x4000C03C
 2567                           ;`TMR16B0EMR.EM0`           0x4000C03C,        4, base=16,    bitRange=0-0
 2568                           ;`TMR16B0EMR.EM1`           0x4000C03C,        4, base=16,    bitRange=1-1
 2569                           ;`TMR16B0EMR.EM2`           0x4000C03C,        4, base=16,    bitRange=2-2
 2570                           ;`TMR16B0EMR.EM3`           0x4000C03C,        4, base=16,    bitRange=3-3
 2571                           ;`TMR16B0EMR.EMC0`          0x4000C03C,        4, base=16,    bitRange=4-5
 2572                           ;`TMR16B0EMR.EMC1`          0x4000C03C,        4, base=16,    bitRange=6-7
 2573                           ;`TMR16B0EMR.EMC2`          0x4000C03C,        4, base=16,    bitRange=8-9
 2574                           ;`TMR16B0EMR.EMC3`          0x4000C03C,        4, base=16,    bitRange=10-11
 2575                           
 2576                           TMR16B0CTCR              EQU  0x4000C070
 2577                           ;`TMR16B0CTCR.CTM`          0x4000C070,        4, base=16,    bitRange=0-1
 2578                           ;`TMR16B0CTCR.CIS`          0x4000C070,        4, base=16,    bitRange=2-3
 2579                           
 2580                           TMR16B0PWMC              EQU  0x4000C074
 2581                           ;`TMR16B0PWMC.PWM0ENA`      0x4000C074,        4, base=16,    bitRange=0-0
 2582                           ;`TMR16B0PWMC.PWM1ENA`      0x4000C074,        4, base=16,    bitRange=1-1
 2583                           ;`TMR16B0PWMC.PWM2ENA`      0x4000C074,        4, base=16,    bitRange=2-2
 2584                           ;`TMR16B0PWMC.PWM3ENA`      0x4000C074,        4, base=16,    bitRange=3-3
 2585                           
 2586                           
 2587                           ;
 2588                           ;               CT16B1
 2589                           ;
 2590                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2591                           ;     ----                        ----      -------     --------  ----------- --------
 2592                           
 2593                           
 2594                           TMR16B1IR                EQU  0x40010000
 2595                           ;`TMR16B1IR.MR0INT`         0x40010000,        4, base=16,    bitRange=0-0
 2596                           ;`TMR16B1IR.MR1INT`         0x40010000,        4, base=16,    bitRange=1-1
 2597                           ;`TMR16B1IR.MR2INT`         0x40010000,        4, base=16,    bitRange=2-2
 2598                           ;`TMR16B1IR.MR3INT`         0x40010000,        4, base=16,    bitRange=3-3
 2599                           ;`TMR16B1IR.CR0INT`         0x40010000,        4, base=16,    bitRange=4-4
 2600                           
 2601                           TMR16B1TCR               EQU  0x40010004
 2602                           ;`TMR16B1TCR.CE`            0x40010004,        4, base=16,    bitRange=0-0
 2603                           ;`TMR16B1TCR.CR`            0x40010004,        4, base=16,    bitRange=1-1
 2604                           
 2605                           TMR16B1TC                EQU  0x40010008
 2606                           
 2607                           TMR16B1PR                EQU  0x4001000C
 2608                           
 2609                           TMR16B1PC                EQU  0x40010010
 2610                           
 2611                           TMR16B1MCR               EQU  0x40010014
 2612                           ;`TMR16B1MCR.MR0I`          0x40010014,        4, base=16,    bitRange=0-0
 2613                           ;`TMR16B1MCR.MR0R`          0x40010014,        4, base=16,    bitRange=1-1
 2614                           ;`TMR16B1MCR.MR0S`          0x40010014,        4, base=16,    bitRange=2-2
 2615                           ;`TMR16B1MCR.MR1I`          0x40010014,        4, base=16,    bitRange=3-3
 2616                           ;`TMR16B1MCR.MR1R`          0x40010014,        4, base=16,    bitRange=4-4
 2617                           ;`TMR16B1MCR.MR1S`          0x40010014,        4, base=16,    bitRange=5-5
 2618                           ;`TMR16B1MCR.MR2I`          0x40010014,        4, base=16,    bitRange=6-6
 2619                           ;`TMR16B1MCR.MR2R`          0x40010014,        4, base=16,    bitRange=7-7
 2620                           ;`TMR16B1MCR.MR2S`          0x40010014,        4, base=16,    bitRange=8-8
 2621                           ;`TMR16B1MCR.MR3I`          0x40010014,        4, base=16,    bitRange=9-9
 2622                           ;`TMR16B1MCR.MR3R`          0x40010014,        4, base=16,    bitRange=10-10
 2623                           ;`TMR16B1MCR.MR3S`          0x40010014,        4, base=16,    bitRange=11-11
 2624                           
 2625                           TMR16B1MR0               EQU  0x40010018
 2626                           
 2627                           TMR16B1MR1               EQU  0x4001001C
 2628                           
 2629                           TMR16B1MR2               EQU  0x40010020
 2630                           
 2631                           TMR16B1MR3               EQU  0x40010024
 2632                           
 2633                           TMR16B1CCR               EQU  0x40010028
 2634                           ;`TMR16B1CCR.CAP0RE`        0x40010028,        4, base=16,    bitRange=0-0
 2635                           ;`TMR16B1CCR.CAP0FE`        0x40010028,        4, base=16,    bitRange=1-1
 2636                           ;`TMR16B1CCR.CAP0I`         0x40010028,        4, base=16,    bitRange=2-2
 2637                           
 2638                           TMR16B1CR0               EQU  0x4001002C
 2639                           
 2640                           TMR16B1EMR               EQU  0x4001003C
 2641                           ;`TMR16B1EMR.EM0`           0x4001003C,        4, base=16,    bitRange=0-0
 2642                           ;`TMR16B1EMR.EM1`           0x4001003C,        4, base=16,    bitRange=1-1
 2643                           ;`TMR16B1EMR.EM2`           0x4001003C,        4, base=16,    bitRange=2-2
 2644                           ;`TMR16B1EMR.EM3`           0x4001003C,        4, base=16,    bitRange=3-3
 2645                           ;`TMR16B1EMR.EMC0`          0x4001003C,        4, base=16,    bitRange=4-5
 2646                           ;`TMR16B1EMR.EMC1`          0x4001003C,        4, base=16,    bitRange=6-7
 2647                           ;`TMR16B1EMR.EMC2`          0x4001003C,        4, base=16,    bitRange=8-9
 2648                           ;`TMR16B1EMR.EMC3`          0x4001003C,        4, base=16,    bitRange=10-11
 2649                           
 2650                           TMR16B1CTCR              EQU  0x40010070
 2651                           ;`TMR16B1CTCR.CTM`          0x40010070,        4, base=16,    bitRange=0-1
 2652                           ;`TMR16B1CTCR.CIS`          0x40010070,        4, base=16,    bitRange=2-3
 2653                           
 2654                           TMR16B1PWMC              EQU  0x40010074
 2655                           ;`TMR16B1PWMC.PWM0ENA`      0x40010074,        4, base=16,    bitRange=0-0
 2656                           ;`TMR16B1PWMC.PWM1ENA`      0x40010074,        4, base=16,    bitRange=1-1
 2657                           ;`TMR16B1PWMC.PWM2ENA`      0x40010074,        4, base=16,    bitRange=2-2
 2658                           ;`TMR16B1PWMC.PWM3ENA`      0x40010074,        4, base=16,    bitRange=3-3
 2659                           
 2660                           
 2661                           ;
 2662                           ;               CT32B0
 2663                           ;
 2664                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2665                           ;     ----                        ----      -------     --------  ----------- --------
 2666                           
 2667                           
 2668                           TMR32B0IR                EQU  0x40014000
 2669                           ;`TMR32B0IR.MR0INT`         0x40014000,        4, base=16,    bitRange=0-0
 2670                           ;`TMR32B0IR.MR1INT`         0x40014000,        4, base=16,    bitRange=1-1
 2671                           ;`TMR32B0IR.MR2INT`         0x40014000,        4, base=16,    bitRange=2-2
 2672                           ;`TMR32B0IR.MR3INT`         0x40014000,        4, base=16,    bitRange=3-3
 2673                           ;`TMR32B0IR.CR0INT`         0x40014000,        4, base=16,    bitRange=4-4
 2674                           
 2675                           TMR32B0TCR               EQU  0x40014004
 2676                           ;`TMR32B0TCR.CE`            0x40014004,        4, base=16,    bitRange=0-0
 2677                           ;`TMR32B0TCR.CR`            0x40014004,        4, base=16,    bitRange=1-1
 2678                           
 2679                           TMR32B0TC                EQU  0x40014008
 2680                           
 2681                           TMR32B0PR                EQU  0x4001400C
 2682                           
 2683                           TMR32B0PC                EQU  0x40014010
 2684                           
 2685                           TMR32B0MCR               EQU  0x40014014
 2686                           ;`TMR32B0MCR.MR0I`          0x40014014,        4, base=16,    bitRange=0-0
 2687                           ;`TMR32B0MCR.MR0R`          0x40014014,        4, base=16,    bitRange=1-1
 2688                           ;`TMR32B0MCR.MR0S`          0x40014014,        4, base=16,    bitRange=2-2
 2689                           ;`TMR32B0MCR.MR1I`          0x40014014,        4, base=16,    bitRange=3-3
 2690                           ;`TMR32B0MCR.MR1R`          0x40014014,        4, base=16,    bitRange=4-4
 2691                           ;`TMR32B0MCR.MR1S`          0x40014014,        4, base=16,    bitRange=5-5
 2692                           ;`TMR32B0MCR.MR2I`          0x40014014,        4, base=16,    bitRange=6-6
 2693                           ;`TMR32B0MCR.MR2R`          0x40014014,        4, base=16,    bitRange=7-7
 2694                           ;`TMR32B0MCR.MR2S`          0x40014014,        4, base=16,    bitRange=8-8
 2695                           ;`TMR32B0MCR.MR3I`          0x40014014,        4, base=16,    bitRange=9-9
 2696                           ;`TMR32B0MCR.MR3R`          0x40014014,        4, base=16,    bitRange=10-10
 2697                           ;`TMR32B0MCR.MR3S`          0x40014014,        4, base=16,    bitRange=11-11
 2698                           
 2699                           TMR32B0MR0               EQU  0x40014018
 2700                           
 2701                           TMR32B0MR1               EQU  0x4001401C
 2702                           
 2703                           TMR32B0MR2               EQU  0x40014020
 2704                           
 2705                           TMR32B0MR3               EQU  0x40014024
 2706                           
 2707                           TMR32B0CCR               EQU  0x40014028
 2708                           ;`TMR32B0CCR.CAP0RE`        0x40014028,        4, base=16,    bitRange=0-0
 2709                           ;`TMR32B0CCR.CAP0FE`        0x40014028,        4, base=16,    bitRange=1-1
 2710                           ;`TMR32B0CCR.CAP0I`         0x40014028,        4, base=16,    bitRange=2-2
 2711                           
 2712                           TMR32B0CR0               EQU  0x4001402C
 2713                           
 2714                           TMR32B0EMR               EQU  0x4001403C
 2715                           ;`TMR32B0EMR.EM0`           0x4001403C,        4, base=16,    bitRange=0-0
 2716                           ;`TMR32B0EMR.EM1`           0x4001403C,        4, base=16,    bitRange=1-1
 2717                           ;`TMR32B0EMR.EM2`           0x4001403C,        4, base=16,    bitRange=2-2
 2718                           ;`TMR32B0EMR.EM3`           0x4001403C,        4, base=16,    bitRange=3-3
 2719                           ;`TMR32B0EMR.EMC0`          0x4001403C,        4, base=16,    bitRange=4-5
 2720                           ;`TMR32B0EMR.EMC1`          0x4001403C,        4, base=16,    bitRange=6-7
 2721                           ;`TMR32B0EMR.EMC2`          0x4001403C,        4, base=16,    bitRange=8-9
 2722                           ;`TMR32B0EMR.EMC3`          0x4001403C,        4, base=16,    bitRange=10-11
 2723                           
 2724                           TMR32B0CTCR              EQU  0x40014070
 2725                           ;`TMR32B0CTCR.CTM`          0x40014070,        4, base=16,    bitRange=0-1
 2726                           ;`TMR32B0CTCR.CIS`          0x40014070,        4, base=16,    bitRange=2-3
 2727                           
 2728                           TMR32B0PWMC              EQU  0x40014074
 2729                           ;`TMR32B0PWMC.PWM0ENA`      0x40014074,        4, base=16,    bitRange=0-0
 2730                           ;`TMR32B0PWMC.PWM1ENA`      0x40014074,        4, base=16,    bitRange=1-1
 2731                           ;`TMR32B0PWMC.PWM2ENA`      0x40014074,        4, base=16,    bitRange=2-2
 2732                           ;`TMR32B0PWMC.PWM3ENA`      0x40014074,        4, base=16,    bitRange=3-3
 2733                           
 2734                           
 2735                           ;
 2736                           ;               CT32B1
 2737                           ;
 2738                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2739                           ;     ----                        ----      -------     --------  ----------- --------
 2740                           
 2741                           
 2742                           TMR32B1IR                EQU  0x40018000
 2743                           ;`TMR32B1IR.MR0INT`         0x40018000,        4, base=16,    bitRange=0-0
 2744                           ;`TMR32B1IR.MR1INT`         0x40018000,        4, base=16,    bitRange=1-1
 2745                           ;`TMR32B1IR.MR2INT`         0x40018000,        4, base=16,    bitRange=2-2
 2746                           ;`TMR32B1IR.MR3INT`         0x40018000,        4, base=16,    bitRange=3-3
 2747                           ;`TMR32B1IR.CR0INT`         0x40018000,        4, base=16,    bitRange=4-4
 2748                           
 2749                           TMR32B1TCR               EQU  0x40018004
 2750                           ;`TMR32B1TCR.CE`            0x40018004,        4, base=16,    bitRange=0-0
 2751                           ;`TMR32B1TCR.CR`            0x40018004,        4, base=16,    bitRange=1-1
 2752                           
 2753                           TMR32B1TC                EQU  0x40018008
 2754                           
 2755                           TMR32B1PR                EQU  0x4001800C
 2756                           
 2757                           TMR32B1PC                EQU  0x40018010
 2758                           
 2759                           TMR32B1MCR               EQU  0x40018014
 2760                           ;`TMR32B1MCR.MR0I`          0x40018014,        4, base=16,    bitRange=0-0
 2761                           ;`TMR32B1MCR.MR0R`          0x40018014,        4, base=16,    bitRange=1-1
 2762                           ;`TMR32B1MCR.MR0S`          0x40018014,        4, base=16,    bitRange=2-2
 2763                           ;`TMR32B1MCR.MR1I`          0x40018014,        4, base=16,    bitRange=3-3
 2764                           ;`TMR32B1MCR.MR1R`          0x40018014,        4, base=16,    bitRange=4-4
 2765                           ;`TMR32B1MCR.MR1S`          0x40018014,        4, base=16,    bitRange=5-5
 2766                           ;`TMR32B1MCR.MR2I`          0x40018014,        4, base=16,    bitRange=6-6
 2767                           ;`TMR32B1MCR.MR2R`          0x40018014,        4, base=16,    bitRange=7-7
 2768                           ;`TMR32B1MCR.MR2S`          0x40018014,        4, base=16,    bitRange=8-8
 2769                           ;`TMR32B1MCR.MR3I`          0x40018014,        4, base=16,    bitRange=9-9
 2770                           ;`TMR32B1MCR.MR3R`          0x40018014,        4, base=16,    bitRange=10-10
 2771                           ;`TMR32B1MCR.MR3S`          0x40018014,        4, base=16,    bitRange=11-11
 2772                           
 2773                           TMR32B1MR0               EQU  0x40018018
 2774                           
 2775                           TMR32B1MR1               EQU  0x4001801C
 2776                           
 2777                           TMR32B1MR2               EQU  0x40018020
 2778                           
 2779                           TMR32B1MR3               EQU  0x40018024
 2780                           
 2781                           TMR32B1CCR               EQU  0x40018028
 2782                           ;`TMR32B1CCR.CAP0RE`        0x40018028,        4, base=16,    bitRange=0-0
 2783                           ;`TMR32B1CCR.CAP0FE`        0x40018028,        4, base=16,    bitRange=1-1
 2784                           ;`TMR32B1CCR.CAP0I`         0x40018028,        4, base=16,    bitRange=2-2
 2785                           
 2786                           TMR32B1CR0               EQU  0x4001802C
 2787                           
 2788                           TMR32B1EMR               EQU  0x4001803C
 2789                           ;`TMR32B1EMR.EM0`           0x4001803C,        4, base=16,    bitRange=0-0
 2790                           ;`TMR32B1EMR.EM1`           0x4001803C,        4, base=16,    bitRange=1-1
 2791                           ;`TMR32B1EMR.EM2`           0x4001803C,        4, base=16,    bitRange=2-2
 2792                           ;`TMR32B1EMR.EM3`           0x4001803C,        4, base=16,    bitRange=3-3
 2793                           ;`TMR32B1EMR.EMC0`          0x4001803C,        4, base=16,    bitRange=4-5
 2794                           ;`TMR32B1EMR.EMC1`          0x4001803C,        4, base=16,    bitRange=6-7
 2795                           ;`TMR32B1EMR.EMC2`          0x4001803C,        4, base=16,    bitRange=8-9
 2796                           ;`TMR32B1EMR.EMC3`          0x4001803C,        4, base=16,    bitRange=10-11
 2797                           
 2798                           TMR32B1CTCR              EQU  0x40018070
 2799                           ;`TMR32B1CTCR.CTM`          0x40018070,        4, base=16,    bitRange=0-1
 2800                           ;`TMR32B1CTCR.CIS`          0x40018070,        4, base=16,    bitRange=2-3
 2801                           
 2802                           TMR32B1PWMC              EQU  0x40018074
 2803                           ;`TMR32B1PWMC.PWM0ENA`      0x40018074,        4, base=16,    bitRange=0-0
 2804                           ;`TMR32B1PWMC.PWM1ENA`      0x40018074,        4, base=16,    bitRange=1-1
 2805                           ;`TMR32B1PWMC.PWM2ENA`      0x40018074,        4, base=16,    bitRange=2-2
 2806                           ;`TMR32B1PWMC.PWM3ENA`      0x40018074,        4, base=16,    bitRange=3-3
 2807                           
 2808                           
 2809                           ;
 2810                           ;               A/D Converters
 2811                           ;
 2812                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2813                           ;     ----                        ----      -------     --------  ----------- --------
 2814                           
 2815                           
 2816                           AD0CR                    EQU  0x4001C000
 2817                           ;`AD0CR.SEL`                0x4001C000,        4, base=16,    bitRange=0-7
 2818                           ;`AD0CR.CLKDIV`             0x4001C000,        4, base=16,    bitRange=8-15
 2819                           ;`AD0CR.BURST`              0x4001C000,        4, base=16,    bitRange=16-16
 2820                           ;`AD0CR.CLKS`               0x4001C000,        4, base=16,    bitRange=17-19
 2821                           ;`AD0CR.START`              0x4001C000,        4, base=16,    bitRange=24-26
 2822                           ;`AD0CR.EDGE`               0x4001C000,        4, base=16,    bitRange=27-27
 2823                           
 2824                           AD0GDR                   EQU  0x4001C004
 2825                           ;`AD0GDR.RESULT`            0x4001C004,        4, base=16,    bitRange=6-15
 2826                           ;`AD0GDR.CHN`               0x4001C004,        4, base=16,    bitRange=24-26
 2827                           ;`AD0GDR.OVERUN`            0x4001C004,        4, base=16,    bitRange=30-30
 2828                           ;`AD0GDR.DONE`              0x4001C004,        4, base=16,    bitRange=31-31
 2829                           
 2830                           AD0INTEN                 EQU  0x4001C00C
 2831                           ;`AD0INTEN.ADINTEN0`        0x4001C00C,        4, base=16,    bitRange=0-0
 2832                           ;`AD0INTEN.ADINTEN1`        0x4001C00C,        4, base=16,    bitRange=1-1
 2833                           ;`AD0INTEN.ADINTEN2`        0x4001C00C,        4, base=16,    bitRange=2-2
 2834                           ;`AD0INTEN.ADINTEN3`        0x4001C00C,        4, base=16,    bitRange=3-3
 2835                           ;`AD0INTEN.ADINTEN4`        0x4001C00C,        4, base=16,    bitRange=4-4
 2836                           ;`AD0INTEN.ADINTEN5`        0x4001C00C,        4, base=16,    bitRange=5-5
 2837                           ;`AD0INTEN.ADINTEN6`        0x4001C00C,        4, base=16,    bitRange=6-6
 2838                           ;`AD0INTEN.ADINTEN7`        0x4001C00C,        4, base=16,    bitRange=7-7
 2839                           ;`AD0INTEN.ADGINTEN`        0x4001C00C,        4, base=16,    bitRange=8-8
 2840                           
 2841                           AD0DR0                   EQU  0x4001C010
 2842                           ;`AD0DR0.RESULT`            0x4001C010,        4, base=16,    bitRange=6-15
 2843                           ;`AD0DR0.OVERUN`            0x4001C010,        4, base=16,    bitRange=30-30
 2844                           ;`AD0DR0.DONE`              0x4001C010,        4, base=16,    bitRange=31-31
 2845                           
 2846                           AD0DR1                   EQU  0x4001C014
 2847                           ;`AD0DR1.RESULT`            0x4001C014,        4, base=16,    bitRange=6-15
 2848                           ;`AD0DR1.OVERUN`            0x4001C014,        4, base=16,    bitRange=30-30
 2849                           ;`AD0DR1.DONE`              0x4001C014,        4, base=16,    bitRange=31-31
 2850                           
 2851                           AD0DR2                   EQU  0x4001C018
 2852                           ;`AD0DR2.RESULT`            0x4001C018,        4, base=16,    bitRange=6-15
 2853                           ;`AD0DR2.OVERUN`            0x4001C018,        4, base=16,    bitRange=30-30
 2854                           ;`AD0DR2.DONE`              0x4001C018,        4, base=16,    bitRange=31-31
 2855                           
 2856                           AD0DR3                   EQU  0x4001C01C
 2857                           ;`AD0DR3.RESULT`            0x4001C01C,        4, base=16,    bitRange=6-15
 2858                           ;`AD0DR3.OVERUN`            0x4001C01C,        4, base=16,    bitRange=30-30
 2859                           ;`AD0DR3.DONE`              0x4001C01C,        4, base=16,    bitRange=31-31
 2860                           
 2861                           AD0DR4                   EQU  0x4001C020
 2862                           ;`AD0DR4.RESULT`            0x4001C020,        4, base=16,    bitRange=6-15
 2863                           ;`AD0DR4.OVERUN`            0x4001C020,        4, base=16,    bitRange=30-30
 2864                           ;`AD0DR4.DONE`              0x4001C020,        4, base=16,    bitRange=31-31
 2865                           
 2866                           AD0DR5                   EQU  0x4001C024
 2867                           ;`AD0DR5.RESULT`            0x4001C024,        4, base=16,    bitRange=6-15
 2868                           ;`AD0DR5.OVERUN`            0x4001C024,        4, base=16,    bitRange=30-30
 2869                           ;`AD0DR5.DONE`              0x4001C024,        4, base=16,    bitRange=31-31
 2870                           
 2871                           AD0DR6                   EQU  0x4001C028
 2872                           ;`AD0DR6.RESULT`            0x4001C028,        4, base=16,    bitRange=6-15
 2873                           ;`AD0DR6.OVERUN`            0x4001C028,        4, base=16,    bitRange=30-30
 2874                           ;`AD0DR6.DONE`              0x4001C028,        4, base=16,    bitRange=31-31
 2875                           
 2876                           AD0DR7                   EQU  0x4001C02C
 2877                           ;`AD0DR7.RESULT`            0x4001C02C,        4, base=16,    bitRange=6-15
 2878                           ;`AD0DR7.OVERUN`            0x4001C02C,        4, base=16,    bitRange=30-30
 2879                           ;`AD0DR7.DONE`              0x4001C02C,        4, base=16,    bitRange=31-31
 2880                           
 2881                           AD0STAT                  EQU  0x4001C030
 2882                           ;`AD0STAT.DONE0`            0x4001C030,        4, base=16,    bitRange=0-0
 2883                           ;`AD0STAT.DONE1`            0x4001C030,        4, base=16,    bitRange=1-1
 2884                           ;`AD0STAT.DONE2`            0x4001C030,        4, base=16,    bitRange=2-2
 2885                           ;`AD0STAT.DONE3`            0x4001C030,        4, base=16,    bitRange=3-3
 2886                           ;`AD0STAT.DONE4`            0x4001C030,        4, base=16,    bitRange=4-4
 2887                           ;`AD0STAT.DONE5`            0x4001C030,        4, base=16,    bitRange=5-5
 2888                           ;`AD0STAT.DONE6`            0x4001C030,        4, base=16,    bitRange=6-6
 2889                           ;`AD0STAT.DONE7`            0x4001C030,        4, base=16,    bitRange=7-7
 2890                           ;`AD0STAT.OVERRUN0`         0x4001C030,        4, base=16,    bitRange=8-8
 2891                           ;`AD0STAT.OVERRUN1`         0x4001C030,        4, base=16,    bitRange=9-9
 2892                           ;`AD0STAT.OVERRUN2`         0x4001C030,        4, base=16,    bitRange=10-10
 2893                           ;`AD0STAT.OVERRUN3`         0x4001C030,        4, base=16,    bitRange=11-11
 2894                           ;`AD0STAT.OVERRUN4`         0x4001C030,        4, base=16,    bitRange=12-12
 2895                           ;`AD0STAT.OVERRUN5`         0x4001C030,        4, base=16,    bitRange=13-13
 2896                           ;`AD0STAT.OVERRUN6`         0x4001C030,        4, base=16,    bitRange=14-14
 2897                           ;`AD0STAT.OVERRUN7`         0x4001C030,        4, base=16,    bitRange=15-15
 2898                           ;`AD0STAT.ADINT`            0x4001C030,        4, base=16,    bitRange=16-16
 2899                           
 2900                           
 2901                           ;
 2902                           ;               Watchdog
 2903                           ;
 2904                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2905                           ;     ----                        ----      -------     --------  ----------- --------
 2906                           
 2907                           
 2908                           WDMOD                    EQU  0x40004000
 2909                           ;`WDMOD.WDEN`               0x40004000,        4, base=16,    bitRange=0-0
 2910                           ;`WDMOD.WDRESET`            0x40004000,        4, base=16,    bitRange=1-1
 2911                           ;`WDMOD.WDTOF`              0x40004000,        4, base=16,    bitRange=2-2
 2912                           ;`WDMOD.WDINT`              0x40004000,        4, base=16,    bitRange=3-3
 2913                           
 2914                           WDTC                     EQU  0x40004004
 2915                           ;`WDTC.COUNT`               0x40004004,        4, base=16,    bitRange=0-23
 2916                           
 2917                           WDFEED                   EQU  0x40004008
 2918                           
 2919                           WDTV                     EQU  0x4000400C
 2920                           ;`WDTV.COUNT`               0x4000400C,        4, base=16,    bitRange=0-23
 2921                           
 2922                           
 2923                           ;
 2924                           ;               Flash
 2925                           ;
 2926                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2927                           ;     ----                        ----      -------     --------  ----------- --------
 2928                           
 2929                           
 2930                           FLASHCFG                 EQU  0x4003C010
 2931                           ;`FLASHCFG.FLASHTIM`        0x4003C010,        4, base=16,    bitRange=0-1
 2932                           
 2933                           
 2934                           ;
 2935                           ;               Flash signature generation
 2936                           ;
 2937                           ;     Name                        Zone      Address     Bytesize  Displaybase Bitrange
 2938                           ;     ----                        ----      -------     --------  ----------- --------
 2939                           
 2940                           
 2941                           FMSSTART                 EQU  0x4003C020
 2942                           ;`FMSSTART.START`           0x4003C020,        4, base=16,    bitRange=0-16
 2943                           
 2944                           FMSSTOP                  EQU  0x4003C024
 2945                           ;`FMSSTOP.STOP`             0x4003C024,        4, base=16,    bitRange=0-16
 2946                           ;`FMSSTOP.SIG_START`        0x4003C024,        4, base=16,    bitRange=17-17
 2947                           
 2948                           FMSW0                    EQU  0x4003C02C
 2949                           
 2950                           FMSW1                    EQU  0x4003C030
 2951                           
 2952                           FMSW2                    EQU  0x4003C034
 2953                           
 2954                           FMSW3                    EQU  0x4003C038
 2955                           
 2956                           FMSTAT                   EQU  0x4003CFE0
 2957                           ;`FMSTAT.SIG_DONE`          0x4003CFE0,        4, base=16,    bitRange=2-2
 2958                           
 2959                           FMSTATCLR                EQU  0x4003CFE8
 2960                           
 2961                           
 2962                           ;;
 2963                           ;; Group info for SFR Window.
 2964                           ;;
 2965                           ;[SfrGroupInfo]
 2966                           
 2967                           ;group = `NVIC`,`SYSTICKCSR`,`SYSTICKRVR`,`SYSTICKCVR`,`SYSTICKCALVR`,`SETENA0`,`ISER`,`CLRENA0`,`I
                                CER`,`SETPEND0`,`ISPR`,`CLRPEND0`,`ICPR`,`IP0`,`IP1`,`IP2`,`IP3`,`IP4`,`IP5`,`IP6`,`IP7`,`CPUIDBR`,`
                                CPUID`,`ICSR`,`AIRCR`,`SCR`,`CCR`,`SHPR2`,`SHPR3`
 2968                           ;group = `System control block`,`SYSMEMREMAP`,`PRESETCTRL`,`SYSPLLCTRL`,`SYSPLLSTAT`,`SYSOSCCTRL`,`
                                WDTOSCCTRL`,`IRCCTRL`,`SYSRESSTAT`,`SYSPLLCLKSEL`,`SYSPLLCLKUEN`,`MAINCLKSEL`,`MAINCLKUEN`,`SYSAHBCL
                                KDIV`,`SYSAHBCLKCTRL`,`SSP0CLKDIV`,`UARTCLKDIV`,`SSP1CLKDIV`,`WDTCLKSEL`,`WDTCLKUEN`,`WDTCLKDIV`,`CL
                                KOUTCLKSEL`,`CLKOUTUEN`,`CLKOUTDIV`,`PIOPORCAP0`,`PIOPORCAP1`,`BODCTRL`,`SYSTCKCAL`,`NMISRC`,`STARTA
                                PRP0`,`STARTERP0`,`STARTRSRP0CLR`,`STARTSRP0`,`PDSLEEPCFG`,`PDAWAKECFG`,`PDRUNCFG`,`DEVICE_ID`
 2969                           ;group = `PMU`,`PCON`,`GPREG0`,`GPREG1`,`GPREG2`,`GPREG3`,`GPREG4`
 2970                           ;group = `I/O configuration`,`IOCON_PIO2_6`,`IOCON_PIO2_0`,`IOCON_RESET_PIO0_0`,`IOCON_PIO0_1`,`IOC
                                ON_PIO1_8`,`IOCON_PIO0_2`,`IOCON_PIO2_7`,`IOCON_PIO2_8`,`IOCON_PIO2_1`,`IOCON_PIO0_3`,`IOCON_PIO0_4`
                                ,`IOCON_PIO0_5`,`IOCON_PIO1_9`,`IOCON_PIO3_4`,`IOCON_PIO2_4`,`IOCON_PIO2_5`,`IOCON_PIO3_5`,`IOCON_PI
                                O0_6`,`IOCON_PIO0_7`,`IOCON_PIO2_9`,`IOCON_PIO2_10`,`IOCON_PIO2_2`,`IOCON_PIO0_8`,`IOCON_PIO0_9`,`IO
                                CON_SWCLK_PIO0_10`,`IOCON_PIO1_10`,`IOCON_PIO2_11`,`IOCON_R_PIO0_11`,`IOCON_R_PIO1_0`,`IOCON_R_PIO1_
                                1`,`IOCON_R_PIO1_2`,`IOCON_PIO3_0`,`IOCON_PIO3_1`,`IOCON_PIO2_3`,`IOCON_SWDIO_PIO1_3`,`IOCON_PIO1_4`
                                ,`IOCON_PIO1_11`,`IOCON_PIO3_2`,`IOCON_PIO1_5`,`IOCON_PIO1_6`,`IOCON_PIO1_7`,`IOCON_PIO3_3`,`IOCON_S
                                CK_LOC`,`IOCON_DSR_LOC`,`IOCON_DCD_LOC`,`IOCON_RI_LOC`
 2971                           ;group = `CPIO`,`GPIO0DATA`,`GPIO0DATA0`,`GPIO0DATA1`,`GPIO0DATAL`,`GPIO0DIR`,`GPIO0DIR0`,`GPIO0DIR
                                1`,`GPIO0DIRL`,`GPIO0IS`,`GPIO0IS0`,`GPIO0IS1`,`GPIO0ISL`,`GPIO0IBE`,`GPIO0IBE0`,`GPIO0IBE1`,`GPIO0I
                                BEL`,`GPIO0IEV`,`GPIO0IEV0`,`GPIO0IEV1`,`GPIO0IEVL`,`GPIO0IE`,`GPIO0IE0`,`GPIO0IE1`,`GPIO0IEL`,`GPIO
                                0RIS`,`GPIO0RIS0`,`GPIO0RIS1`,`GPIO0RISL`,`GPIO0MIS`,`GPIO0MIS0`,`GPIO0MIS1`,`GPIO0MISL`,`GPIO0IC`,`
                                GPIO1DATA`,`GPIO1DATA0`,`GPIO1DATA1`,`GPIO1DATAL`,`GPIO1DIR`,`GPIO1DIR0`,`GPIO1DIR1`,`GPIO1DIRL`,`GP
                                IO1IS`,`GPIO1IS0`,`GPIO1IS1`,`GPIO1ISL`,`GPIO1IBE`,`GPIO1IBE0`,`GPIO1IBE1`,`GPIO1IBEL`,`GPIO1IEV`,`G
                                PIO1IEV0`,`GPIO1IEV1`,`GPIO1IEVL`,`GPIO1IE`,`GPIO1IE0`,`GPIO1IE1`,`GPIO1IEL`,`GPIO1RIS`,`GPIO1RIS0`,
                                `GPIO1RIS1`,`GPIO1RISL`,`GPIO1MIS`,`GPIO1MIS0`,`GPIO1MIS1`,`GPIO1MISL`,`GPIO1IC`,`GPIO2DATA`,`GPIO2D
                                ATA0`,`GPIO2DATA1`,`GPIO2DATAL`,`GPIO2DIR`,`GPIO2DIR0`,`GPIO2DIR1`,`GPIO2DIRL`,`GPIO2IS`,`GPIO2IS0`,
                                `GPIO2IS1`,`GPIO2ISL`,`GPIO2IBE`,`GPIO2IBE0`,`GPIO2IBE1`,`GPIO2IBEL`,`GPIO2IEV`,`GPIO2IEV0`,`GPIO2IE
                                V1`,`GPIO2IEVL`,`GPIO2IE`,`GPIO2IE0`,`GPIO2IE1`,`GPIO2IEL`,`GPIO2RIS`,`GPIO2RIS0`,`GPIO2RIS1`,`GPIO2
                                RISL`,`GPIO2MIS`,`GPIO2MIS0`,`GPIO2MIS1`,`GPIO2MISL`,`GPIO2IC`,`GPIO3DATA`,`GPIO3DATA0`,`GPIO3DATAL`
                                ,`GPIO3DIR`,`GPIO3DIR0`,`GPIO3DIRL`,`GPIO3IS`,`GPIO3IS0`,`GPIO3ISL`,`GPIO3IBE`,`GPIO3IBE0`,`GPIO3IBE
                                L`,`GPIO3IEV`,`GPIO3IEV0`,`GPIO3IEVL`,`GPIO3IE`,`GPIO3IE0`,`GPIO3IEL`,`GPIO3RIS`,`GPIO3RIS0`,`GPIO3R
                                ISL`,`GPIO3MIS`,`GPIO3MIS0`,`GPIO3MISL`,`GPIO3IC`
 2972                           ;group = `UART`,`U0RBRTHR`,`U0DLL`,`U0RBR`,`U0THR`,`U0IER`,`U0DLM`,`U0FCR`,`U0IIR`,`U0LCR`,`U0MCR`,
                                `U0LSR`,`U0MSR`,`U0SCR`,`U0ACR`,`U0FDR`,`U0TER`,`U0RS485CTRL`,`U0ADRMATCH`,`U0RS485DLY`
 2973                           ;group = `SSP0`,`SSP0CR0`,`SSP0CR1`,`SSP0DR`,`SSP0SR`,`SSP0CPSR`,`SSP0IMSC`,`SSP0RIS`,`SSP0MIS`,`SS
                                P0ICR`
 2974                           ;group = `SSP1`,`SSP1CR0`,`SSP1CR1`,`SSP1DR`,`SSP1SR`,`SSP1CPSR`,`SSP1IMSC`,`SSP1RIS`,`SSP1MIS`,`SS
                                P1ICR`
 2975                           ;group = `I2C`,`I2C0CONSET`,`I2C0STAT`,`I2C0DAT`,`I2C0ADR`,`I2C0SCLH`,`I2C0SCLL`,`I2C0CONCLR`,`I2C0
                                MMCTRL`,`I2C0ADR1`,`I2C0ADR2`,`I2C0ADR3`,`I2C0DATABUFFER`,`I2C0MASK0`,`I2C0MASK1`,`I2C0MASK2`,`I2C0M
                                ASK3`
 2976                           ;group = `CT16B0`,`TMR16B0IR`,`TMR16B0TCR`,`TMR16B0TC`,`TMR16B0PR`,`TMR16B0PC`,`TMR16B0MCR`,`TMR16B
                                0MR0`,`TMR16B0MR1`,`TMR16B0MR2`,`TMR16B0MR3`,`TMR16B0CCR`,`TMR16B0CR0`,`TMR16B0EMR`,`TMR16B0CTCR`,`T
                                MR16B0PWMC`
 2977                           ;group = `CT16B1`,`TMR16B1IR`,`TMR16B1TCR`,`TMR16B1TC`,`TMR16B1PR`,`TMR16B1PC`,`TMR16B1MCR`,`TMR16B
                                1MR0`,`TMR16B1MR1`,`TMR16B1MR2`,`TMR16B1MR3`,`TMR16B1CCR`,`TMR16B1CR0`,`TMR16B1EMR`,`TMR16B1CTCR`,`T
                                MR16B1PWMC`
 2978                           ;group = `CT32B0`,`TMR32B0IR`,`TMR32B0TCR`,`TMR32B0TC`,`TMR32B0PR`,`TMR32B0PC`,`TMR32B0MCR`,`TMR32B
                                0MR0`,`TMR32B0MR1`,`TMR32B0MR2`,`TMR32B0MR3`,`TMR32B0CCR`,`TMR32B0CR0`,`TMR32B0EMR`,`TMR32B0CTCR`,`T
                                MR32B0PWMC`
 2979                           ;group = `CT32B1`,`TMR32B1IR`,`TMR32B1TCR`,`TMR32B1TC`,`TMR32B1PR`,`TMR32B1PC`,`TMR32B1MCR`,`TMR32B
                                1MR0`,`TMR32B1MR1`,`TMR32B1MR2`,`TMR32B1MR3`,`TMR32B1CCR`,`TMR32B1CR0`,`TMR32B1EMR`,`TMR32B1CTCR`,`T
                                MR32B1PWMC`
 2980                           ;group = `A/D Converters`,`AD0CR`,`AD0GDR`,`AD0INTEN`,`AD0DR0`,`AD0DR1`,`AD0DR2`,`AD0DR3`,`AD0DR4`,
                                `AD0DR5`,`AD0DR6`,`AD0DR7`,`AD0STAT`
 2981                           ;group = `Watchdog`,`WDMOD`,`WDTC`,`WDFEED`,`WDTV`
 2982                           ;group = `Flash`,`FLASHCFG`
 2983                           ;group = `Flash signature generation`,`FMSSTART`,`FMSSTOP`,`FMSW0`,`FMSW1`,`FMSW2`,`FMSW3`,`FMSTAT`
                                ,`FMSTATCLR`
 2984                           
 2985                           ;;
 2986                           ;; Interrupt list for SWO interrupt view.
 2987                           ;;
 2988                           ;[InterruptList]
 2989                           ;Interrupt0   = NMI            0x08
 2990                           ;Interrupt1   = HardFault      0x0C
 2991                           ;Interrupt2   = MemManage      0x10
 2992                           ;Interrupt3   = BusFault       0x14
 2993                           ;Interrupt4   = UsageFault     0x18
 2994                           ;Interrupt5   = SVC            0x2C
 2995                           ;Interrupt6   = DebugMon       0x30
 2996                           ;Interrupt7   = PendSV         0x38
 2997                           ;Interrupt8   = SysTick        0x3C
 2998                           ;Interrupt9   = WAKE_UP0       0x40
 2999                           ;Interrupt10  = WAKE_UP1       0x44
 3000                           ;Interrupt11  = WAKE_UP2       0x48
 3001                           ;Interrupt12  = WAKE_UP3       0x4C
 3002                           ;Interrupt13  = WAKE_UP4       0x50
 3003                           ;Interrupt14  = WAKE_UP5       0x54
 3004                           ;Interrupt15  = WAKE_UP6       0x58
 3005                           ;Interrupt16  = WAKE_UP7       0x5C
 3006                           ;Interrupt17  = WAKE_UP8       0x60
 3007                           ;Interrupt18  = WAKE_UP9       0x64
 3008                           ;Interrupt19  = WAKE_UP10      0x68
 3009                           ;Interrupt20  = WAKE_UP11      0x6C
 3010                           ;Interrupt21  = WAKE_UP12      0x70
 3011                           ;Interrupt22  = SSP1           0x78
 3012                           ;Interrupt23  = I2C0           0x7C
 3013                           ;Interrupt24  = CT16B0         0x80
 3014                           ;Interrupt25  = CT16B1         0x84
 3015                           ;Interrupt26  = CT32B0         0x88
 3016                           ;Interrupt27  = CT32B1         0x8C
 3017                           ;Interrupt28  = SSP0           0x90
 3018                           ;Interrupt29  = UART0          0x94
 3019                           ;Interrupt30  = ADC            0xA0
 3020                           ;Interrupt31  = WDT            0xA4
 3021                           ;Interrupt32  = BOD            0xA8
 3022                           ;Interrupt33  = PIO_3          0xB0
 3023                           ;Interrupt34  = PIO_2          0xB4
 3024                           ;Interrupt35  = PIO_1          0xB8
 3025                           ;Interrupt36  = PIO_0          0xBC
    9                           // IAR C:\Program Files\IAR Systems\Embedded Workbench 7.1\arm\inc\NXP
   10                           //------------------------------------------------------------------------------
   11                           $FISH_ARM_CORTEX_M_REGS.h
    1                           // t    r0
    2                           // n    r1
    3                           // w    r2
    4                           // x    r3
    5                           // y    r4
    6                           // i    r5
    7                           // r    r6
    8                           // p    r7
    9                           // r8   lr
   10                           // r9   pc
   11                           // ra   r10
   12                           // rb   r11
   13                           // k    r12
   14                           
   15                           #define t       r0      //                          AX
   16                           #define n       r1      // v4th
   17                           #define w       r2      // v4th NOS DPUSH           DX
   18                           #define x       r3      // Execution
   19                           #define y       r4      //                          BX as scratch (ROT)
   20                           #define i       r5      // IP                       DX:SI
   21                           #define r       r6      // Return Stack Pointer
   22                           #define p       r7      // Parameter Stack Pointer
   23                           //              r8      // Link register
   24                           //              r9      // Program Counter
   25                           //      ARMv6 Cortex M0 LPC 1114 is 16 bit thumb ISA.
   26                           //      Use of the following registers limited to local variables mostly
   27                           #define ra      r10     // 
   28                           #define rb      r11     // 
   29                           #define k       r12     // 
   12                           $FISH_NXP_M0_MACROS.h
    1                           
    2                           //ss    SET     1       // "single-step" switch for debug/shakedown testing
    3                           //#define ss
    4                           
    5                           //------------------------------------------------------------------------------
    6                           //      Inner Interpreter Macros
    7                           //      Beauty is you can put any ISA in a macro and no prob till referenced!
    8                           
    9                           // IF   ss
   10                           #ifdef ss
   18                           #else
   19                           NEXT1   MACRO   
   20                                   LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
   21                                   BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
   22                                   ENDM
   23                           #endif
   24                           // ENDIF
   25                           
   26                           NEXT    MACRO   
   27                                   LDM     i!, {w} // get cfa addr to w, incr i after
   28                                   NEXT1
   29                                   ENDM
   30                           
   31                           TPUSH   MACRO   
   32                                   PUSHt   // push t to p, pre decrement p
   33                                   NEXT
   34                                   ENDM
   35                           
   36                           DPUSH   MACRO   
   37                                   PUSHw   // push w to p, pre decrement p
   38                                   TPUSH
   39                                   ENDM
   40                           
   41                           //------------------------------------------------------------------------------
   42                           //      FISH STACK MACRO's
   43                           //      Beauty is you can put any ISA in a macro and no prob till referenced!
   44                           //      Cortex M0 THUMB only does STMia and LDMia
   45                           //      I (rstack value to pstack) expects POP to be post increment
   46                           //      Meaning that TOS is = to current p or r
   47                           //      Therefore PUSH is pre decrement
   48                           
   49                           PUSHt   MACRO
   50                                   SUBS    p, p, #4        // push t to p, pre decrement p
   51                                   STR     t, [p]
   52                                   ENDM
   53                           
   54                           POP2t   MACRO
   55                           #ifndef TOSCT
   56                                   LDR     t, [p]          // pop tos to t, post increment p
   57                           #endif
   58                                   ADDS    p, p, #4
   59                                   ENDM
   60                           
   61                           NDPOP2t MACRO                   // macro = copy tos to t, leave it on the stack
   62                                   LDR     t, [p]
   63                                   ENDM
   64                           
   65                           PUSHn   MACRO
   66                                   SUBS    p, p, #4        // push n to p, pre decrement p
   67                                   STR     n, [p]
   68                                   ENDM
   69                           
   70                           POP2n   MACRO
   71                                   LDR     n, [p]
   72                                   ADDS    p, p, #4
   73                                   ENDM
   74                           
   75                           PUSHw   MACRO
   76                                   SUBS    p, p, #4        //  push w to p, pre decrement p
   77                                   STR     w, [p]
   78                                   ENDM
   79                           
   80                           POP2w   MACRO
   81                                   LDR     w, [p]
   82                                   ADDS    p, p, #4
   83                                   ENDM
   84                           
   85                           NDPOP2w MACRO                   // macro = copy tos to w, leave it on the stack
   86                                   LDR     w, [p]
   87                                   ENDM
   88                           
   89                           PUSHx   MACRO
   90                                   SUBS    p, p, #4        //  push x to p, pre decrement p
   91                                   STR     x, [p]
   92                                   ENDM
   93                           
   94                           POP2x   MACRO
   95                                   LDR     x, [p]
   96                                   ADDS    p, p, #4
   97                                   ENDM
   98                           
   99                           NDPOP2x MACRO                   // macro = copy tos to w, leave it on the stack
  100                                   LDR     x, [p]
  101                                   ENDM
  102                           
  103                           PUSHi   MACRO
  104                                   SUBS    p, p, #4        // push i to p, pore increment p
  105                                   STR     i, [p]
  106                                   ENDM
  107                           
  108                           POP2i   MACRO
  109                                   LDR     i, [p]
  110                                   ADDS    p, p, #4
  111                                   ENDM
  112                           
  113                           PUSHt2r MACRO
  114                                   SUBS    r, r, #4        //  push t to r, pre decrement r
  115                                   STR     t, [r]
  116                                   ENDM
  117                           
  118                           PUSHi2r MACRO
  119                                   SUBS    r, r, #4        //  push i to r, pre decrement r
  120                                   STR     i, [r]
  121                                   ENDM
  122                           
  123                           POPr2i  MACRO
  124                                   LDR i, [r]              //  pop r to i, post increment r
  125                                   ADDS    r, r, #4
  126                                   ENDM
  127                           
  128                           //POP2p MACRO
  129                           //      ENDM
  130                           //POP2PC        MACRO 
  131                           //      ENDM
  132                           
  133                           POPr2t  MACRO 
  134                                   LDR     t, [r]
  135                                   ADDS    r, r, #4
  136                                   ENDM
  137                           
  138                           PUSHn2r MACRO
  139                                   SUBS    r, r, #4        //  push t to r, pre decrement r
  140                                   STR     n, [r]
  141                                   ENDM
  142                           
  143                           PUSHw2r MACRO
  144                                   SUBS    r, r, #4        //  push w to r, pre decrement r
  145                                   STR     w, [r]
  146                                   ENDM
  147                           
  148                           LIT2t   MACRO
  149                                   // as in xeq token at ToS setup for lit
  150                                   LDM     i!, {t} // fetch memory p points to into {t}, inc i
  151                                   ENDM
  152                           
  153                           POPp2w  MACRO
  154                                   // as in xeq token at ToS setup for exec
  155                                   LDM     p!, {w} // fetch memory p points to into {w}, inc p
  156                                   ENDM
  157                           
   13                           //------------------------------------------------------------------------------
   14                           // #defines for XON, -1 TRUE, IO2TP, etc.
   15                           // COPY OF Assembler Preproccesor Defined Symbols for each configuration
   16                           $FISH_RM_CONFIG_#DEFINES.h
    1                           // FISH #defines for system wide control
    2                           // this define must keep RESET!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    3                           //#define USE_CMAIN     // Affects cstartup_M.c FM0_COLD and RET2c
    4                           #define FISH_STM32F4_Peripheral_Register_ADDRS
    5                           #define TRUE_EQU_NEG_ONE
    6                           #define XON_XOFF        // Use XON_XOFF Flow Control
    7                           #define ABORT_STOP_TILL_CO
    8                           #define EOL_DLE         // DLE 0x10/16d in QUIT after last line interpreted
    9                           #define EOL_NAK         // NAK in error messages for STDLED editor highlight
   10                           //#define DEFAULT_BAUD_TEST
   11                           //#define CTS_RTS       // Use Hardware Flow Control
   12                           //#define IO2TP         // for ports before i/o done - enable PADCLR and TIBCLR
   13                           //#define TOSCT         // TOS Cache Testing QUERY BACKSPACING OVER INPUT!!!
   14                           //#define SLOW_POWERUP  // For slow power supply
   15                           //#define CLKOUT        // PIO0_1 is CLKOUT
   16                           //#define TESTRAM       // run flogram at start-up
   17                           //#define DEBUG_FLASH   // 
   18                           
   19                           //#define IOBUFS_DEBUG
   20                           //IOBUFS_DEBUG #define:
   21                           //NOOP & .SH IN EXPECT AFTER LEAVE 
   22                           //TIB DUMP OF EXPECT IN QUERY
   23                           //HERE DUMP IN INTERPRET'S DFIND
   24                           //WORD PARSES USING SPACE - DOES SPACE AFTER? 
   25                           
   26                           // VTOR_PATCH defined in 205 ASM PREPROC CONFIG - UNTIL 205 VTOR issue RESOLVED.
   27                           
   28                           // COPY OF ALL CONFIGURATION Assembly Preprocessor sections.
   29                           
   30                           /* ALL CONFIGURATIONS:
   31                           Assembly Preprocessor Additional Include Directories:
   32                           $PROJ_DIR$\..\FISH_RM_COMMON
   33                           $PROJ_DIR$\..\FISH_RM_COMMON_CODE_CORTEX_M
   34                           */
   35                           
   36                           /*
   37                           STM32F205RC-STM118mhg Configuration Assembly Preprocessor Section:
   38                           Assembly Preprocessor Defined Symbols:
   39                           FISH_PubRel_WORDSET
   40                           FISH_Debug_WORDSET
   41                           VTOR_PATCH
   42                           STM32F205RC
   43                           STM32F205RC_SRAM128
   44                           STM32F205RC_XRC10_118MHZ
   45                           */
   46                           /*
   47                           STM32F4_PubRel Configuration Assembly Preprocessor Section:
   48                           Assembly Preprocessor Defined Symbols:
   49                           FISH_PubRel_WORDSET
   50                           STM32F4_XRC08_168MHZ
   51                           */
   52                           /*
   53                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   54                           Assembly Preprocessor Defined Symbols:
   55                           FISH_PubRel_WORDSET
   56                           FISH_Debug_WORDSET
   57                           STM32F4_XRC08_168MHZ
   58                           */
   59                           /*
   60                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   61                           Assembly Preprocessor Additional Include Directories:
   62                           
   63                           Assembly Preprocessor Defined Symbols:
   64                           */
   65                           /*
   66                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   67                           Assembly Preprocessor Additional Include Directories:
   68                           
   69                           Assembly Preprocessor Defined Symbols:
   70                           */
   71                           /*
   72                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   73                           Assembly Preprocessor Additional Include Directories:
   74                           
   75                           Assembly Preprocessor Defined Symbols:
   76                           */
   77                           /*
   78                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   79                           Assembly Preprocessor Additional Include Directories:
   80                           
   81                           Assembly Preprocessor Defined Symbols:
   82                           */
   83                           /*
   84                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   85                           Assembly Preprocessor Additional Include Directories:
   86                           
   87                           Assembly Preprocessor Defined Symbols:
   88                           */
   89                           /*
   90                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   91                           Assembly Preprocessor Additional Include Directories:
   92                           
   93                           Assembly Preprocessor Defined Symbols:
   94                           */
   95                           /*
   96                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
   97                           Assembly Preprocessor Additional Include Directories:
   98                           
   99                           Assembly Preprocessor Defined Symbols:
  100                           */
  101                           /*
  102                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  103                           Assembly Preprocessor Additional Include Directories:
  104                           
  105                           Assembly Preprocessor Defined Symbols:
  106                           */
  107                           /*
  108                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  109                           Assembly Preprocessor Additional Include Directories:
  110                           
  111                           Assembly Preprocessor Defined Symbols:
  112                           */
  113                           /*
  114                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  115                           Assembly Preprocessor Additional Include Directories:
  116                           
  117                           Assembly Preprocessor Defined Symbols:
  118                           */
  119                           /*
  120                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  121                           Assembly Preprocessor Additional Include Directories:
  122                           
  123                           Assembly Preprocessor Defined Symbols:
  124                           */
  125                           /*
  126                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  127                           Assembly Preprocessor Additional Include Directories:
  128                           
  129                           Assembly Preprocessor Defined Symbols:
  130                           */
  131                           /*
  132                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  133                           Assembly Preprocessor Additional Include Directories:
  134                           
  135                           Assembly Preprocessor Defined Symbols:
  136                           */
  137                           /*
  138                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  139                           Assembly Preprocessor Additional Include Directories:
  140                           
  141                           Assembly Preprocessor Defined Symbols:
  142                           */
  143                           /*
  144                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  145                           Assembly Preprocessor Additional Include Directories:
  146                           
  147                           Assembly Preprocessor Defined Symbols:
  148                           */
  149                           /*
  150                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  151                           Assembly Preprocessor Additional Include Directories:
  152                           
  153                           Assembly Preprocessor Defined Symbols:
  154                           */
  155                           /*
  156                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  157                           Assembly Preprocessor Additional Include Directories:
  158                           
  159                           Assembly Preprocessor Defined Symbols:
  160                           */
  161                           /*
  162                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  163                           Assembly Preprocessor Additional Include Directories:
  164                           
  165                           Assembly Preprocessor Defined Symbols:
  166                           */
  167                           /*
  168                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  169                           Assembly Preprocessor Additional Include Directories:
  170                           
  171                           Assembly Preprocessor Defined Symbols:
  172                           */
  173                           /*
  174                           STM32F4_DEBUG Configuration Assembly Preprocessor Section:
  175                           Assembly Preprocessor Additional Include Directories:
  176                           
  177                           Assembly Preprocessor Defined Symbols:
  178                           */
   17                           //------------------------------------------------------------------------------
   18                           // NXP M0 FLASH, RAM, CLOCK Configurations:
   19                           // Placed in each configurations ( Debug, etc )'s
   20                           $FISH_M0_EQUATES.h // #defines of FISH_M0_CONFIG_DEFINES.s
    1                           // FISH NXP M0/M1+ VARIANTS FOR THIS SOURCE
    2                           // #def are placed in the Assembler Preproccesor Defined Symbols section.
    3                           // EQUATES are for REAL VALUES used in FISH assembly code
    4                           #ifdef NXP_M0_11xx_XRC10_50MHZ
    6                           #endif
    7                           #ifdef NXP_M0_11xx_IRC12_48MHZ
    8                           SYSTEMCLOCK     EQU     48000000        // Use 12mhz IRC for 48mhz
    9                           #endif
   10                           #ifdef NXP_M0_81x_IRC12_12MHZ
   12                           #endif
   13                           #ifdef NXP_M0_81x_IRC12_24MHZ
   15                           #endif
   16                           
   17                           //---------------------------------NXP M0/M1+ Flash Equates --------------------------------
   18                           // Starting and Last Page cannot equal FLASH_PPAGE - which may be reserved and fault if read
   19                           // FLASH_UPAGE1 = 0 = NO FLASH AVAILABLE
   20                           
   21                           // This section for NXP M0 1115 64k Flash parts
   22                           #ifdef NXP_M0_064kFlash_4KWrite
   28                           #endif  // NXP_M0_064kFlash_4KWrite
   29                           
   30                           // This section for NXP M0 1114 32k Flash parts
   31                           #ifdef NXP_M0_032kFlash_4KWrite
   32                           FLASH_WR_SIZE   EQU     0x1000          // Smallest writeable page size
   33                           FLASH_SPAGE     EQU     0x4000          // Start of Free Flash Page(s)
   34                           FLASH_LPAGE     EQU     0x7000          // Last Page for user FLASH storage
   35                           // FOR LOOP CONTROL AND BOUNDS CHECKING
   36                           FLASH_PPAGE     EQU     0x8000          // Past Last Page
   37                           #endif  // NXP_M0_032kFlash_4KWrite
   38                           
   39                           // This section for NXP M1 812 16k Flash parts
   40                           #ifdef NXP_M0_016kFlash_1KWrite
   42                           #ifndef SRM
   44                           #else
   48                           #endif  // SRM
   52                           #endif  // NXP_M0_016kFlash_1KWrite
   53                           
   54                           // Various RAM sizes set here
   55                           // This is universal in NXP, Cortex M0/M1+'s !?!
   56                           RAM_START       EQU     0x10000000
   57                           
   58                           #ifdef NXP_M0_004kRam
   59                           RAM_END         EQU     0x10001000      // LPC1114FD/102 32k/4k STP ATEAM BOARD
   60                           #endif
   61                           #ifdef NXP_M0_008kRam                   // STP NXP 32k/8k, 64k/8k and LPCxpresso Boards:
   63                           #endif
   64                           
   65                           DEFAULT_BAUD    EQU     9600            // 9600 until UART0_INIT USED
   66                           DEFAULT_BASE    EQU     10              // BASE at powerup
   67                           XON_CHAR        EQU     17              // ASCII DECIMAL XON_CHAR
   68                           XOFF_CHAR       EQU     19              // ASCII DECIMAL XOFF_CHAR
   69                           IOBUFSIZE       EQU     96              // For Tib and Pad
   70                           MAXWORDLEN      EQU     31              // magic!!! for ID. <<<<<<<<<<<<<<<<<<<<
   71                           
   72                           // RESERVE SPACE FOR IAP PROGRAMMING execution and STACK:
   73                           /* UM10398 LPC111x/LPC11Cxx User manual
   74                           26.4.7 Interrupts during IAP
   75                           The on-chip flash memory is not accessible during erase/write operations. When the user 
   76                           application code starts executing the interrupt vectors from the user flash area are active.
                                 
   77                           Before making any IAP call, either disable the interrupts or ensure that the user interrupt
                                 
   78                           vectors are active in RAM and that the interrupt handlers reside in RAM. The IAP code 
   79                           does not use or disable interrupts.
   80                           26.4.8 RAM used by ISP command handler
   81                           ISP commands use on-chip RAM from 0x1000 017C to 0x1000 025B. The user could use 
   82                           this area, but the contents may be lost upon reset. Flash programming commands use the 
   83                           top 32 bytes of on-chip RAM. The stack is located at (RAM top - 32). The maximum stack 
   84                           usage is 256 bytes and it grows downwards.
   85                           26.4.9 RAM used by IAP command handler
   86                           Flash programming commands use the top 32bytes of on-chip RAM. The maximum stack 
   87                           usage in the user allocated stack space is 128 bytes and it grows downwards.
   88                           */
   89                           
   90                           // So (RAM top - 32) + 256 byte stack needs to be provided!
   91                           // By section IAP-ISP_Reserved in memap and .icf (The 32 bytes)
   92                           // - Verify SP? (is it sp or cstack?) has 256 bytes available
   93                           
   94                           // IAR PROJECT->LINKER->COMFIG->EDIT->MEMORY REGIONS->RAM->END<<<<<<<<<<<<<<<<<<
   95                           // RESERVE SPACE FOR CSTACK
   96                           // IAR PROJECT->LINKER->COMFIG->EDIT->STACK/HEAP SIZES<<<<<<<<<<<<<<<<<<<<<<<<<<
   97                           // FISH SETS THESE VALUES TO 0x40
   98                           IAPCALL         EQU     0x1FFF1FF1      // Call Address of IAP routine
   99                           /*
  100                           #ifdef NXP_M0_004kRam
  101                           BOTTOM_IAPSTACK EQU     0x10000FE0      // 0x10000FE0 VALUES SET BY FISH
  102                           TOP_IAPSTACK    EQU     BOTTOM_IAPSTACK+32
  103                           #endif
  104                           #ifdef NXP_M0_008kRam
  105                           BOTTOM_IAPSTACK EQU     0x10001FE0      // 0x10000FE0 VALUES SET BY FISH
  106                           TOP_IAPSTACK    EQU     BOTTOM_IAPSTACK+32
  107                           #endif
  108                           */
  109                           STACKSIZE       EQU     32*4            // SHOOULD BE GOOD - 120 BYTES 0x78
  110                           
  111                           //------------------------------------------------------------------------------
  112                           // RESERVE SPACE AFTER .bss FOR FISH STACKS, AND UNINITIALIZED RAM
  113                           
  114                           PINIT   EQU     (RAM_END-16)           // FISH PARAMETER STACK in register p
  115                           RINIT   EQU     (PINIT - STACKSIZE)     // FISH RETURN STACK in register r
  116                           BOTTOM_RSTACK   EQU     (RINIT - STACKSIZE)     // FISH END OF RETURN STACK ADDR
  117                           
  118                           // Uninitialized RAM is between CSTACK$$Limit and RINIT-(size)
  119                           // RECALCULATE IF ANY NEW _SV'S ADDED OR STACKSIZE CHANGED<<<<<<<<<<<<<<<<<<<<<<
  120                           // CSTACK AND HEAP IF ALLOCATED FOLLOWS .bss ( FOLLOWING FROM SYM FILE )
  121                           
  122                           // 10000c78 B CSTACK$$Limit
  123                           // 10000c80 a UNINITRAMBASE
  124                           // 10000edc a UNINITRAMEND 592 BYTES
  125                           // 10000ee0 a BOTTOM_RSTACK
  126                           #ifdef NXP_M0_004kRam
  127                           ALL_UNINITRAM_START     EQU     0x10000D40      // ROUND UP CSTACK$$Limit
  128                           // USED FOR SAVING BAUDRATE BETWEEN RESETS AND HARD FAULT RESETS
  129                           #define DBAUD   ALL_UNINITRAM_START     // .bss zeroing out one word past WARNING
  130                           #define UBAUD   ALL_UNINITRAM_START+4
  131                           // Define space for user use of this resource - After DBAUD and UBAUD so far!
  132                           ALL_UNINITRAM_FREE_START        EQU     ALL_UNINITRAM_START+8
  133                           ALL_UNINITRAM_END               EQU     BOTTOM_RSTACK-4         // UNINT TO HERE
  134                           #endif  // NXP_M0_004kRam
  135                           
  136                           #ifdef NXP_M0_008kRam
  139                           #define DBAUD   ALL_UNINITRAM_START     // .bss zeroing out one word past WARNING
  140                           #define UBAUD   ALL_UNINITRAM_START+4
  144                           #endif  // NXP_M0_008kRam
  145                           
  146                           DBAUDADDR       EQU     DBAUD
  147                           UBAUDADDR       EQU     UBAUD
   21                           //$FISH_M0_MEMMAP.s  // SYSTEM AND USER MEMORY MAPPING
   22                           //------------------------------------------------------------------------------
   23                           // Place (select?) :NONAME's before dynamic content to make CFA addresses static.
   24                           $FISH_NXP_M0_SLIB.s
    1                           // Created FISH_NXP_M0_SLIB.s
    2                           // - To place :NONAME's before dynamic content to make their CFA addresses static.
    3                           
    4                           //------------------------------------------------------------------------------
    5                           // SECTION HEADER TO ALIGN ALL HI LEVEL CODE - ASM SECTION AT END DIFFERS!
    6                            SECTION .text : CONST (2)
    7                            ALIGNROM 2,0xFFFFFFFF
    8                           //------------------------------------------------------------------------------
    9                           //:NONAME BELL:       ( -- ) Emit BELL char.
   10                           BELL:
   11    00000000 .............         DC32    DOCOL, LIT, 0x07, EMIT, SEMIS
                  ...07000000..
                  .............
                  .            
   12                           
   13                           //:NONAME EIGHT:      ( -- n )
   14                           //= :NONAME BACKSPACE_CHAR:  ( -- n ) 
   15                           EIGHT:
   16                           BACKSPACE_CHAR:
   17    00000014 ........08000         DC32    DOCON, 8
                  000          
   18                           
   19                           //:NONAME BSOUT:      ( -- ) Emit BACKSPACE char erasing it and maintain OUT.
   20                           BSOUT:
   21    0000001C ........              DC32    DOCOL
   22    00000020 .............         DC32    BACKSPACE_CHAR, EMIT
                  ...          
   23    00000028 ........              DC32    SPACE
   24    0000002C .............         DC32    BACKSPACE_CHAR, EMIT
                  ...          
   25    00000034 ........FDFFF         DC32    LIT, -3, OUT_SV, PSTORE // Keep OUT in synch
                  FFF..........
                  ......       
   26    00000044 ........              DC32    SEMIS
   27                           
   28                           //------------------------------------------------------------------------------
   29                           #ifndef SRM
   30                           //:NONAME DOTSBASE:   ( n -- ) Pass n as base to .S
   31                           DOTSBASE:
   32    00000048 ........              DC32    DOCOL
   33    0000004C ........              DC32    BASE_TO_R12     // Save current BASE
   34    00000050 .............         DC32    BASE_SV, STORE, DOTS
                  ...........  
   35    0000005C ........              DC32    BASE_FROM_R12   // Restore BASE
   36    00000060 ........              DC32    SEMIS
   37                           
   38                           //:NONAME PRINT_SUFFIX ( -- ) Print char representing BASE ( b d or h )
   39                           PRINT_SUFFIX:
   40    00000064 ........              DC32    DOCOL
   41    00000068 .............         DC32    BASE_SV, AT, DUP
                  ...........  
   42    00000074 .............         DC32    TWO, EQUAL
                  ...          
   43    0000007C ........              DC32    ZBRAN
   44    00000080 18000000              DC32     DEC_OR_HEX-.
   45                           
   46                           IS_BIN:        
   47    00000084 ........62000         DC32    LIT, 'b', EMIT, DROP
                  000..........
                  ......       
   48    00000094 ........              DC32    SEMIS
   49                                   
   50                           DEC_OR_HEX:
   51    00000098 ........0A000         DC32    LIT, 10, EQUAL
                  000........  
   52    000000A4 ........              DC32    ZBRAN
   53    000000A8 14000000              DC32     IS_HEX-.
   54                           
   55                           IS_DECIMAL:
   56    000000AC ........64000         DC32    LIT, 'd', EMIT
                  000........  
   57    000000B8 ........              DC32    SEMIS
   58                           
   59                           IS_HEX:
   60    000000BC ........68000         DC32    LIT, 'h', EMIT
                  000........  
   61    000000C8 ........              DC32    SEMIS
   62                           
   63                           //#ifndef SRM
   64                           //:NONAME DOT_BASE_SUFFIX: ( n -- ) DOT with BASE suffix appended.
   65                           // USED in . .D and .SD
   66                            SECTION .text : CONST (2)
   67                           DOT_BASE_SUFFIX:
   68    00000000 ........              DC32    DOCOL
   69    00000004 ........              DC32    STOD            // Extend sign
   70    00000008 ........              DC32    ZERO            // and no padding
   71    0000000C ........              DC32    DDOTR           // in call to D.R
   72    00000010 ........              DC32    PRINT_SUFFIX    // Read BASE and print suffix
   73    00000014 ........              DC32    SEMIS
   74                           
   75                           //:NONAME UDOT_BASE_SUFFIX: ( n -- ) UDOT with BASE suffix appended.
   76                           // USED in .B .H .SB AND .SH
   77                           UDOT_BASE_SUFFIX:
   78    00000018 ........              DC32    DOCOL
   79    0000001C .............         DC32    ZERO, ZERO      // No sign and no padding
                  ...          
   80    00000024 ........              DC32    DDOTR           // in call to D.R
   81    00000028 ........              DC32    PRINT_SUFFIX    // Read BASE and print suffix
   82    0000002C ........              DC32    SEMIS
   83                           
   84                           //:NONAME DOTBASE:   ( n n -- ) Use TOP n as temporary BASE to output with.
   85                           //       Save current BASE and use n as BASE for this DOT or U.
   86                           //       Used by .B .D and .H
   87                           DOTBASE:
   88    00000030 ........              DC32    DOCOL
   89    00000034 ........              DC32    BASE_TO_R12     // Save current BASE
   90    00000038 .............         DC32    DUP, BASE_SV, STORE     // Save and set BASE to use
                  ...........  
   91                           // IF THIS IS ELIMINATED AND UDOT ONLY USED -1 .D IS 42432762367
   92    00000044 ........0A000         DC32    LIT, 10, EQUAL  // Use saved BASE for DECIMAL case
                  000........  
   93    00000050 ........              DC32    ZBRAN           // Fall thru for DECIMAL Case
   94    00000054 10000000              DC32    DBUSEDUDOT-.    // Else handle BIN and HEX as unsigned.
   95                           
   96    00000058 ........              DC32    DOT_BASE_SUFFIX
   97                           
   98    0000005C ........              DC32    BRAN
   99    00000060 08000000              DC32    DBASEDONE-.     // Finish with space and reestoration of BASE.
  100                           
  101                           DBUSEDUDOT:
  102    00000064 ........              DC32    UDOT_BASE_SUFFIX
  103                           
  104                           DBASEDONE:
  105    00000068 ........              DC32    SPACE           // Provide normal . formatting
  106    0000006C ........              DC32    BASE_FROM_R12   // Restore BASE
  107    00000070 ........              DC32    SEMIS
  108                           #endif  // not SRM
  109                           //------------------------------------------------------------------------------
  110                           
  111                           //:NONAME INITSO_SV:    ( -- addr of INITSO )
  112                           //      A system variable that contains the initial value for the stack pointer.
  113                           //      Pronounced S-zero. See SP!
  114                           INITSO_SV:
  115    00000074 .............         DC32    DOCON, INITSO
                  ...          
  116                           
  117                           //:NONAME INITRO_SV:    ( -- addr of INITRO )
  118                           //      A system variable containing the initial location of the return stack.
  119                           //      Pronounced R-zero. See RP!
  120                           INITRO_SV:
  121    0000007C .............         DC32    DOCON, INITRO
                  ...          
  122                           
  123                           
  124                           //:NONAME CSP_SV:       ( -- addr of CSP ) Stack address save for compile error checking
  125                           //       A system variable temporarily storing the stack pointer position, for
  126                           //       compilation error checking.
  127                           CSP_SV:
  128    00000084 .............         DC32    DOCON, CSP
                  ...          
  129                           
  130                           //:NONAME HLD_SV:       ( -- addr of NHLD ) Holds address of numeric output conversion
  131                           //      A system variable that holds the address of the latest character of
  132                           //      text during numeric output conversion. Usually pad relative.
  133                           HLD_SV:
  134    0000008C .............         DC32    DOCON, NHLD
                  ...          
  135                           
  136                           //:NONAME DICTFULL_ABORT ( -- ) Issue Dictionary Full Message and ABORT
  137                           DICTFULL_ABORT:
  138    00000094 ........              DC32    DOCOL
  139    00000098 .............         DC32    LIT, msg_dictfull
                  ...          
  140    000000A0 .............         DC32    NULLSTRLEN, TYPE
                  ...          
  141    000000A8 ........              DC32    ABORT
  142                           
  143                           //:NONAME ALLOT_PRIM: ( un -- ) ALLOT WITHOUT DICTIONARY CHECK
  144                           ALLOT_PRIM:
  145    000000AC ........              DC32    DOCOL
  146    000000B0 ........              DC32    DP_SV
  147    000000B4 ........              DC32    PSTORE
  148    000000B8 ........              DC32    SEMIS
  149                           
  150                           //:NONAME COMMA_PRIM ( CFA -- ) COMMA WITHOUT DICTSPACE TEST
  151                           COMMA_PRIM:
  152    000000BC ........              DC32    DOCOL
  153    000000C0 ........              DC32    ALIGN32_FF_PAD  // ASM CANDIDATE
  154    000000C4 ........              DC32    HERE            // is NEW DP
  155    000000C8 ........              DC32    STORE           // CFA
  156    000000CC ........              DC32    FOUR
  157    000000D0 ........              DC32    ALLOT_PRIM      // ALLOT W/O DICTSPACE CHECK
  158    000000D4 ........              DC32    SEMIS
  159                           
  160                           //:NONAME QCOMP: ( -- ) Issue error message if not compiling.
  161                           QCOMP:
  162    000000D8 ........              DC32    DOCOL
  163    000000DC ........              DC32    STATE_SV
  164    000000E0 ........              DC32    AT
  165    000000E4 ........              DC32    ZEQU
  166    000000E8 .............         DC32    LIT, msg_qcomp
                  ...          
  167    000000F0 ........              DC32    QERROR    // ( f nullstr-addr -- )
  168    000000F4 ........              DC32    SEMIS
  169                           
  170                           //:NONAME QEXEC:        ( -- ) Issue error message if not executing.
  171                           QEXEC:
  172    000000F8 ........              DC32    DOCOL
  173    000000FC ........              DC32    STATE_SV
  174    00000100 ........              DC32    AT
  175    00000104 .............         DC32    LIT, msg_qexec
                  ...          
  176    0000010C ........              DC32    QERROR    // ( f nullstr-addr -- )
  177    00000110 ........              DC32    SEMIS
  178                           
  179                           //:NONAME QPAIR:        ( n1 n2 -- ) Issue an error message if n1 does not equal n2.
  180                           //      The message indicates that compiled conditionals do not match.
  181                           QPAIR:
  182    00000114 ........              DC32    DOCOL
  183    00000118 ........              DC32    SUBB
  184    0000011C .............         DC32    LIT, msg_qpair
                  ...          
  185    00000124 ........              DC32    QERROR    // ( f nullstr-addr -- )
  186    00000128 ........              DC32    SEMIS
  187                           
  188                           //:NONAME QSTACK:       ( -- ) If Stack Error type error message then Abort.
  189                           //      Issue an error message if the stack is out of bounds. This
  190                           //      definition may be installation dependent.
  191                           QSTACK:
  192    0000012C ........              DC32    DOCOL
  193    00000130 ........              DC32    SPAT
  194    00000134 ........              DC32    INITSO_SV
  195    00000138 ........              DC32    AT
  196    0000013C ........              DC32    SWAP
  197    00000140 ........              DC32    ULESSTHAN       // U< ( 2 1 -- 0 ) ( 1 2 -- 1 )
  198    00000144 .............         DC32    LIT, msg_qstack
                  ...          
  199    0000014C ........              DC32    QERROR    // ( f nullstr-addr -- )
  200    00000150 ........              DC32    SEMIS
  201                           
  202                           //:NONAME PDOTQ:        ( -- ) DOTQ run-time
  203                           //      The run-time proceedure, compiled by ." which transmits the
  204                           //      following in-line text to the selected output device. See ."
  205                           //      USE SINGLE QUOTES in SOURCE USAGE!!!!
  206                           PDOTQ:
  207    00000154 ........              DC32    DOCOL
  208    00000158 ........              DC32    RFROM                           // Addr of string = aofstr
  209    0000015C .............         DC32    DUP, COUNT, TYPE
                  ...........  
  210    00000168 .............         DC32    COUNT, PLUS
                  ...          
  211    00000170 ........              DC32    ALIGNED
  212    00000174 ........              DC32    TOR
  213    00000178 ........              DC32    SEMIS
  214                           
  215                           //:NONAME QUERY:        ( -- ) Use Expect to fill TIB
  216                           //      Input characters into TIB as a NULL terminated string using EXPECT.
  217                           //      TIB is filled until CR/EMTER or count argument to EXPECT is reached.
  218                           //      IN is set to zero and the string in TIB is NULL terminated. 
  219                           QUERY:
  220    0000017C ........              DC32    DOCOL
  221    00000180 ........              DC32    TIB_SV               // LIT, TIB-1      //TIB_SV
  222    00000184 ........5E000         DC32    LIT, IOBUFSIZE-2        // 96-2=94
                  000          
  223    0000018C ........              DC32    EXPECT          // expect = counted null terminated string now.
  224    00000190 ........01000         DC32    STRVA, 1, IN    // so skip count byte
                  000........  
  225                           #ifdef  IOBUFS_DEBUG        
  227                           #endif        
  228    0000019C ........              DC32    SEMIS
  229                           
  230                           //:NONAME PNUMBER:      ( 0 0 addr1 -- d addr2 )
  231                           //                      ( 0 0 addr1 -- LSW MSW addr2=addr1+chars )
  232                           //      Convert the ascii text beginning at addr1+l
  233                           //      with regard to BASE into a 64 bIt unsigned number d.
  234                           //      Addr2 is the address of the first unconvertable digit, usually space
  235                           //      or NULL.
  236                           //      Used by NUMBER.
  237                           PNUMBER:
  238    000001A0 ........              DC32    DOCOL
  239                           PNUM1:                          // Begin
  240    000001A4 ........              DC32    ONEP            // ( LSW MSW addr+1 -- )
  241    000001A8 .............         DC32    DUP, TOR        // ( LSW MSW  addr+1 -- ) copy of addr+1 >r
                  ...          
  242    000001B0 ........              DC32    CAT             // ( LSW MSW c -- )
  243    000001B4 .............         DC32    BASE_SV, AT     // ( LSW MSW c base -- )
                  ...          
  244    000001BC ........              DC32    DIGIT           // ( LSW MSW c base -- 0 0 digit 1 (ok)
  245                                                          // | ( 0 0 0 (bad))
  246                           // digit gets 0, 0x20 or 0x2E and returns 0 then branches to fromr semis...
  247    000001C0 ........              DC32    ZBRAN           //
  248    000001C4 58000000              DC32     PNUM2-.        // If digit retuned 0 branch, else fall thru
  249                           
  250    000001C8 ........              DC32    SWAP            // ( LSW MSW digit -- )
  251    000001CC .............         DC32    BASE_SV, AT     // ( LSW digit MSW base -- )
                  ...          
  252                           //      U* (un un --  ud=<LSW MSW> )
  253    000001D4 ........              DC32   USTAR            // ( LSW digit LSW MSW  -- )
  254    000001D8 ........              DC32    DROP
  255    000001DC ........              DC32    ROT
  256    000001E0 .............         DC32    BASE_SV, AT     // ( base*accn bn base -- )
                  ...          
  257    000001E8 ........              DC32    USTAR           // ( base*accn bn*base --   )
  258    000001EC ........              DC32    DPLUS           // ( base*accn+bn*base --   )
  259    000001F0 .............         DC32    DPL_SV, AT, ONEP
                  ...........  
  260    000001FC ........              DC32    ZBRAN           // IF true
  261    00000200 10000000              DC32    PNUM3-.         // else do
  262                           
  263    00000204 .............         DC32    ONE, DPL_SV, PSTORE
                  ...........  
  264                           
  265                           PNUM3:                          // endif
  266                                                           // ( 0 0 <c | 0> -- )
  267    00000210 ........              DC32    RFROM           // ( 0 0 <c | 0> addr+1 -- ) copy of addr+1 <r
  268    00000214 ........              DC32    BRAN
  269    00000218 8CFFFFFF              DC32    PNUM1-.         // REPEAT
  270                           
  271                           PNUM2:
  272    0000021C ........              DC32    RFROM           // copy of addr+1 <r
  273    00000220 ........              DC32    SEMIS
  274                           
  275                           //:NONAME DFIND:        ( --- pfa len tf )(found)
  276                           //                      ( --- ff ) (not found)
  277                           //      Accepts the next text word (delimited by blanks) in the input stream
  278                           //      to HERE, and searches the CONTEXT and then CURRENT vocabularies
  279                           //      for a matching entry. If found, the dictionary entry's parameter
  280                           //      field address, its length byte, and a boolean true is left.
  281                           //      Otherwise, only a boolean false is left.
  282                           //      DFIND LEN HAS TO BE smudged header byte for INTERPRET.
  283                           DFIND:
  284    00000224 ........              DC32    DOCOL
  285                           #ifdef IO2TP
  288                           #endif
  289    00000228 ........              DC32    BLANK   // ( ch -- )
  290    0000022C ........              DC32    WORD    // ( cH-DELIM  --- )
  291    00000230 ........              DC32    HERE    // ( txt -- )
  292                           #ifdef  IOBUFS_DEBUG        
  294                           #endif        
  295    00000234 ........              DC32    LATEST  // ( txt nfa -- )
  296    00000238 ........              DC32    PFIND   // ( txt nfa -- pfa wordlen 1 ) (ok)
  297                                                   // | ( txt nfa -- 0 ) (bad)
  298    0000023C ........              DC32    SEMIS
  299                           
  300                           //:NONAME COMP: ( -- ) Compile CFA of word that follows inside a definition.
  301                           // DOTQ: DO: LOOP: PLOOP: LITERAL: DLITERALl COLON: SEMIS:
  302                           // DO DICTSPACE CHECK, AS DOES COMMA, CCOMMA and ALLOT
  303                           // SO COMMA_PRIM CREATED AND USED HERE FOR COMPILER SPEEDUP
  304                           //      Compile CFA of word that follows.
  305                           //      When the word containing COMPILE executes, the execution address of
  306                           //      the word following COMPILE is copied (compiled) into the dictionary.
  307                           //      This allows specific compilation situations to be handled in
  308                           //      addition to simply compiling an execution address (which the
  309                           //      interpreter already does).
  310                           COMP:
  311    00000240 ........              DC32    DOCOL
  312                           //      DC32    QEXEC   // QCOMP
  313    00000244 ........              DC32    RFROM   // addr of next word in body of this word
  314    00000248 ........              DC32    DUP
  315    0000024C ........              DC32    FOURP   // addr past next word...
  316    00000250 ........              DC32    TOR     // that where execution resumes after
  317    00000254 ........              DC32    AT      // compiling this word
  318                           //      DC32    COMMA   // ALIGNED, INCREMENTS DP REFLECTED by HERE
  319    00000258 ........              DC32    COMMA_PRIM // NO DICTSPACE CHECK HERE
  320    0000025C ........              DC32    SEMIS
  321                           
  322                           //:NONAME MSMOD:        ( ud1 n2 -- n3 ud4 )
  323                           //      An unsigned mixed magnitude math operation which leaves a double
  324                           //      quotient ud4 and remainder u3, from a double dividend ud1 and single
  325                           //      divisor u2. Primarily used in pictured numeric output DIG
  326                           MSMOD:
  327    00000260 ........              DC32    DOCOL           // EX 1 0 A
  328    00000264 ........              DC32    TOR             // -- 1 0
  329    00000268 ........              DC32    ZERO            // -- 1 0 0
  330    0000026C ........              DC32    R               // -- 1 0 0 A
  331    00000270 ........              DC32    USLASH          // ( uLSW uMSW u32 --- u32REMAINDER u32QUOTIENT )
  332    00000274 ........              DC32    RFROM
  333    00000278 ........              DC32    SWAP            // -- 0 A 0 1 0
  334    0000027C ........              DC32    TOR
  335    00000280 ........              DC32    USLASH
  336    00000284 ........              DC32    RFROM
  337    00000288 ........              DC32    SEMIS
  338                           
  339                           //:NONAME SCSP: ( -- ) Save the parameter stack position in CSP.
  340                           //      Part of the compiler security.
  341                           //      Means Store (save) Compile time stack position.
  342                           SCSP:
  343    0000028C ........              DC32    DOCOL
  344    00000290 ........              DC32    SPAT
  345    00000294 ........              DC32    CSP_SV
  346    00000298 ........              DC32    STORE
  347    0000029C ........              DC32    SEMIS
  348                           
  349                           //:NONAME QCSP: ( -- ) Issue error message if stack and CSP don't match.
  350                           //      Indicates unbalanced compilation. Part of compiler security
  351                           QCSP:
  352    000002A0 ........              DC32    DOCOL
  353    000002A4 ........              DC32    SPAT
  354    000002A8 ........              DC32    CSP_SV
  355    000002AC ........              DC32    AT
  356    000002B0 ........              DC32    SUBB
  357    000002B4 .............         DC32    LIT, msg_qstack
                  ...          
  358    000002BC ........              DC32    QERROR    // ( f nullstr-addr -- )
  359    000002C0 ........              DC32    SEMIS
  360                           
  361                           //:NONAME INTERPRET:    ( -- ) The space delimited text Token Interpreter
  362                           //      Find or convert a text token then execute it's semantics or compile it,
  363                           //      depending on STATE. The token text is from the TIB.
  364                           
  365                           //      If the token cannot be found in a dictionary (by a search of CURRENT),
  366                           //      an attempt to converte it to a number according to the current base.
  367                           //      is tried. That also failing, an error message will TYPE and ABORT.
  368                           
  369                           //      Text input will be taken according to the convention for WORD. If a
  370                           //      decimal point is found as part of a number, a double number value
  371                           //      will be left. The decimal point is saved in DPL but otherwise
  372                           //      has no other purpose than to force this action.
  373                           //      See NUMBER.
  374                           INTERPRET:
  375    000002C4 ........              DC32    DOCOL
  376                           INTE1:                          // Begin
  377    000002C8 ........              DC32    DFIND           // IO2TP noop there for TIB entry
  378                           //      -FIND ( --- pfa len tf )(found) ( --- ff ) (not found)
  379    000002CC ........              DC32    ZBRAN           // IF not a word,
  380    000002D0 3C000000              DC32     INTE2-.        // TRY AS A NUMBER
  381                           
  382    000002D4 ........              DC32    STATE_SV        // CSTATE 0 = INTERPRET, Cxh = COMPILING
  383    000002D8 ........              DC32    AT              // DFIND len has to be SMUDGED NFA count
  384    000002DC ........              DC32    LESSTHAN        // for CSTATE to pass IMMEDIATE words
  385    000002E0 ........              DC32    ZBRAN           // To execute immdeiate words while compiling
  386    000002E4 14000000              DC32     INTE3-.
  387                           
  388    000002E8 ........              DC32    CFA
  389    000002EC ........              DC32    COMMA_PRIM      // No DICTSPACE check, aligned.
  390    000002F0 ........              DC32    BRAN    //ELSE
  391    000002F4 0C000000              DC32     INTE4-.
  392                           
  393                           INTE3:
  394    000002F8 ........              DC32    CFA     //EXECUTE FOUND WORD
  395    000002FC ........              DC32    EXEC    //endif
  396                           INTE4:
  397    00000300 ........              DC32    QSTACK   // IF STACK error abort using qerr
  398    00000304 ........              DC32    BRAN    //ELSE
  399    00000308 C0FFFFFF              DC32     INTE1-.
  400                           
  401                           INTE2:
  402    0000030C ........              DC32    HERE
  403    00000310 ........              DC32    NUMBER //( addr   ---   32LSW 32MSW ) IF error quit
  404    00000314 ........              DC32    DPL_SV
  405    00000318 ........              DC32    AT
  406    0000031C ........              DC32    ONEP
  407    00000320 ........              DC32    ZBRAN   // IF 1+ = 0
  408    00000324 10000000              DC32     INTE6-.        // SINGLE NUMBER
  409                           
  410    00000328 ........              DC32    DLITERAL   // PUSH DOUBLE NUMBER TO STACK
  411    0000032C ........              DC32    BRAN    // ELSE DOUBLE NUMBER
  412    00000330 0C000000              DC32     INTE7-.
  413                           
  414                           INTE6:
  415    00000334 ........              DC32    DROP
  416    00000338 ........              DC32    LITERAL // PUSH SINGLE NUMBER TO STACK
  417                           
  418                           INTE7:
  419    0000033C ........              DC32    QSTACK  // endif   // IF STACK error abort using qerr
  420                           
  421                           INTE5:
  422    00000340 ........              DC32    BRAN    // AGAIN
  423    00000344 84FFFFFF              DC32     INTE1-.
  424                           
  425                           //:NONAME QUIT: ( -- ) The Outer Interpreter.
  426                           //      THE OUTER INTERPRETER WAITS FOR INPUT
  427                           //      THEN CONVERTS NUMBERS AND EXECUTES WORDS
  428                           //      Clear the return stack, stop compilation, and return control to the
  429                           //      operators terminal. No message is given.
  430                           QUIT:
  431    00000348 ........              DC32    DOCOL
  432    0000034C ........              DC32    LBRAC   // Set CSTATE to zero - not compiling.
  433    00000350 ........              DC32    SPSTO   // ADDED in PAREN TEST
  434                           QUIT1:                  // Begin
  435                           #ifdef IO2TP
  437                           #endif
  438    00000354 ........              DC32    RPSTO
  439    00000358 ........              DC32    QUERY           // ( -- ) Input to TIB
  440    0000035C ........              DC32    INTERPRET       // ( -- ) RETURN BY CR placing null in tib ->  NULL:
  441                           #ifdef IO2TP
  444                           #endif
  445                           // ISSUE INLY CR IF COMPILING OR IF PROMPT: SET TO 0 WITH POFF(PROMPTOFF)
  446    00000360 ........              DC32    STATE_SV        // 0xC0 is compiling
  447    00000364 ........              DC32    AT
  448    00000368 ........              DC32    ZEQU            // NOT = TO ZERO IF COMPILING SO 0 IF COMPILING
  449    0000036C ........              DC32    ZBRAN           // BRANCH IF 0 - CSTATE IS NON-ZERO = compiling
  450    00000370 38000000              DC32     QUIT2-.        // CR, LOOP AGAIN
  451                           
  452                           // v1.7 new feature to vector the system prompt
  453                           // zero means only cr with every line - for download suppression of all but errs
  454    00000374 .............         DC32    LIT, PROMPT, AT
                  ...........  
  455    00000380 ........              DC32    ZBRAN           // IF PROMPT$ = 0
  456    00000384 24000000              DC32     QUIT2-.        // CR, LOOP AGAIN
  457                           
  458                           // PROMPT$ is not zero
  459    00000388 .............         DC32    LIT, PROMPT, AT
                  ...........  
  460                           //        DC32    LIT, msg_MY_OK
  461    00000394 .............         DC32    NULLSTRLEN, TYPE
                  ...          
  462                           //------------------------------------------------------------------------------
  463                           #ifdef SRM
  469                           #else
  470    0000039C .............         DC32    BASE_SV, AT
                  ...          
  471    000003A4 ........              DC32    DOTDEC
  472                           #endif
  473                           
  474                           //------------------------------------------------------------------------------
  475                           BP1_QUIT:
  476                           #ifdef IO2TP
  480                           #endif
  481                           QUIT2:
  482                           if EOL_DLE
  483                           QUIT_EOL_DLE:
  484    000003A8 ........10000         DC32    LIT, 0x10, EMIT // 16d DLE Data Link Escape
                  000........  
  485                           //        DC32    LIT, 0xFE, EMIT // 255d BLACK SQUARE or '|o' in EOL_DLE
  486                           endif
  487    000003B4 ........              DC32    CR              // HERE FOR BOTH COMPILE AND INTERPRET
  488    000003B8 ........              DC32    BRAN            // AGAIN
  489    000003BC 98FFFFFF              DC32     QUIT1-.
  490                           
  491                           //:NONAME BACK: ( addr -- ) Branch back primitive
  492                           //      Calculate the backward branch offset from HERE to addr and compile
  493                           //      into the next available dictionary memory address.
  494                           BACK:
  495    000003C0 ........              DC32    DOCOL
  496    000003C4 ........              DC32    HERE
  497    000003C8 ........              DC32    SUBB
  498    000003CC ........              DC32    COMMA
  499    000003D0 ........              DC32    SEMIS
  500                           
  501                           //:NONAME SEMIC_CREATE:      ( -- ) Used after CREATE to reset CSDP
  502                           //      Used in ; CON and VAR to reset CSDP which is used to auto forget
  503                           //      Words that have errors during compilation.
  504                           SEMIC_CREATE:
  505    000003D4 ........              DC32    DOCOL
  506    000003D8 ........00000         DC32    STRVA, 0, CSDP  // RESET AUTO FORGET WHEN CREATE ERROR
                  000........  
  507    000003E4 ........              DC32    SEMIS
  508                           
  509                           //:NONAME CSDP_SV ( -- addr of CSDP ) Holds where to reset if definition fails
  510                           CSDP_SV:
  511    000003E8 .............         DC32    DOCON, CSDP
                  ...          
  512                           
  513                           //:NONAME       PM:  ( n1 n2 -- n3 ) Apply the sign of n2 to n1, which is left as n3.
  514                           PM:
  515    000003F0 ........              DC32    DOCOL
  516    000003F4 ........              DC32    ZLESS
  517    000003F8 ........              DC32    ZBRAN   //IF
  518    000003FC 08000000              DC32    PM1-.
  519                           
  520    00000400 ........              DC32    NEGATE  //endif
  521                           PM1:
  522    00000404 ........              DC32    SEMIS
  523                           
  524                           //:NONAME       DPM: ( d1 n -- d2) Apply the sign of n to the double number d1.
  525                           DPM:
  526    00000408 ........              DC32    DOCOL
  527    0000040C ........              DC32    ZLESS
  528    00000410 ........              DC32    ZBRAN   //IF
  529    00000414 08000000              DC32    DPM1-.
  530                           
  531    00000418 ........              DC32    DNEGATE //endif
  532                           DPM1:
  533    0000041C ........              DC32    SEMIS
  534                           
  535                           //:NONAME SIGNON:     ( -- ) type SIGNON message.
  536                           SIGNON:
  537    00000420 ........              DC32    DOCOL
  538                           #ifdef IO2TP
  541                           #endif
  542    00000424 .............         DC32    CR, LIT, msg_FISH
                  ...........  
  543    00000430 .............         DC32    NULLSTRLEN, TYPE
                  ...          
  544                           #ifdef SRM
  546                           #endif
  547                           #ifndef SRM
  548    00000438 .............         DC32    LIT, msg_FISH_TIMESTAMP
                  ...          
  549    00000440 .............         DC32    NULLSTRLEN, TYPE
                  ...          
  550                           #endif
  551                           #ifdef EOL_DLE
  552    00000448 .............         DC32    LIT, msg_SIGNON_DLE
                  ...          
  553    00000450 .............         DC32    NULLSTRLEN, TYPE
                  ...          
  554                           #endif
  555                           #ifndef SRM
  556    00000458 ........              DC32    CR
  557                           #endif
  558                           #ifdef IO2TP
  561                           #endif
  562    0000045C ........              DC32    SEMIS
  563                           
  564                           //:NONAME WARM:       ( -- ) Perform FWARM and FLASH_SCAN
  565                           //      SYSTEM RAMVARSPACE INIT
  566                           //      Patch in FLASH_SAVE'd Code.
  567                           WARM:
  568    00000460 ........              DC32    DOCOL
  569    00000464 ........              DC32    FWARM
  570    00000468 ........              DC32    FLASH_SCAN
  571    0000046C ........              DC32    SEMIS
  572                           
  573                           //:NONAME       TRAVERSE TRAVERSE: ( addr1 n -- addr2 ) Used in NFA and PFA
  574                           //      USED only in NFA and PFA, padding alignment is done there.
  575                           //      Move across a variable length padding aligned name field with smudged 1rst and last
                                 byte.
  576                           //      addr1 is the address of either the length byte or the last letter.
  577                           //      If n=1, the motion is toward nfa - hi memory, if n=-l, the motion is
  578                           //      toward CFA - low memory. The addr2 resulting is address
  579                           //      of the other end of the name.
  580                           TRAVERSE:
  581    00000470 ........              DC32    DOCOL
  582    00000474 ........              DC32    SWAP
  583                           TRAVERSE_BEGIN:
  584    00000478 ........              DC32    OVER    // Begin
  585    0000047C ........              DC32    PLUS
  586    00000480 ........7F000         DC32    LIT,0x7F
                  000          
  587    00000488 ........              DC32    OVER
  588    0000048C ........              DC32    CAT
  589    00000490 ........              DC32    LESSTHAN
  590    00000494 ........              DC32    ZBRAN   //until
  591    00000498 E0FFFFFF              DC32     TRAVERSE_BEGIN-.
  592                           
  593    0000049C ........              DC32    SWAP
  594    000004A0 ........              DC32    DROP
  595    000004A4 ........              DC32    SEMIS
  596                           
  597                           //------------------------------------------------------------------------------
  598                           // ASM CODE START - MUST BE ALLIGNED AGAIN
  599                           /* AS in:
  600                            SECTION .text : CONST (2)
  601                            ALIGNROM 2,0xFFFFFFFF
  602                           LABEL:
  603                                   DC32    .+5
  604                            SECTION .text : CODE (2)
  605                                   ASM     CODE
  606                           */
  607                           //------------------------------------------------------------------------------
  608                           //:NONAME SECTION:
  609                           //:NONAME SV_INIT_VALUES: Table of FISH SYSTEM VAR Iinitial values.
  610                            SECTION .text : CONST (2)
  611                            ALIGNROM 2,0xFFFFFFFF
  612                           SV_INIT_VALUES:
  613                           // 4 words of System Variables
  614    00000000 0A000000              DC32    DEFAULT_BASE            // NBASE
  615    00000004 01000000              DC32    1                       // IN
  616    00000008 00000000              DC32    0                       // OUT
  617    0000000C 00000000              DC32    0                       // CSTATE
  618                           // 5 addresses of System Data Structures
  619    00000010 F00F0010              DC32    PINIT                   // INITSO
  620    00000014 700F0010              DC32    RINIT                   // INITRO
  621    00000018 ........              DC32    TIB                     // INITTIB
  622    0000001C ........              DC32    RAMVARSPACE             // UP
  623    00000020 ........              DC32    ORIG                    // DP
  624                           // 4 addresses of System Pointers
  625    00000024 00000000              DC32    0                       // CSDP
  626    00000028 00000000              DC32    0                       // FENCE
  627                           #ifdef FISH_PubRel_WORDSET
  628    0000002C ........              DC32    WC_FISH_PubRel_NFA      // 11d CURRENT
  629                           #endif
  630                           #ifdef FISH_NXP_M0_PRO_WORDCAT
  632                           #endif
  633    00000030 ........              DC32    msg_MY_OK               // 13d PROMPT
  634    00000034 00000000              DC32    0                       // 14d ERROR_HALT
  635                           // 14d WORDS TO COPY
  636                           
  637                           
  638                           //:NONAME FWARM   ( -- ) FISH SYSTEM VAR Initialization primitive.
  639                            SECTION .text : CONST (2)
  640                            ALIGNROM 2,0xFFFFFFFF
  641                           FWARM:
  642    00000000 ........              DC32    .+5
  643                            SECTION .text : CODE (2)
  644    00000000 0548                  LDR     t, = SV_INIT_VALUES
  645    00000002 0649                  LDR     n, = END_RAMVARSPACE_SV_START
  646    00000004 0E22                  LDR     w, = 14d
  647                           FWBEGIN:
  648    00000006 0368                  LDR     x, [t]
  649    00000008 0B60                  STR     x, [n]
  650    0000000A 0430                  ADDS    t, #4
  651    0000000C 0431                  ADDS    n, #4
  652    0000000E 013A                  SUBS    w, #1
  653    00000010 F9D1                  BNE     FWBEGIN
  654                                   NEXT
  654.1  00000012 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  654                                   NEXT1
  654.1  00000014 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  654.2  00000016 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  654.3                                 ENDM
  654.4                                 ENDM
  655                            LTORG  // Always outside of code, else data in words
  655.1                                  TABLE
  655.2  00000018 ........              Reference on line 644
  655.3  0000001C ........              Reference on line 645
  656                           
  657                           //:NONAME DOCOL   ( -- )  COMPILED VERSION OF COLON
  658                            SECTION .text : CODE (2)
  659                            ALIGNROM 2,0xFFFFFFFF
  660                           DOCOL:  // no cfa for DOCOL!!!!!        <<<<<<<<<<<<<<<<<<
  661                                   PUSHi2r         // save IP to Rstack
  661.1  00000000 361F                  SUBS    r, r, #4        //  push i to r, pre decrement r
  661.2  00000002 3560                  STR     i, [r]
  661.3                                 ENDM
  662    00000004 1546                  MOV     i, w    // jam new IP = cfa+4
  663                                   NEXT
  663.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  663                                   NEXT1
  663.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  663.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  663.3                                 ENDM
  663.4                                 ENDM
  664                           
  665                           //:NONAME SEMIS:        ( -- ) COMPILED VERSION OF SEMICOLON
  666                           //      Terminate a colon-definition,
  667                           //      : pushed the calling word return addr to the return stack
  668                           //      This retrieves it and returns to calling word.
  669                            SECTION .text : CONST (2)
  670                            ALIGNROM 2,0xFFFFFFFF
  671                           SEMIS:
  672    00000000 ........              DC32    .+5
  673                            SECTION .text : CODE (2)
  674                                   POPr2i  // pop docol saved IP from Rstack
  674.1  00000000 3568                  LDR i, [r]              //  pop r to i, post increment r
  674.2  00000002 361D                  ADDS    r, r, #4
  674.3                                 ENDM
  675                                   NEXT
  675.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  675                                   NEXT1
  675.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  675.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  675.3                                 ENDM
  675.4                                 ENDM
  676                           
  677                           //:NONAME DOVAR   ( -- ) COMPILED VERSION OF VAR
  678                           // VAR is a CON but DOVAR is 'duplicated' to allow search for it's CFA
  679                           // so FORGET can reclaim VAR space.
  680                            SECTION .text : CODE (2)
  681                            ALIGNROM 2,0xFFFFFFFF
  682                           DOVAR:
  683    00000000 01CA                  LDM     w!, {t}
  684                                   TPUSH
  684                                   PUSHt   // push t to p, pre decrement p
  684.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  684.2  00000004 3860                  STR     t, [p]
  684.3                                 ENDM
  684                                   NEXT
  684.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  684                                   NEXT1
  684.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  684.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  684.3                                 ENDM
  684.4                                 ENDM
  684.5                                 ENDM
  685                           
  686                           //:NONAME DOCON   ( -- ) COMPILED VERSION OF CON
  687                            SECTION .text : CODE (2)
  688                            ALIGNROM 2,0xFFFFFFFF
  689                           DOCON:
  690    00000000 01CA                  LDM     w!, {t}
  691                                   TPUSH
  691                                   PUSHt   // push t to p, pre decrement p
  691.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  691.2  00000004 3860                  STR     t, [p]
  691.3                                 ENDM
  691                                   NEXT
  691.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  691                                   NEXT1
  691.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  691.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  691.3                                 ENDM
  691.4                                 ENDM
  691.5                                 ENDM
  692                           
  693                           //:NONAME LIT:        ( -- n ) The primitive that pushes a number in a definition.
  694                           //      Within a colon-definition, LIT is automatically compiled before each
  695                           //      32 bit literal number encountered in input text. Later execution of
  696                           //      LIT causes the contents of the next dictionary address ( the LITERAL #)
  697                           //      to be pushed to the stack.
  698                           //      Use LITERAL
  699                            SECTION .text : CONST (2)
  700                            ALIGNROM 2,0xFFFFFFFF
  701                           LIT:
  702    00000000 ........              DC32    .+5
  703                            SECTION .text : CODE (2)
  704                                   LIT2t   // LDM          i!, {t}
  704.1                                 // as in xeq token at ToS setup for lit
  704.2  00000000 01CD                  LDM     i!, {t} // fetch memory p points to into {t}, inc i
  704.3                                 ENDM
  705                                           // fetch memory i points to into {t}, inc i after
  706                                   TPUSH
  706                                   PUSHt   // push t to p, pre decrement p
  706.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  706.2  00000004 3860                  STR     t, [p]
  706.3                                 ENDM
  706                                   NEXT
  706.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  706                                   NEXT1
  706.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  706.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  706.3                                 ENDM
  706.4                                 ENDM
  706.5                                 ENDM
  707                           
  708                           //:NONAME RLIT: ( -- n ) LIT primitive that can have it's value relocated.
  709                           //      SEE LIT. ALLOWS RELOCATION OF THIS type OF LIT
  710                            SECTION .text : CONST (2)
  711                            ALIGNROM 2,0xFFFFFFFF
  712                           RLIT:
  713    00000000 ........              DC32    .+5
  714                            SECTION .text : CODE (2)
  715                                   LIT2t           // LDM          i!, {t}
  715.1                                 // as in xeq token at ToS setup for lit
  715.2  00000000 01CD                  LDM     i!, {t} // fetch memory p points to into {t}, inc i
  715.3                                 ENDM
  716                                                   // fetch memory i points to into {t}, inc i after
  717                                   TPUSH
  717                                   PUSHt   // push t to p, pre decrement p
  717.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  717.2  00000004 3860                  STR     t, [p]
  717.3                                 ENDM
  717                                   NEXT
  717.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  717                                   NEXT1
  717.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  717.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  717.3                                 ENDM
  717.4                                 ENDM
  717.5                                 ENDM
  718                           
  719                           //:NONAME GOTO:   ( cfa -- ) Redirect execution to cfa in another hi-level word.
  720                           //      CAUTION!!!!!!! A SYSTEM WORD EXPOSED FOR THE BOLD AND BRAVE!!!!!!!
  721                           //      Stack in CURRENT WORD MUST BE CLEANED UP!
  722                           //      AND STACK MUSTE BE SET UP as expected where you GOTO.
  723                           //      YOU CANNOT VIOLATE controls structure (LOOPS, BEGINs IFs, etc).
  724                           //      Unless you come from the same point in the same control structure!
  725                            SECTION .text : CONST (2)
  726                            ALIGNROM 2,0xFFFFFFFF
  727                           GOTO:
  728    00000000 ........              DC32    .+5
  729                            SECTION .text : CODE (2)
  730                                   POP2i // set i as pointer to cfa to start execution
  730.1  00000000 3D68                  LDR     i, [p]
  730.2  00000002 3F1D                  ADDS    p, p, #4
  730.3                                 ENDM
  731                                   NEXT
  731.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  731                                   NEXT1
  731.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  731.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  731.3                                 ENDM
  731.4                                 ENDM
  732                           
  733                           //:NONAME CREATE_DOES_GOTO:   ( -- )
  734                           //      PUSH ADDRESS OF CREATED WORDS PFA THEN
  735                           //      Redirect execution to cfa of the CREATE DOES> word.
  736                           //      THIS IS LIKE A DOCON IE NO DOCOL!!!!
  737                           //      CAUTION!!!!!!! A SYSTEM WORD EXPOSED FOR THE BOLD AND BRAVE!!!!!!!
  738                           //      Stack in CURRENT WORD MUST BE CLEANED UP!
  739                           //      AND STACK MUSTE BE SET UP as expected where you GOTO.
  740                           //      YOU CANNOT VIOLATE controls structure (LOOPS, BEGINs IFs, etc).
  741                           //      Unless you come from the same point in the same control structure!
  742                           CREATE_DOES_GOTO:
  743                            SECTION .text : CODE (2)
  744                           // WILL NEED A NEW CASE in FLASH_SAVE!
  745                           // NO DOCOL - SO FUDGE ONE
  746                           // PUSH ADDR AFTER EXEC in INTERPRET TO r:
  747                                   PUSHi2r         // save IP to Rstack
  747.1  00000000 361F                  SUBS    r, r, #4        //  push i to r, pre decrement r
  747.2  00000002 3560                  STR     i, [r]
  747.3                                 ENDM
  748                           // AND THIS LOADS GOTO ADDR
  749    00000004 4568                  LDR     i, [t, #4]      // GET GOTO ADDRESS
  750                           // THIS PUSHES PFA TO t
  751    00000006 0830                  ADDS    t, t, #8        // COMPUTE REAL PFA
  752                                   PUSHt
  752.1  00000008 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  752.2  0000000A 3860                  STR     t, [p]
  752.3                                 ENDM
  753                                   NEXT
  753.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  753                                   NEXT1
  753.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  753.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  753.3                                 ENDM
  753.4                                 ENDM
  754                           
  755                           //:NONAME DICTSPACE:  ( -- n ) Calculate and push dictionary space available
  756                            SECTION .text : CONST (2)
  757                            ALIGNROM 2,0xFFFFFFFF
  758                           DICTSPACE:
  759    00000000 ........              DC32    .+5
  760                            SECTION .text : CODE (2)
  761    00000000 0448                  LDR     t, = DICTSPACE_END
  762    00000002 0549                  LDR     n, = DP
  763    00000004 0968                  LDR     n, [n]
  764    00000006 401A                  SUBS    t, t, n
  765                                   TPUSH
  765                                   PUSHt   // push t to p, pre decrement p
  765.1  00000008 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  765.2  0000000A 3860                  STR     t, [p]
  765.3                                 ENDM
  765                                   NEXT
  765.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  765                                   NEXT1
  765.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  765.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  765.3                                 ENDM
  765.4                                 ENDM
  765.5                                 ENDM
  766                           // LTORG
  767                           
  768                           //:NONAME VARSPACE:    ( -- n ) Calculate and push VAR space available
  768.1                                  TABLE
  768.2  00000014 ........              Reference on line 761
  768.3  00000018 ........              Reference on line 762
  769                            SECTION .text : CONST (2)
  770                            ALIGNROM 2,0xFFFFFFFF
  771                           VARSPACE:
  772    00000000 ........              DC32    .+5
  773                            SECTION .text : CODE (2)
  774    00000000 0448                  LDR     t, = END_RAMVARSPACE_SV_START
  775    00000002 0549                  LDR     n, = UP // UP IS ALLOCATION POINTER FOR VARS AND VARALLOT
  776    00000004 0968                  LDR     n, [n]
  777    00000006 401A                  SUBS    t, t, n
  778                                   TPUSH
  778                                   PUSHt   // push t to p, pre decrement p
  778.1  00000008 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  778.2  0000000A 3860                  STR     t, [p]
  778.3                                 ENDM
  778                                   NEXT
  778.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  778                                   NEXT1
  778.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  778.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  778.3                                 ENDM
  778.4                                 ENDM
  778.5                                 ENDM
  779    00000012 0000           LTORG
  779.1                                  TABLE
  779.2  00000014 ........              Reference on line 774
  779.3  00000018 ........              Reference on line 775
  780                           
  781                           // Rewrite for TOSCT interop?
  782                           //:NONAME PFIND:        ( addr1 addr2 -- pfa b tf ) (ok)
  783                           //              ( addr1 addr2 -- ff ) (bad)
  784                           //      LEN HAS TO BE smudged header byte for INTERPRET.
  785                           //      Header LEN BYTE REQUIRED by Interpret for immediate word execution
  786                           //      Searches the dictionary starting at the name field address addr2,
  787                           //      matching to the text at addr1. Returns parameter field address,
  788                           //      length byte of name field and boolean true for a good match. If no
  789                           //      match is found, only a boolean false is left.
  790                           //
  791                           //      To step thru to a word set bp at :NONAME
  792                           //      and watch r3 for match of word addr from symbol file
  793                            SECTION .text : CONST (2)
  794                            ALIGNROM 2,0xFFFFFFFF
  795                           PFIND:
  796    00000000 ........              DC32    .+5
  797                            SECTION .text : CODE (2)
  798                                   POP2x   // r3 Dict Name NFA
  798.1  00000000 3B68                  LDR     x, [p]
  798.2  00000002 3F1D                  ADDS    p, p, #4
  798.3                                 ENDM
  799                                   POP2w   // r2 String Addr usually at here
  799.1  00000004 3A68                  LDR     w, [p]
  799.2  00000006 3F1D                  ADDS    p, p, #4
  799.3                                 ENDM
  800    00000008 9346                  MOV     rb, w   // r11 Save TXT String ADDR
  801                           
  802                           //      SEARCH LOOP
  803                           //      nfa length test
  804                           //      x must = Dict nfa
  805                           PFIN1:                  // ADDR-->char counted strings
  806    0000000A 5A46                  MOV     w, rb   // restore txt str addr
  807    0000000C 1878                  LDRB    t, [x]  // GET nfa LENGTH from r3
  808                           //      LEN HAS TO BE smudged header byte for DFIND -> INTERPRET.
  809                           //      ELSE DO THIS HERE TO MAKE IT ACTUAL & REMOVE SECTION BELOW
  810                           //      MOVS    y, #0x3F
  811                           //      ANDS    t, y
  812    0000000E 8446                  MOV     k, t    // r12 Save search word length
  813    00000010 1178                  LDRB    n, [w]  // r1 r2 TXT WORD LEN
  814    00000012 4840                  EORS    t, t, n
  815    00000014 3F24                  MOVS    y, # 03Fh
  816    00000016 2040                  ANDS    t, y
  817    00000018 19D1                  BNE     PFIN5   // Len mismatch, GET NEXT LINK FIELD ADDR (lfa)
  818                           
  819                           //      LENGTHS MATCH - CHECK EACH CHARACTER in NAME
  820                           //      TEST FIRST CHAR AND DETERMINE IF LAST
  821                           PFIN2:
  822    0000001A 521C                  ADDS    w, w, #1        // str
  823    0000001C 5B1C                  ADDS    x, x, #1        // nfa
  824    0000001E 1878                  LDRB    t, [x]          // GET nfa 1RST CHAR
  825    00000020 1178                  LDRB    n, [w]          // GET TXT 1RST CHAR
  826    00000022 8842                  CMP     t, n            // eor was working but this make 0x80 subb
  827    00000024 F9D0                  BEQ     PFIN2           // matched try next char
  828                             
  829    00000026 8024                  MOVS    y, #0x80
  830    00000028 001B                  SUBS    t, t, y         // ascii only in t and n
  831    0000002A 8842                  cmp     t, n
  832    0000002C 10D1                  BNE     PFIN51          // goto  WORD MISMATCH
  833                           
  834                           //      FOUND END OF NAME (BIT 8 SET) - A MATCH
  835                           //      GET to pfa of found word
  836                           PFIN21:
  837                           
  838    0000002E 5B1C                  ADDS    x, x, #1        // Dict addr
  839    00000030 1878                  LDRB    t, [x]
  840    00000032 FF28                  CMP     t, #0xFF
  841    00000034 FBD0                  BEQ     PFIN21
  842                           
  843                           thispfa:
  844                           
  845    00000036 0833                  ADDS    x, x, #8        // at cfa -> pfa
  846                                   PUSHx                   // PUSH pfa
  846.1  00000038 3F1F                  SUBS    p, p, #4        //  push x to p, pre decrement p
  846.2  0000003A 3B60                  STR     x, [p]
  846.3                                 ENDM
  847    0000003C 0120                  MOVS    t, #1           // TRUE VALUE
  848    0000003E 6246                  MOV     w, k            // RETURN Header Byte LENGTH
  849                                   DPUSH
  849                                   PUSHw   // push w to p, pre decrement p
  849.1  00000040 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
  849.2  00000042 3A60                  STR     w, [p]
  849.3                                 ENDM
  849                                   TPUSH
  849                                   PUSHt   // push t to p, pre decrement p
  849.1  00000044 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  849.2  00000046 3860                  STR     t, [p]
  849.3                                 ENDM
  849                                   NEXT
  849.1  00000048 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  849                                   NEXT1
  849.1  0000004A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  849.2  0000004C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  849.3                                 ENDM
  849.4                                 ENDM
  849.5                                 ENDM
  849.6                                 ENDM
  850                           
  851                           //      NO NAME MATCH - TRY ANOTHER
  852                           //      Set NEXT LINK FIELD ADDR (lfa) to x
  853                           //      ( ZERO = FIRST WORD OF DICTIONARY )
  854                           //      GET TO END OF NAME BEFORE Padding IF ANY
  855                           //      ENTER HERE FROM LEN!= (RB->CNT)
  856                           PFIN5:
  857    0000004E 5B1C                  ADDS     x, x, #1       // inc char in name addr
  858                           
  859                           //      ENTER HERE FROM WORD MISMATCH
  860                           PFIN51:
  861    00000050 1878                  LDRB    t, [x]          // get Dict Word char
  862    00000052 8024                  MOVS    y, #0x80
  863    00000054 2042                  TST     t, y            // is last char in word bit set
  864    00000056 FAD0                  BEQ     PFIN5
  865                           
  866                           //      UNMATCHED NAME - POINTING AT LAST CHAR BEFORE Padding IF ANY
  867                           //      GET PAST FF Padding AND GET lfa
  868                           PFIN7:
  869                           // Code for ALIGNED
  870                           //      ADDS            x, x, #3
  871    00000058 1B1D                  ADDS            x, x, #4        // add 1 for entry
  872    0000005A 0648                  LDR             t, =-4
  873    0000005C 0340                  ANDS            x, x, t
  874    0000005E 1B68                  LDR     x, [x]  // r3 GET lfa to next word
  875    00000060 002B                  CMP     x, #0   // START OF DICT ( 0 ) ?
  876    00000062 00D0                  BEQ             WORDNOTFOUND
  877                           
  878                           // NOT A BRAN TARGET - This one used for breakpoint
  879                           PFIND_NEXT_NFA:
  880    00000064 D1E7                  B       PFIN1           // Search next word x must = Dict nfa
  881                           
  882                           WORDNOTFOUND:                   // PFIND: DONE ( NO MATCH FOUND )
  883    00000066 0020                  MOVS     t, #0
  884                                   TPUSH
  884                                   PUSHt   // push t to p, pre decrement p
  884.1  00000068 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  884.2  0000006A 3860                  STR     t, [p]
  884.3                                 ENDM
  884                                   NEXT
  884.1  0000006C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  884                                   NEXT1
  884.1  0000006E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  884.2  00000070 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  884.3                                 ENDM
  884.4                                 ENDM
  884.5                                 ENDM
  885    00000072 0000           LTORG
  885.1                                  TABLE
  885.2  00000074 FCFFFFFF              Reference on line 872
  886                           
  887                           //:NONAME BRAN: ( -- ) Branch in definitions primitive
  888                           //      In IAR branch target MUST BE ON Next LINE!!!<<<<<<<<<<<<<<<<<<<<<<<<
  889                           //      The run-time proceedure to unconditionally branch. An in-line offset
  890                           //      is added to the interpretive pointer IP to branch ahead or back.
  891                           //      BRANCH is compiled by ELSE, AGAIN, REPEAT.
  892                            SECTION .text : CONST (2)
  893                            ALIGNROM 2,0xFFFFFFFF
  894                           BRAN:
  895    00000000 ........              DC32    .+5
  896                            SECTION .text : CODE (2)
  897                           BRAN1:
  898    00000000 2B68                  LDR     x, [i]          // Get branck target
  899    00000002 ED18                  ADDS    i, i, x         // use as offset
  900                                   NEXT
  900.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  900                                   NEXT1
  900.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  900.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  900.3                                 ENDM
  900.4                                 ENDM
  901                           
  902                           //:NONAME ZBRAN:        ( f -- ) Branch if zero definition primitive.
  903                           //      In IAR branch target MUST BE ON Next LINE!!!<<<<<<<<<<<<<<<<<<<<<<<<
  904                           //      The run-time proceedure to conditionally branch. If f is false
  905                           //      (zero), the following in-line parameter is added to the interpretive
  906                           //      pointer to branch ahead or back. Compiled by IF, UNTIL, and WHILE.
  907                            SECTION .text : CONST (2)
  908                            ALIGNROM 2,0xFFFFFFFF
  909                           ZBRAN:
  910    00000000 ........              DC32    .+5
  911                            SECTION .text : CODE (2)
  912                                   POP2t
  912.1                         #ifndef TOSCT
  912.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  912.3                         #endif
  912.4  00000002 3F1D                  ADDS    p, p, #4
  912.5                                 ENDM
  913    00000004 0028                  CMP     t, #0           // ZERO?
  914                           #ifdef TOSCT                    // CMP CONSUMES t
  916                           #endif
  917    00000006 ....                  beq     BRAN1           // YES, BRANCH
  918                           
  919    00000008 2D1D                  ADDS    i, i, #4        // NO - CONTINUE...
  920                                   NEXT
  920.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  920                                   NEXT1
  920.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  920.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  920.3                                 ENDM
  920.4                                 ENDM
  921                           
  922                           //:NONAME XLOOP:        ( -- ) Loop primitive in a definition.
  923                           //      The run-time proceedure compiled by LOOP which increments
  924                           //      the loop index by one and tests for loop completion.
  925                           //      See LOOP.
  926                            SECTION .text : CONST (2)
  927                            ALIGNROM 2,0xFFFFFFFF
  928                           XLOOP:
  929    00000000 ........              DC32    .+5
  930                            SECTION .text : CODE (2)
  931    00000000 0123                  MOVS            x, #1
  932                           XLOO1:
  933                                   // Get Limit and Index from r w/o popping them
  934    00000002 7468                  LDR     y, [r, #4]      // Limit
  935    00000004 3268                  LDR     w, [r]          // Index
  936    00000006 9442                  CMP     y, w            // If equal
  937    00000008 03D0                  BEQ     XLOO2           // done
  938                           
  939    0000000A D218                  adds    w, w, x         // INDEX = INDEX + INCR
  940    0000000C 3260                  str     w, [r]          // Put it back by overwrite for I
  941    0000000E A41A                  SUBS    y, y, w
  942    00000010 ....                  BNE     BRAN1           // End of `DO' LOOP
  943                           XLOO2:
  944                                   // Drop Limit and Index, increment i
  945    00000012 0836                  ADDS    r, r, #8
  946    00000014 2D1D                  ADDS    i, i, #4
  947                                   NEXT
  947.1  00000016 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  947                                   NEXT1
  947.1  00000018 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  947.2  0000001A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  947.3                                 ENDM
  947.4                                 ENDM
  948                           
  949                           //:NONAME XPLOOP:       ( n -- ) +LOOP primitive in definitions.
  950                           //      The run-time proceedure compiled by +LOOP, which increments the loop
  951                           //      index by n and tests for loop completion. See +LOOP.
  952                            SECTION .text : CONST (2)
  953                            ALIGNROM 2,0xFFFFFFFF
  954                           XPLOOP:
  955    00000000 ........              DC32    .+5
  956                            SECTION .text : CODE (2)
  957                                   POP2x                   // GET LOOP VALUE
  957.1  00000000 3B68                  LDR     x, [p]
  957.2  00000002 3F1D                  ADDS    p, p, #4
  957.3                                 ENDM
  958                           #ifdef TOSCT
  960                           #endif
  961    00000004 ....                  b       XLOO1           // see XLOO1 for why it's put in x
  962                           
  963                           //:NONAME XDO:  ( Limit Index -- ) The DO primitive in definitions.
  964                           //      ( Limit = addr+cnt Index = addr  -- ) as in ( TIB+LEN TIB -- )
  965                           //      The run-time proceedure compiled by DO which moves the loop control
  966                           //      parameters to the return stack. See DO.
  967                            SECTION .text : CONST (2)
  968                            ALIGNROM 2,0xFFFFFFFF
  969                           XDO:
  970    00000000 ........              DC32    .+5
  971                            SECTION .text : CODE (2)
  972                                   POP2t                   // INITIAL INDEX VALUE = ADDR
  972.1                         #ifndef TOSCT
  972.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  972.3                         #endif
  972.4  00000002 3F1D                  ADDS    p, p, #4
  972.5                                 ENDM
  973                                   POP2w                   // LIMIT VALUE = ADDR+CNT
  973.1  00000004 3A68                  LDR     w, [p]
  973.2  00000006 3F1D                  ADDS    p, p, #4
  973.3                                 ENDM
  974                                   PUSHw2r
  974.1  00000008 361F                  SUBS    r, r, #4        //  push w to r, pre decrement r
  974.2  0000000A 3260                  STR     w, [r]
  974.3                                 ENDM
  975                                   PUSHt2r                 // i expects index TOP of RSTACK
  975.1  0000000C 361F                  SUBS    r, r, #4        //  push t to r, pre decrement r
  975.2  0000000E 3060                  STR     t, [r]
  975.3                                 ENDM
  976                           #ifdef TOSCT
  978                           #endif
  979                                   NEXT
  979.1  00000010 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  979                                   NEXT1
  979.1  00000012 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  979.2  00000014 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  979.3                                 ENDM
  979.4                                 ENDM
  980                           
  981                           //:NONAME CATLT7F  ( addr -- c ) Get char at addr then AND it with 7Fh
  982                            SECTION .text : CONST (2)
  983                            ALIGNROM 2,0xFFFFFFFF
  984                           CATLT7F:
  985    00000000 ........              DC32    .+5
  986                            SECTION .text : CODE (2)
  987                                   POP2t
  987.1                         #ifndef TOSCT
  987.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  987.3                         #endif
  987.4  00000002 3F1D                  ADDS    p, p, #4
  987.5                                 ENDM
  988    00000004 0078                  LDRB    t, [t]
  989    00000006 7F21                  LDR     n, =7Fh
  990    00000008 0840                  ANDS    t, t, n
  991                                   TPUSH
  991                                   PUSHt   // push t to p, pre decrement p
  991.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  991.2  0000000C 3860                  STR     t, [p]
  991.3                                 ENDM
  991                                   NEXT
  991.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  991                                   NEXT1
  991.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  991.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  991.3                                 ENDM
  991.4                                 ENDM
  991.5                                 ENDM
  992                           
  993                           //:NONAME TIB_CHAR_SCAN   ( c -- f ) Scan TIB for c or until null found.
  994                           // Scan TIB, a null terminated string at TIB+IN for 'c' or null termination.
  995                           // Uses and adjusts IN to reflect offset to c or null in TIB.
  996                           // Return false flag if null found first, indicating end of input in TIB,
  997                           // ( usually from QUERY ) else return true flag, either with IN adjusted.
  998                            SECTION .text : CONST (2)
  999                            ALIGNROM 2,0xFFFFFFFF
 1000                           TIB_CHAR_SCAN:
 1001    00000000 ........              DC32    .+5
 1002                            SECTION .text : CODE (2)
 1003                           // t is char matched from TIB as flag to return
 1004                                   POP2n                   // Char were lookin for
 1004.1  00000000 3968                  LDR     n, [p]
 1004.2  00000002 3F1D                  ADDS    p, p, #4
 1004.3                                 ENDM
 1005    00000004 094A                  LDR     w, = TIB
 1006    00000006 9246                  MOV     ra, w           // Save for IN calculation.
 1007    00000008 094B                  LDR     x, = IN
 1008    0000000A 1C68                  LDR     y, [x]          // Get offset in to TIB
 1009    0000000C 1219                  ADDS    w, w, y         // Create TIB+IN
 1010                           TCS_LOOP:
 1011    0000000E 1078                  LDRB    t, [w]          // Strting at TIB+IN ( ex space after ( .
 1012    00000010 0132                  ADDS    w, #1           // When matched
 1013    00000012 8842                  CMP     t, n            // Character passed to test
 1014    00000014 01D0                  BEQ     TCS_FOUND
 1015                                   
 1016    00000016 0028                  CMP     t, #0           // Null at end of TIB?
 1017    00000018 F9D1                  BNE     TCS_LOOP        // no keep looking
 1018                           
 1019                           TCS_FOUND:
 1020    0000001A 5446                  MOV     y, ra           // TIB
 1021    0000001C 121B                  SUBS    w, w, y         // TIB+Char offset
 1022    0000001E 1A70                  STRB    w, [x]          // Set IN
 1023                                   TPUSH                   // t is null or char
 1023                                   PUSHt   // push t to p, pre decrement p
 1023.1  00000020 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1023.2  00000022 3860                  STR     t, [p]
 1023.3                                 ENDM
 1023                                   NEXT
 1023.1  00000024 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1023                                   NEXT1
 1023.1  00000026 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1023.2  00000028 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1023.3                                 ENDM
 1023.4                                 ENDM
 1023.5                                 ENDM
 1024                           
 1025                           //:NONAME TOGGLE:       ( addr b -- ) Complement BYTE at addr by the bit pattern b.
 1026                           //      Byte operator for NFA count byte
 1027                           //      Complement (FLIP) the BYTE contents of addr by the bit pattern b.
 1028                           //      SEE SETBITS and CLRBITS
 1028.1                                  TABLE
 1028.2  0000002C ........              Reference on line 1005
 1028.3  00000030 ........              Reference on line 1007
 1029                            SECTION .text : CONST (2)
 1030                            ALIGNROM 2,0xFFFFFFFF
 1031                           TOGGLE:
 1032    00000000 ........              DC32    .+5
 1033                            SECTION .text : CODE (2)
 1034                                   POP2n           // Bit PATTERN
 1034.1  00000000 3968                  LDR     n, [p]
 1034.2  00000002 3F1D                  ADDS    p, p, #4
 1034.3                                 ENDM
 1035                                   POP2w           // ADDR
 1035.1  00000004 3A68                  LDR     w, [p]
 1035.2  00000006 3F1D                  ADDS    p, p, #4
 1035.3                                 ENDM
 1036    00000008 1078                  LDRB    t, [w]
 1037    0000000A 4840                  EORS    t, t, n
 1038    0000000C 1070                  STRB    t, [w]
 1039                                   NEXT
 1039.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1039                                   NEXT1
 1039.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1039.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1039.3                                 ENDM
 1039.4                                 ENDM
 1040                           
 1041                           #ifdef XON_XOFF
 1042                           //:NONAME IF_EOL_SEND_XOFF: Get xoff out ASAP in EXPECT!
 1043                           //      Must leave char in t!!!!!!!!!
 1044                            SECTION .text : CONST (2)
 1045                            ALIGNROM 2,0xFFFFFFFF
 1046                           IF_EOL_SEND_XOFF:
 1047    00000000 ........              DC32    .+5
 1048                            SECTION .text : CODE (2)
 1049                           //------------------------------------------------------------------------------
 1050                           #ifdef  IO2TP
 1052                           #else
 1053                           //------------------------------------------------------------------------------
 1054    00000000 0A21                  LDR     n, = 0Ah        // ^J
 1055    00000002 8842                  CMP     t, n
 1056    00000004 05D1                  BNE     CR_CHECK
 1057                           
 1058                           SUB_CR_4_NL:
 1059                                   POP2t
 1059.1                         #ifndef TOSCT
 1059.2  00000006 3868                  LDR     t, [p]          // pop tos to t, post increment p
 1059.3                         #endif
 1059.4  00000008 3F1D                  ADDS    p, p, #4
 1059.5                                 ENDM
 1060    0000000A 0D20                  LDR     t, = 0Dh        // ^M
 1061                                   PUSHt
 1061.1  0000000C 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1061.2  0000000E 3860                  STR     t, [p]
 1061.3                                 ENDM
 1062    00000010 02E0                  B       EOL_SEND_XOFF
 1063                           
 1064                           CR_CHECK:
 1065    00000012 0D21                  LDR     n, = 0Dh
 1066    00000014 8842                  CMP     t, n    // LEAVE CHAR in T!!!!
 1067    00000016 03D1                  BNE     NOT_CR
 1068                           
 1069                           EOL_SEND_XOFF:
 1070                           // IO2TP DOES NOT GET HERE
 1071    00000018 ........              BL      TXRDY_SUBR
 1072    0000001C ........              BL      XOFF_SUBR
 1073                           //------------------------------------------------------------------------------
 1074                           NOT_CR:
 1075                                   NEXT
 1075.1  00000020 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1075                                   NEXT1
 1075.1  00000022 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1075.2  00000024 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1075.3                                 ENDM
 1075.4                                 ENDM
 1076                           #endif  // else IO2TP
 1077                           #endif // XON_XOFF
 1078                           
 1079                           
 1080                           //:NONAME NUMBERSUFFIX:      ( addr -- addr ) Number BASE suffix eval primitive.
 1081                           //      In NUMBER temporarily change base if number has valid suffix.
 1082                           //      IF LEN =1 LEAVE IT!
 1083                           //      IF LEN =2 CHECK FOR .suffix!
 1084                           //      addr is counted number striong. The count is ignored by NUMBER
 1085                           //      If valid Base suffix replace suffix with null for NUMBER.
 1086                           //      NUMBER must save and restore base outside of this call.
 1087                            SECTION .text : CONST (2)
 1088                            ALIGNROM 2,0xFFFFFFFF
 1089                           NUMBERSUFFIX:
 1090    00000000 ........              DC32    .+5
 1091                            SECTION .text : CODE (2)
 1092                                   NDPOP2t         // macro = copy tos to t, leave it on the stack
 1092.1  00000000 3868                  LDR     t, [p]
 1092.2                                 ENDM
 1093    00000002 0178                  LDRB    n, [t]  // get string lentgth
 1094    00000004 0129                  CMP     n, #1
 1095    00000006 0FD0                  BEQ     NSEXIT1
 1096                                   
 1097    00000008 0229                  CMP     n, #2
 1098    0000000A 10D0                  BEQ     NSTWO
 1099                           
 1100                           NSNOTTWO:
 1101    0000000C 0144                  ADD     n, n, t // point to end of string
 1102    0000000E 0A78                  LDRB    w, [n]  // get possible suffix
 1103    00000010 622A                  CMP     w, #'b' // 62h
 1104    00000012 12D0                  BEQ     USEBIN
 1105    00000014 252A                  CMP     w, #'%'
 1106    00000016 10D0                  BEQ     USEBIN
 1107                                   
 1108    00000018 642A                  CMP     w, #'d' // 64h
 1109    0000001A 10D0                  BEQ     USEDEC
 1110    0000001C 232A                  CMP     w, #'#'
 1111    0000001E 0ED0                  BEQ     USEDEC
 1112                                   
 1113    00000020 682A                  CMP     w, #'h' // 68h
 1114    00000022 0ED0                  BEQ     USEHEX
 1115    00000024 242A                  CMP     w, #'$'
 1116    00000026 0CD0                  BEQ     USEHEX
 1117                           
 1118                           NSEXIT1:
 1119                                   NEXT
 1119.1  00000028 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1119                                   NEXT1
 1119.1  0000002A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1119.2  0000002C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1119.3                                 ENDM
 1119.4                                 ENDM
 1120                           
 1121                           NSTWO:  // HERE BECAUSE INPUT LEN IS 2 SO IF . IS FIRST
 1122    0000002E 4278                  LDRB    w, [t, #1]      // GET 1RST CHAR
 1123    00000030 2E2A                  CMP     w, #'.'         // IF IT'S A DOT
 1124    00000032 EBD1                  BNE     NSNOTTWO
 1125                                   NEXT
 1125.1  00000034 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1125                                   NEXT1
 1125.1  00000036 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1125.2  00000038 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1125.3                                 ENDM
 1125.4                                 ENDM
 1126                           
 1127                           USEBIN:
 1128    0000003A 0224                  LDR     y, =2
 1129    0000003C 02E0                  B       CLRSUFFIX
 1130                           USEDEC:
 1131    0000003E 0A24                  LDR     y, =10
 1132    00000040 00E0                  B       CLRSUFFIX
 1133                           USEHEX:
 1134    00000042 1024                  LDR     y, =16
 1135                           
 1136                           CLRSUFFIX:
 1137    00000044 0022                  LDR     w, =0X00        // =0x20
 1138    00000046 0A70                  STRB    w, [n]
 1139    00000048 024A                  LDR     w, =NBASE       // BASE_SV in FISH
 1140    0000004A 1460                  STR     y, [w]
 1141                                   NEXT
 1141.1  0000004C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1141                                   NEXT1
 1141.1  0000004E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1141.2  00000050 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1141.3                                 ENDM
 1141.4                                 ENDM
 1142    00000052 0000           LTORG
 1142.1                                  TABLE
 1142.2  00000054 ........              Reference on line 1139
 1143                           
 1144                           //:NONAME       USTAR:  (u1 u2 --  ud=<LSW MSW> ) USED INTERNALLY - NOT UNSIGNED
 1145                           //      Leave the unsigned double number product of two unsigned numbers.
 1146                            SECTION .text : CONST (2)
 1147                            ALIGNROM 2,0xFFFFFFFF
 1148                           USTAR:
 1149    00000000 ........              DC32    .+5
 1150                            SECTION .text : CODE (2)
 1151                                   POP2t
 1151.1                         #ifndef TOSCT
 1151.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 1151.3                         #endif
 1151.4  00000002 3F1D                  ADDS    p, p, #4
 1151.5                                 ENDM
 1152                                   POP2n
 1152.1  00000004 3968                  LDR     n, [p]
 1152.2  00000006 3F1D                  ADDS    p, p, #4
 1152.3                                 ENDM
 1153                                   
 1154                           // IRQ's and c routines share cstack
 1155                            IMPORT C_CMSIS_DISABLE_IRQS
 1156    00000008 ........              BL C_CMSIS_DISABLE_IRQS
 1157                            IMPORT c_32by32to64mul // LSW in t (r0), MSW in n (r1)
 1158    0000000C ........              BL      c_32by32to64mul
 1159                            IMPORT C_CMSIS_ENABLE_IRQS
 1160    00000010 ........              BL C_CMSIS_ENABLE_IRQS       
 1161    00000014 0246                  MOV     w, t    // LSW
 1162    00000016 0846                  MOV     t, n    // MSW
 1163                                   DPUSH           //  --  LSW MSW )
 1163                                   PUSHw   // push w to p, pre decrement p
 1163.1  00000018 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1163.2  0000001A 3A60                  STR     w, [p]
 1163.3                                 ENDM
 1163                                   TPUSH
 1163                                   PUSHt   // push t to p, pre decrement p
 1163.1  0000001C 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1163.2  0000001E 3860                  STR     t, [p]
 1163.3                                 ENDM
 1163                                   NEXT
 1163.1  00000020 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1163                                   NEXT1
 1163.1  00000022 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1163.2  00000024 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1163.3                                 ENDM
 1163.4                                 ENDM
 1163.5                                 ENDM
 1163.6                                 ENDM
 1164                           
 1165                           //:NONAME       USLASH: ( d n --- u32REM u32QUO ) USED INTERNALLY - NOT UNSIGNED
 1166                           //      Leave the unsigned remainder u2 and unsigned quotient u3 from the
 1167                           //      unsigned double dividend ud and unsigned divisor u1.
 1168                           //      RESULTS ARE NOT A TRADITOIONAL DOUBLE NUMBER ONE WOULD PRINT USING D.
 1169                           //      Quotient = int ( Dividend / Divisor )
 1170                           //      Remainder = Dividend - Quotient * Divisor
 1171                            SECTION .text : CONST (2)
 1172                            ALIGNROM 2,0xFFFFFFFF
 1173                           USLASH:
 1174    00000000 ........              DC32    .+5
 1175                            SECTION .text : CODE (2)
 1176                           //      U/  USLASH: ( uLSW uMSW u32 --- u32REMAINDER u32QUOTIENT )
 1177                                   POP2t                   // U32  divisor
 1177.1                         #ifndef TOSCT
 1177.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 1177.3                         #endif
 1177.4  00000002 3F1D                  ADDS    p, p, #4
 1177.5                                 ENDM
 1178                                   POP2x                   // UMSW  dividendHI
 1178.1  00000004 3B68                  LDR     x, [p]
 1178.2  00000006 3F1D                  ADDS    p, p, #4
 1178.3                                 ENDM
 1179                                   POP2w                   // ULSW dividendLO
 1179.1  00000008 3A68                  LDR     w, [p]
 1179.2  0000000A 3F1D                  ADDS    p, p, #4
 1179.3                                 ENDM
 1180    0000000C 0028                  CMP     t, #0           // divide by zero is divisor = 0
 1181    0000000E 0CD0                  BEQ     DZERO           // J Not Below
 1182                           // IRQ's and c routines share cstack
 1183                            IMPORT C_CMSIS_DISABLE_IRQS
 1184    00000010 ........              BL C_CMSIS_DISABLE_IRQS
 1185                            IMPORT c_64by32div             // LSW of quo in t (r0), rem in w (r2)
 1186    00000014 ........              BL      c_64by32div
 1187                            IMPORT C_CMSIS_ENABLE_IRQS
 1188    00000018 ........              BL C_CMSIS_ENABLE_IRQS       
 1189                                   DPUSH                   //  --  LSW MSW )
 1189                                   PUSHw   // push w to p, pre decrement p
 1189.1  0000001C 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1189.2  0000001E 3A60                  STR     w, [p]
 1189.3                                 ENDM
 1189                                   TPUSH
 1189                                   PUSHt   // push t to p, pre decrement p
 1189.1  00000020 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1189.2  00000022 3860                  STR     t, [p]
 1189.3                                 ENDM
 1189                                   NEXT
 1189.1  00000024 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1189                                   NEXT1
 1189.1  00000026 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1189.2  00000028 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1189.3                                 ENDM
 1189.4                                 ENDM
 1189.5                                 ENDM
 1189.6                                 ENDM
 1190                           
 1191                           DZERO:
 1192    0000002A 4040                  EORS    t, t            // zero
 1193    0000002C 401E                  SUBS    t, t, #1        // 
 1194    0000002E 0246                  MOV     w, t            // 
 1195                                   DPUSH                   //  --  LSW MSW )
 1195                                   PUSHw   // push w to p, pre decrement p
 1195.1  00000030 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1195.2  00000032 3A60                  STR     w, [p]
 1195.3                                 ENDM
 1195                                   TPUSH
 1195                                   PUSHt   // push t to p, pre decrement p
 1195.1  00000034 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1195.2  00000036 3860                  STR     t, [p]
 1195.3                                 ENDM
 1195                                   NEXT
 1195.1  00000038 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1195                                   NEXT1
 1195.1  0000003A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1195.2  0000003C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1195.3                                 ENDM
 1195.4                                 ENDM
 1195.5                                 ENDM
 1195.6                                 ENDM
 1196                           
 1197                           //:NONAME SPSTO:        ( -- ) Initialize the stack pointer from INITSO.
 1198                            SECTION .text : CONST (2)
 1199                            ALIGNROM 2,0xFFFFFFFF
 1200                           SPSTO:
 1201    00000000 ........              DC32    .+5
 1202                            SECTION .text : CODE (2)
 1203    00000000 024A                  LDR     w, = INITSO     // SYSTEM VAR BASE ADDR, Initially set to PINIT
 1204    00000002 1768                  LDR     p, [w]          // RESET PARAMETER STACK PTR
 1205                                   NEXT
 1205.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1205                                   NEXT1
 1205.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1205.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1205.3                                 ENDM
 1205.4                                 ENDM
 1206                           // LTORG
 1207                           
 1208                           //:NONAME RPSTO:        ( -- ) Initialize the return stack pointer from INITR0.
 1208.1                                  TABLE
 1208.2  0000000C ........              Reference on line 1203
 1209                            SECTION .text : CONST (2)
 1210                            ALIGNROM 2,0xFFFFFFFF
 1211                           RPSTO:
 1212    00000000 ........              DC32    .+5
 1213                            SECTION .text : CODE (2)
 1214    00000000 024A                  LDR     w, = INITRO     // SYSTEM VAR BASE ADDR, Initially set to RINIT
 1215    00000002 1668                  LDR     r, [w]          // SET RETURN STACK PTR
 1216                                   NEXT
 1216.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1216                                   NEXT1
 1216.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1216.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1216.3                                 ENDM
 1216.4                                 ENDM
 1217    0000000A 0000           LTORG
 1217.1                                  TABLE
 1217.2  0000000C ........              Reference on line 1214
 1218                           
 1219                           //:NONAME BASE_TO_R12:    ( -- ) Copy BASE to r12
 1220                            SECTION .text : CONST (2)
 1221                            ALIGNROM 2,0xFFFFFFFF
 1222                           BASE_TO_R12:
 1223    00000000 ........              DC32    .+5
 1224                            SECTION .text : CODE (2)
 1225    00000000 024A                  LDR     w, =NBASE
 1226    00000002 1168                  LDR     n, [w]
 1227    00000004 8C46                  MOV     k, n
 1228                                   NEXT
 1228.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1228                                   NEXT1
 1228.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1228.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1228.3                                 ENDM
 1228.4                                 ENDM
 1229                            LTORG
 1229.1                                  TABLE
 1229.2  0000000C ........              Reference on line 1225
 1230                            
 1231                           //:NONAME BASE_FROM_R12:    ( -- ) Set BASE from r12
 1232                            SECTION .text : CONST (2)
 1233                            ALIGNROM 2,0xFFFFFFFF
 1234                           BASE_FROM_R12:
 1235    00000000 ........              DC32    .+5
 1236                            SECTION .text : CODE (2)
 1237    00000000 024A                  LDR     w, =NBASE
 1238    00000002 6146                  MOV     n, k
 1239    00000004 1160                  STR     n, [w]
 1240                                   NEXT
 1240.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1240                                   NEXT1
 1240.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1240.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1240.3                                 ENDM
 1240.4                                 ENDM
 1241                            LTORG
 1241.1                                  TABLE
 1241.2  0000000C ........              Reference on line 1237
 1242                            
 1243                           //:NONAME STRVA:    ( -- ) GET VALUE THEN ADDR FROM NEXT 2 CELLS AND WRITE TO ADDR
 1244                           //      Use proper LABEL for values/addresses!!! EX: FPA vs FPADDR
 1245                            SECTION .text : CONST (2)
 1246                            ALIGNROM 2,0xFFFFFFFF
 1247                           STRVA:
 1248    00000000 ........              DC32    .+5
 1249                            SECTION .text : CODE (2)
 1250    00000000 02CD                  LDM     i!, {n} // GET FROM [w] TO n
 1251    00000002 04CD                  LDM     i!, {w}
 1252    00000004 1160                  STR     n, [w]
 1253                                   NEXT
 1253.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1253                                   NEXT1
 1253.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1253.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1253.3                                 ENDM
 1253.4                                 ENDM
 1254                           
 1255                           //------------------------------------------------------------------------------
 1256                           // SECTION HEADER TO RE ALIGN ALL CODE AFTER THIS INCLUDE
 1257                            SECTION .text : CONST (2)
 1258                            ALIGNROM 2,0xFFFFFFFF
 1259                           //------------------------------------------------------------------------------
   25                           // Main Include
   26                           $FISH_NXP_M0_COLD.s     // NVIC startup, PreRun Test, FISH BOOT and ISR code.
    1                           //-----------------------------------FM0_COLD-----------------------------------
    2                           
    3                            SECTION .text : CODE (2)
    4                            PUBLIC FM0_COLD
    5                           #ifdef USE_CMAIN
    8                           #endif
    9                           // No MAIN() entry point!
   10                           // :NONAME FM0_COLD ( -- ) Reset Vector entry point. Setup FISH Virtual Machine.
   11                           FM0_COLD:
   12                           
   13                           //      Set BOD (Power-up Threshold) register to max values.
   14                           //      UM 10398 3.5.26 BOD control register
   15                           
   16                           //      ldr     t, = BODCTRL            // Set power-up threshold to 2.63v
   17                           //      ldr     n, = 13h                // 10h = enable reset 3 = 2.63v
   18                           //      str     n, [t]
   19                           
   20                           // Initialize RAM
   21                           
   22    00000000 0A49                  ldr     n, = 0x11111111         // fill pattern
   23    00000002 0B48                  ldr     t, = RAM_START
   24    00000004 0B4C                  ldr     y, = DBAUD              // START OF UNINT RAM, @ END OF  CSTACK
   25                           _fillRAM:
   26    00000006 0160                  str     n, [t]
   27    00000008 001D                  adds    t, t, #4
   28    0000000A A042                  cmp     t, y
   29    0000000C FBD3                  blo     _fillRAM
   30                           
   31                           // Preserve some uninitialized RAM for system use such as MYBAUD
   32                           
   33    0000000E 0A48                  ldr     t, = ALL_UNINITRAM_END
   34    00000010 0A4C                  ldr     y, = RAM_END
   35                           _fillSTACKS:
   36    00000012 0160                  str     n, [t]
   37    00000014 001D                  adds    t, t, #4
   38    00000016 A042                  cmp     t, y
   39    00000018 FBD3                  blo     _fillSTACKS
   40                           
   41                           #ifdef USE_CMAIN
   46                           #endif
   47                           
   48    0000001A 094F                  LDR     p, =PINIT
   49    0000001C 094E                  LDR     r, =RINIT
   50    0000001E ....                  ADR     i, FM0_WARM
   51                                   PUSHi2r
   51.1  00000020 361F                  SUBS    r, r, #4        //  push i to r, pre decrement r
   51.2  00000022 3560                  STR     i, [r]
   51.3                                 ENDM
   52                                   NEXT
   52.1  00000024 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
   52                                   NEXT1
   52.1  00000026 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
   52.2  00000028 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
   52.3                                 ENDM
   52.4                                 ENDM
   53                           
   54    0000002A 0000           LTORG
   54.1                                  TABLE
   54.2  0000002C 11111111              Reference on line 22
   54.3  00000030 00000010              Reference on line 23
   54.4  00000034 400D0010              Reference on line 24
   54.5  00000038 EC0E0010              Reference on line 33
   54.6  0000003C 00100010              Reference on line 34
   54.7  00000040 F00F0010              Reference on line 48
   54.8  00000044 700F0010              Reference on line 49
   55                           
   56                           //---------------------------------FM0_WARM-------------------------------------
   57                           // :NONAME FM0_WARM ( -- ) Start up FISH interpretation, then outer interpreter.
   58                            SECTION .text : CONST (2)
   59                           FM0_WARM:
   60                           #ifdef TESTRAM
   62                           #endif
   63    00000000 ........              DC32    FWARM                   // FISH Init
   64    00000004 ........              DC32    SoCinit                 // SYSCLK, systick, MS
   65    00000008 ........              DC32    UART0_INIT    // TEMP TEST FISH_NXP_M0_81x_IRC12_9600BAUDONLY.s
   66    0000000C ........              DC32    CR
   67                           WTEST:  // TEST CODE GOES HERE
   68                           //        DC32    ILA
   69                           //        DC32    DOTS            // SHOW ANY STACK ARTIFACTS HERE
   70                                   // TEST CODE END
   71    00000010 ........FB000         DC32    LIT, 0xFB, EMIT // ANSI ASCII CheckMark
                  000........  
   72    0000001C ........F7000         DC32    LIT, 0xF7, EMIT // ANSI ASCII 2 wavy's
                  000........  
   73    00000028 ........              DC32    COLD    // WARM ABORT THEN QUIT
   74                           #ifdef USE_CMAIN
   76                           #endif
   77                           //------------------------ for meta-single-stepping ----------------------------
   78                           //:NONAME ssNEXT ( -- ) System Internal hi level breakpoint.
   79                            SECTION .text : CODE (2)
   80                            ALIGNROM 2,0xFFFFFFFF
   81                           ssNEXT1:
   82    00000000 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
   83    00000002 9F46                  MOV     pc, x           // w preserves cfa+4 (pfa) for DOCOL's benefit
   84                           
   85                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h !
   86                           
   87                           // If BX not ued here and in SUBR's OR LDR t, 7 vs LDR t, =7 CAUSES:
   88                           // Error[Lp002]: relocation failed: value out of range or illegal: 0xfffff457 
   89                           
   90                           // #define required for #if / #ifdef in M0!!!
   91                           // DC32 .+5 or 10...
   92                           //#define ast
   93                            PUBLIC FM0_SYSTICK_ISR
   94                            SECTION .text : CODE (2)
   95                            ALIGNROM 2,0xFFFFFFFF
   96                           FM0_SYSTICK_ISR:
   97                           #ifdef ast      // this is asm prim #else is hi level
  122                           #else
  123                           // Start of the Hi-Level WORD ISR Test------------------------------------------
  124                           
  125                           // Exceptions show mostly this:
  126                           // R12 = BASE
  127                           // R11 & R1 (n) = 10000010 b DICTSPACE_START
  128                           // R10 & R0 (t) = 00003BC7 Close to LR value in Debugger upon entry!!!
  129                           
  130                           // R6 (r) = 7FFFFFFC Typically
  131                           // R7 (s) = 0 Typically
  132                           
  133                           // ST CTR ? ST ? NOT WORD OR NUMBER   ok, go fish in BASE []
  134                           // Multiple CR exceptions simular, it stops at      ^^^^^^^ !!!!
  135                           // Implicating PFIND and BASE_TO_R12/BASE_FROM_R12  !!!!!!!!!!!!!!!
  136                           
  137                           
  138                           // The Hi-Level WORD ISR Pre amble.
  139                            SECTION .text : CODE (2)
  140                            ALIGNROM 2,0xFFFFFFFF
  141                           DOCOL_ISR:
  142                           // needed!        PUSH    { r0-r5, r10-r12, lr }
  143    00000000 3FB5                  PUSH    {r0-r5, lr }
  144    00000002 5046                  MOV     r0, r10
  145    00000004 5946                  MOV     r1, r11
  146    00000006 6246                  MOV     r2, r12
  147    00000008 07B4                  PUSH    {r0-r2}
  148                           
  149    0000000A 014A                  LDR     w, [PC, #0X4] //= MY_LTORG The High Level Target
  150                                   NEXT1   // -> SEMIS_ISR RETURN required instead of SEMIS!
  150.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  150.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  150.3                                 ENDM
  151                           
  152                           // LTORG
  153                           // The Hi-Level WORD ISR Post amble.
  154                            SECTION .text : CONST (2)
  155                            ALIGNROM 2,0xFFFFFFFF
  156    00000000 ........              DC32    NONAME_STCTR_INCR
  157                           MY_LTORG_ISR_SEMIS:
  158    00000004 ........              DC32    .+5 // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  159                            SECTION .text : CODE (2)
  160                                   POPr2i  // SEMIS to balance DOCOL!!!
  160.1  00000000 3568                  LDR i, [r]              //  pop r to i, post increment r
  160.2  00000002 361D                  ADDS    r, r, #4
  160.3                                 ENDM
  161                           // needed!        POP     { r0-r5, r10-r12, pc }
  162    00000004 07BC                  POP     {r0-r2}
  163    00000006 8246                  MOV     r10, r0
  164    00000008 8B46                  MOV     r11, r1
  165    0000000A 9446                  MOV     r12, r2
  166    0000000C 3FBD                  POP     {r0-r5, pc }
  167                           
  168                           // The test Hi-Level target WORD.
  169                            SECTION .text : CONST (2)
  170                            ALIGNROM 2,0xFFFFFFFF
  171                           NONAME_STCTR_INCR:
  172    00000000 ........              DC32    DOCOL
  173    00000004 .............         DC32    ONE, STCTR, PSTORE      // Incr STICKER
                  ...........  
  174                           //        DC32    STCTR, QUES   // Works showing longer execution can be done.
  175                           //        DC32    DOTSHEX, CR
  176    00000010 ........              DC32    MY_LTORG_ISR_SEMIS
  177                           // End of the Hi-Level WORD ISR Test--------------------------------------------
  178                           // NOTE: LTORG manual in this section!
  179                           #endif
  180                           
  181                           
  182                           /*
  183                           //:NONAME ILA
  184                            SECTION .text : CONST (2)
  185                            ALIGNROM 2,0xFFFFFFFF
  186                           ILA:
  187                                   DC32    DOCOL
  188                                   DC32    NOOP
  189                           //      DC32    ASM_START       // HW ISSUE
  190                           //      NOP
  191                           //      DC32    ASM_END
  192                                   DC32    SEMIS
  193                           */
   27                           $FISH_NXP_M0_MEMMAP.s   // The FISH System Ram Definitions
    1                           // FISH_NXP_M0_SYSTEM.s
    2                           //------------------------------------------------------------------------------
    3                           // FISH FORTH for the NXP ARM Cortex M0 series SystemsOnaChip (SoC).
    4                           // Tested: NXP UM11049 board and NXP LPC1114FD/102 chip with 32kFlash and 4kRam.
    5                           //      RESERVE SPACE FOR FISH SYSTEM VARS AND BUFFERS IN .bss
    6                           
    7                              SECTION FISH_Ram_MemMap : DATA (2)
    8                           // RAM_START and RAM_END defined in FISH_M0_EQUATES.H
    9                           SYSCLOCK        DS32    1               // MUST BE SET AT STARTUP = FULL MHZ #
   10                           FPA:            DS32    1               // FPADDR 0 = NO FLASH AVAILABLE
   11                           FPC:            DS32    1               // FPCURR
   12                           FPSV:           DS32    1               // FP System VAR
   13                           // The above 4 words are the SIGNATURE for saved code in a flash pages.
   14                           // The FISH Dictionary starts 0x10 bytes after RBASE (RAMstart)
   15                           
   16                           DICTSPACE_START:
   17                           #ifdef NXP_M0_004kRam
   18                           ORIG:           DS8     2600            // Dictionary at beginning of RAM
   19                           DICTSPACE_END:                          // For DICTSPACE calculation
   20                           #endif
   21                           #ifdef NXP_M0_008kRam
   24                           #endif
   25                           
   26                           PAD:            DS8     IOBUFSIZE       // +4 to protect following VAR's
   27                           TIB:            DS8     IOBUFSIZE       // +4 to protect following VAR's
   28                           STICKER:        DS32    1               // SYSTICK INTERRUPT ACCUMULATOR
   29                           
   30                           RAMVARSPACE_START:
   31                           RAMVARSPACE:    DS8     24*4            // VAR's are in RAM
   32                                                   // For VARSPACE calculation
   33                            ALIGNRAM 2
   34                           // REARRANGE LATER FOR TASKING AND SIZE BASED OFFSETS!!
   35                           // ZERO
   36                           END_RAMVARSPACE_SV_START:
   37                           // BYTE VALUES
   38                           NBASE:          DS32    1       // BASE_SV for number conversion
   39                           IN:             DS32    1       // IN_SV Offset into tib
   40                           OUT:            DS32    1       // OUT_SV Offset into pad
   41                           CSTATE:         DS32    1       // STATE_SV Compile STATE
   42                           // ADDRESS VALUES
   43                           INITSO:         DS32    1       // INITS0_SV Parameter Stack Addr
   44                           INITRO:         DS32    1       // INITR0_SV Return Stack Addr
   45                           INITTIB:        DS32    1       // TIB_SV TIB Addr
   46                           UP:             DS32    1       // UP_SV See VARALLOT
   47                           DP:             DS32    1       // DP_SV IS See LATEST, COMMA, ALLOT AND CALLOT
   48                           CSDP            DS32    1       // Create saves DP here to restore if errors 
   49                           FENCE:          DS32    1       // FENCE_SV See FORGET
   50                           CURRENT:        DS32    1       // CURRENT_SV See LATEST
   51                           PROMPT:         DS32    1       // Init in FWARM TO msg_MY_OK, $ OR 0 (QUIT)!
   52                           ERROR_HALT:     DS32    1       // Init in FWARM - ERROR, ABORT and COLD
   53                           // THESE ARE INITIALIZED WHEN USED AT RUN-TIME
   54                           CSP:            DS32    1       // CSP_SV SCSP saves stack pos here
   55                           NDPL:           DS32    1       // DPL_SV for number conversion
   56                           NHLD:           DS32    1       // HLD_SV for number conversion
   57                           // BUFFERS
   58                           // 0x1FFF1FF1      // Call Address of IAP routine
   59                           FLASHCMD:       DS32    4*5     // IAP Command Slot + 4 words of arguments
   60                           FLASHRET:       DS32    4*4     // IAP Results Slot + 3 words of arguments
   61                           I2CCMD:         DS32    1       // 
   62                           I2CROLE:        DS32    1       // 
   63                           I2CSTATE:       DS32    1       // 
   64                           I2CBUFFER:      DS8     12      //
   65                           SV_END:
   66                           // BE CAREFUL: Uninitialized RAM is between CSTACK$$Limit and END_RAMVARSPACE-4
   67                           
    3                           //------------------------------------------------------------------------------
    4                           
    5                           // 2DO: Add VIO_UARTX, VIO_KEY, VIO_?KEY and VIO_EMIT
    6                           // (EMIT), (KEY?), and (KEY).
    7                           
    8                           // v1.7:
    9                           
   10                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
   11                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
   12                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   13                           
   14                           // Signon updated. (FOR TEST - FIX B4 SHIP)
   15                           // 2DO: Updated .hex .out and sym.bat
   16                           
   17                           // Split out files to FISH_RM_COMMON and FISH_RM_COMMON_CODE_CORTEX_M
   18                           
   19                           // ADDED EHON and EHOFF to FISH RM
   20                           // Changes iar.s COLD, ERROR and ABORT
   21                           // Changes FISH_STM32F4_SLIB.s SV_INIT_VALUES: & FWARM:
   22                           // Adds 1 word to FISH_STM32F4_MEMMAP.s - ERROR_HALT: SV 
   23                           
   24                           // ADDED P(PROMPT), PON(PROMPTON) and POFF(PROMPTOFF) to FISH RM
   25                           // Changes FISH_NXP_M0_SLIB.s SV_INIT_VALUES: & FWARM: & QUIT:
   26                           // Adds 1 word to FISH_NXP_M0_SYSTEM.s - PROMPT: SV 
   27                           
   28                           // Added #define TRUE_EQU_NEG_ONE
   29                           // Changed all user visible true flags to -1
   30                           
   31                           // Added SXTB Rd, Rm  and SXTH Rd, Rm
   32                           
   33                           // Number Stuff Wordcat reorganized (search NOEXEC or WC_NUMBERS_NFA)
   34                           // EXPECT does counted null strings:
   35                           // NUMBER to look for null terminatiion instead of BLANK.
   36                           // WORD changed to expect null string and elimated BLANKS fill of HERE.
   37                           //      SPEEDS UP TOKENIZATION OF TIB INPUT!
   38                           // ALL IN AND IN_SV INIT SET TO 1 in QUERY SV_INIT_VALUES CLRTIB
   39                           // NUMBERSUFFIX changed to replace suffix with null
   40                           // PAREN ( changed to use TIB+1
   41                           // DPL restored to dictionairy.
   42                           // FISH DATE AND TIMESTAMP removed from SRM to allow for DPL
   43                           
   44                           // FISH ARM V1.6:
   45                           // Added LPC1115 64X8 Configuration.
   46                           // Added any key escape from DUMP
   47                           
   48                           // FISH ARM DebugSrc V1.5.4:
   49                           // CONTSANT, VARIABLE and EXECUTE fit in SRM.
   50                           
   51                           // FISH ARM DebugSrc V1.5.3:
   52                           // CREATE for DOES>
   53                           // IRQS_SUSPEND/RESUME for FLASH_SAVE and FLASH_FORGET
   54                           // BASE in prompt restored.
   55                           
   56                           // FISH ARM DebugSrc V1.5.2:
   57                           // FIXED FLASH_SAVE/SCAN STACK LEAVINGS
   58                           //
   59                           // 
   60                           //------------------------------------------------------------------------------
   61                           // START OF SIGNON MESSAGE
   62                            SECTION .text : CONST (2)
   63                           msg_FISH:
   64                           // DC8 "?" IS A NULL TERMINATED STRING
   65                           // DC8 '?' IS NOT
   66                           //      DC8     'FISH ARM'
   67    00000000 4649534820415         DC8     'FISH ARM Hi-Level ISR Test!!!'
                  24D2048692D4C
                  6576656C20495
                  3522054657374
                  212121       
   68                           //------------------------------------------------------------------------------
   69                           // CHIP FLASH and RAM DESIGNATION
   70                           #ifdef  NXP_M0_812
   72                           #endif
   73                           #if     NXP_M0_11xx & NXP_M0_004kRam
   74    0000001D 204C504331313         DC8     ' LPC111x 32x4 '
                  1782033327834
                  20           
   75                           #endif
   76                           #if     NXP_M0_11xx & NXP_M0_008kRam
   78                           #endif
   79                           #if     NXP_M0_1115 & NXP_M0_008kRam & NXP_M0_064kFlash_4KWrite
   81                           #endif
   82                           //------------------------------------------------------------------------------
   83                           // FISH MODEL
   84                           //      DC8     'RM DebugSrc V1.6.1 : '
   85                           #if     FISH_PubRel_WORDSET 
   86    0000002B 524D20                DC8     'RM '
   87                           #endif  // FISH_PubRel_WORDSET
   88                           #if     FISH_NXP_M0_PRO_WORDCAT
   90                           #endif
   91                           #if     SRM
   93                           #endif
   94                           #if     FISH_Debug_WORDSET
   96                           #endif
   97                           //------------------------------------------------------------------------------
   98                           // FISH Version
   99    0000002E 56312E37              DC8     'V1.7'
  100                           //------------------------------------------------------------------------------
  101                           // FISH COPYRIGHT AND TEAM
  102    00000032 2028432932303         DC8     ' (C)2014-2015 A-TEAM FORTH : '
                  1342D32303135
                  20412D5445414
                  D20464F525448
                  203A20       
  103                           //------------------------------------------------------------------------------
  104                           #ifndef SRM
  105                           // FISH DATE AND TIMESTAMP
  106    0000004F 4F63742031362         DC8     __DATE__        // Null terminated string
                  03230323300  
  107                           msg_FISH_TIMESTAMP:
  108    0000005B 20617420              DC8     ' at '
  109    0000005F 31383A31303A3         DC8     __TIME__        // Null terminated string
                  03500        
  110                           #endif
  111                           #ifdef EOL_DLE
  112                           msg_SIGNON_DLE:
  113    00000068 1000                  DC8     0x10, 0
  114                           #endif
  115                           
  116                           // END OF SIGNON MESSAGE
  117                           //------------------------------------------------------------------------------
  118                           
  119                           //------------------------------------------------------------------------------
  120                           // FISH PROMPT
  121                           msg_MY_OK:
  122    0000006A 206F6B2C20676         DC8     " ok, go fish in BASE "
                  F206669736820
                  696E204241534
                  52000        
  123                           //------------------------------------------------------------------------------
  124                           
  125                           
  126                           //-----------------START OF DICTIONARY = Last word in search--------------------
  127                           //      NOOP NOOP:      ( -- )
  128                            SECTION .text : CONST (2)
  129                           NOOP_NFA:
  130    00000000 84                    DC8     0x84
  131    00000001 4E4F4F                DC8     'NOO'
  132    00000004 D0                    DC8     'P'+0x80
  133    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  134    00000008 00000000              DC32    0       // 0 START OF DICTIONARY = Last word in search
  135                           NOOP:
  136                           ///* mixed asm hi lvel test
  137    0000000C ........              DC32    DOCOL
  138                           // This need to point to the +5?
  139    00000010 ........              DC32    ASM_NOOP_1     // . worked to get started
  140                           ASM_NOOP_1:
  141    00000014 ........              DC32    .+5
  142                            SECTION .text : CODE (2)
  143    00000000 00BF                  NOP
  144    00000002 024D                  LDR     i, =ASM_NOOP_2
  145                                   NEXT    // or TPUSH or DPUSH
  145.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  145                                   NEXT1
  145.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  145.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  145.3                                 ENDM
  145.4                                 ENDM
  146                           // fix alignment !
  146.1                                  TABLE
  146.2  0000000C ........              Reference on line 144
  147                            SECTION .text : CONST (2)
  148                           ASM_NOOP_2:
  149    00000000 ........              DC32    SEMIS
  150                           //*/
  151                           /* Oroginal
  152                                   DC32    .+5
  153                            SECTION .text : CODE (2)
  154                                   NOP
  155                                   NEXT
  156                           */
  157                           
  158                           //      EXECUTE EXEC:   ( cfa -- ) RENAMED: EXECUTE to EXEC
  159                           //      Execute a single word whose cfa is on the stack
  160                           
  161                            SECTION .text : CONST (2)
  162                           EXEC_NFA:
  163    00000000 87                    DC8     0x87
  164    00000001 455845435554          DC8     'EXECUT'
  165    00000007 C5                    DC8     'E'+0x80
  166                            ALIGNROM 2,0xFFFFFFFF
  167    00000008 ........              DC32    NOOP_NFA
  168                           EXEC:
  169    0000000C ........              DC32    .+5
  170                            SECTION .text : CODE (2)
  171                           #ifdef XON_XOFF
  172    00000000 ........              BL      TXRDY_SUBR
  173    00000004 ........              BL      XOFF_SUBR
  174                           #endif  // XON_XOFF
  175                                   POPp2w // as in xeq token at ToS setup for exec LDM     p!, {w}
  175.1                                 // as in xeq token at ToS setup for exec
  175.2  00000008 04CF                  LDM     p!, {w} // fetch memory p points to into {w}, inc p
  175.3                                 ENDM
  176                                   NEXT1
  176.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  176.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  176.3                                 ENDM
  177                           
  178                           
  179                           // TXRDY_SUBR:
  180                            SECTION .text : CODE (2)
  181                           TXRDY_SUBR:
  182    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  183                           
  184                           #if     NXP_M0_11xx | NXP_M0_1115
  185    00000002 024C                  LDR     y, = U0LSR      // Line Status Register
  186                           #endif  // NXP_M0_11xx
  187                           
  188                           #ifdef NXP_M0_812
  190                           #endif  // NXP_M0_812
  191                           
  192                           txRDY?:
  193    00000004 2168                  LDR     n, [y]          // Get Line Status
  194                           //------------------------------------------------------------------------------
  195                           #if     NXP_M0_11xx | NXP_M0_1115
  196    00000006 8909                  LSRS    n, n, #6        // 7 = TX BUF EMPTY 6 = TX HOLD REG EMPTY
  197                           #endif  // NXP_M0_11xx
  198                           #ifdef NXP_M0_812
  200                           #endif  // NXP_M0_812
  201                           //------------------------------------------------------------------------------
  202    00000008 FCD3                  BCC     txRDY?          // Ready
  203    0000000A 1047                  BX      w       //lr              // SUBR RETURN
  204                           
  205                           // XOFF_SUBR:
  206                           #ifdef XON_XOFF
  206.1                                  TABLE
  206.2  0000000C 14800040              Reference on line 185
  207                            SECTION .text : CODE (2)
  208                           XOFF_SUBR:
  209    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  210                           //------------------------------------------------------------------------------
  211                           #if     NXP_M0_11xx | NXP_M0_1115
  212    00000002 0249                  LDR     n,= U0RBRTHR
  213                           #endif  // NXP_M0_11xx
  214                           #ifdef NXP_M0_812
  216                           #endif  // NXP_M0_812
  217                           //------------------------------------------------------------------------------
  218    00000004 1324                  LDR     y,  = XOFF_CHAR
  219    00000006 0C70                  STRB    y, [n]
  220    00000008 1047                  BX      w       //lr              // SUBR RETURN
  221                           #endif // XON_XOFF
  222                           
  223                           // XON_SUBR:
  224                           #ifdef XON_XOFF
  224.1                                  TABLE
  224.2  0000000C 00800040              Reference on line 212
  225                            SECTION .text : CODE (2)
  226                           XON_SUBR:
  227    00000000 7246                  MOV     w, lr           // Allow for interrupts to use LR
  228                           //------------------------------------------------------------------------------
  229                           #if     NXP_M0_11xx | NXP_M0_1115
  230    00000002 0249                  LDR     n, = U0RBRTHR
  231                           #endif  // NXP_M0_11xx
  232                           #ifdef NXP_M0_812
  234                           #endif  // NXP_M0_812
  235                           //------------------------------------------------------------------------------
  236                           // XON:
  237    00000004 1124                  LDR     y, = XON_CHAR   // preserve TOS 11 24 01 49
  238    00000006 0C70                  STRB    y, [n]
  239    00000008 1047                  BX      w       //lr              // SUBR RETURN
  240                           #endif // XON_XOFF
  241    0000000A 0000           LTORG
  241.1                                  TABLE
  241.2  0000000C 00800040              Reference on line 230
  242                           
  243                           //      BL BLANK:       ( -- n )
  244                           //      Push ascii space character as n to TOS.
  245                           
  246                            SECTION .text : CONST (2)
  247                           BLANK_NFA:
  248    00000000 82                    DC8     0x82
  249    00000001 42                    DC8     'B'
  250    00000002 CC                    DC8     'L'+0x80
  251    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  252    00000004 ........              DC32    EXEC_NFA
  253                           BLANK:
  254    00000008 ........              DC32    DOCOL
  255                           //        DC32    NOOP
  256    0000000C ........              DC32    ASM_ENTRY_1     // . worked to get started
  257                           ASM_ENTRY_1:
  258    00000010 ........              DC32    .+5
  259                            SECTION .text : CODE (2)
  260    00000000 034D                  LDR     i, =ASM_EXIT_1
  261    00000002 2020                  LDR     t, =0x20
  262                                   TPUSH
  262                                   PUSHt   // push t to p, pre decrement p
  262.1  00000004 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  262.2  00000006 3860                  STR     t, [p]
  262.3                                 ENDM
  262                                   NEXT
  262.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  262                                   NEXT1
  262.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  262.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  262.3                                 ENDM
  262.4                                 ENDM
  262.5                                 ENDM
  263                           // fix alignment !
  263.1                                  TABLE
  263.2  00000010 ........              Reference on line 260
  264                            SECTION .text : CONST (2)
  265                           ASM_EXIT_1:
  266    00000000 ........              DC32    SEMIS
  267                                   
  268                           //        DC32    DOCON, 0x20
  269                                   
  270                           
  271                           
  272                           //========================= START SYSTEM VARIABLES ===========================//
  273                           // _SV IS cfa label of WORD's that return their address.
  274                           // MODIFIED ALL to be label based vs. offset based.
  275                           
  276                           
  277                           //      UP UP_SV:       ( -- addr of UP ) Value stored here is ALIGNED
  278                           //      A system variable, the RAM VAR pointer, which contains
  279                           //      the address of the next free memory above in the USERRAMSPACE.
  280                           //      The value may be read by .UV and altered by VAR.
  281                           
  282                            SECTION .text : CONST (2)
  283                           UP_NFA:
  284    00000000 82                    DC8     0x82
  285    00000001 55                    DC8     'U'
  286    00000002 D0                    DC8     'P'+0x80
  287    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  288    00000004 ........              DC32    BLANK_NFA
  289                           UP_SV:
  290    00000008 .............         DC32    DOCON, UP
                  ...          
  291                           
  292                           
  293                           //      FENCE FENCE_SV: ( -- addr of FENCE )
  294                           //      A system variable containing an address below which FORGET ting is
  295                           //      trapped. To forget below this point the system must alter the contents
  296                           //      of FENCE.
  297                           
  298                            SECTION .text : CONST (2)
  299                           FENCE_NFA:
  300    00000000 85                    DC8     0x85
  301    00000001 46454E43              DC8     'FENC'
  302    00000005 C5                    DC8     'E'+0x80
  303    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  304    00000008 ........              DC32    UP_NFA
  305                           FENCE_SV:
  306    0000000C .............         DC32    DOCON, FENCE
                  ...          
  307                           
  308                           
  309                           //      DP DP_SV:       ( -- addr of DP ) Value stored here is ALIGNED
  310                           //      A system variable, the dictionary pointer, which contains the address
  311                           //      of the next free memory above the dictionary. The value may be read
  312                           //      by HERE and altered by COMMA (ALIGNED) , ALLOT and CALLOT (UNALIGNED) .
  313                           
  314                            SECTION .text : CONST (2)
  315                           DP_NFA:
  316    00000000 82                    DC8     0x82
  317    00000001 44                    DC8     'D'
  318    00000002 D0                    DC8     'P'+0x80
  319    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  320    00000004 ........              DC32    FENCE_NFA
  321                           DP_SV:
  322    00000008 .............         DC32    DOCON, DP
                  ...          
  323                           
  324                           
  325                           //      BASE BASE_SV:   ( -- addr of NBASE )
  326                           //      A system variable containing the current number base used for input
  327                           //      and output conversion.
  328                           
  329                            SECTION .text : CONST (2)
  330                           BASE_NFA:
  331    00000000 84                    DC8     0x84
  332    00000001 424153                DC8     'BAS'
  333    00000004 C5                    DC8     'E'+0x80
  334    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  335    00000008 ........              DC32    DP_NFA
  336                           BASE_SV:
  337    0000000C .............         DC32    DOCON, NBASE
                  ...          
  338                           
  339                           
  340                           //      CURRENT CURRENT_SV:     ( -- addr of CURRENT )
  341                           //      CURRENT searched everytime. CONTEXT is not used
  342                           //      Used by Create, Definitions, etc and by Latest
  343                           //      to leave the nfa of the topmost word in the CURRENT
  344                           //      vocabulary.  See LATEST NOTE:(FIG) CURR @ @ this CURR @
  345                           
  346                            SECTION .text : CONST (2)
  347                           CURRENT_NFA:
  348    00000000 87                    DC8     0x87
  349    00000001 43555252454E          DC8     'CURREN'
  350    00000007 D4                    DC8     'T'+0x80
  351                            ALIGNROM 2,0xFFFFFFFF
  352    00000008 ........              DC32    BASE_NFA
  353                           CURRENT_SV:
  354    0000000C .............         DC32    DOCON, CURRENT  // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
                  ...          
  355                           
  356                           
  357                           //      STATE STATE_SV: ( -- addr of CSTATE )
  358                           //      A system variable containing the compilation state. A non-zero value
  359                           //      indicates compilation. The value itself may be implementation
  360                           //      dependent. 0xC0 must be used for INTERPRET to execute IMMEDIATE words.
  361                           
  362                            SECTION .text : CONST (2)
  363                           STATE_NFA:
  364    00000000 85                    DC8     0x85
  365    00000001 53544154              DC8     'STAT'
  366    00000005 C5                    DC8     'E'+0x80
  367    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  368    00000008 ........              DC32    CURRENT_NFA
  369                           STATE_SV:
  370    0000000C .............         DC32    DOCON, CSTATE       //Compile STATE
                  ...          
  371                           
  372                           
  373                           //      OUT OUT_SV:     ( --  addr of OUT )
  374                           //      A system variable that contains a value incremented by EMIT. The system
  375                           //      may alter and examine OUT to control display formating.
  376                           
  377                            SECTION .text : CONST (2)
  378                           OUT_NFA:
  379    00000000 83                    DC8     0x83
  380    00000001 4F55                  DC8     'OU'
  381    00000003 D4                    DC8     'T'+0x80
  382                            ALIGNROM 2,0xFFFFFFFF
  383    00000004 ........              DC32    STATE_NFA
  384                           OUT_SV:
  385    00000008 .............         DC32    DOCON, OUT
                  ...          
  386                           
  387                           
  388                           //      IN IN_SV:       ( -- addr of IN )
  389                           //      A system variable containing the byte offset within (TIB),
  390                           //      from which the tokens are parsed by WORD and moved to HERE,
  391                           //      as a counted null terminated string (created by EXPECT).
  392                           //      Initialized to 1 to skip count byte produced by EXPECT.
  393                           
  394                            SECTION .text : CONST (2)
  395                           IN_NFA:
  396    00000000 82                    DC8     0x82
  397    00000001 49                    DC8     'I'
  398    00000002 CE                    DC8     'N'+0x80
  399    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  400    00000004 ........              DC32    OUT_NFA
  401                           IN_SV:
  402    00000008 .............          DC32   DOCON, IN
                  ...          
  403                           
  404                           
  405                           //      PAD PAD_SV:     ( -- addr of PAD )
  406                           //      Leave the address of the text output buffer PAD on the stack.
  407                           //      Typically at least 82 bytes long.
  408                           
  409                            SECTION .text : CONST (2)
  410                           PAD_NFA:
  411    00000000 83                    DC8     0x83
  412    00000001 5041                  DC8     'PA'
  413    00000003 C4                    DC8     'D'+0x80
  414                            ALIGNROM 2,0xFFFFFFFF
  415    00000004 ........              DC32    IN_NFA
  416                           PAD_SV:
  417    00000008 .............         DC32    DOCON, PAD
                  ...          
  418                           
  419                           
  420                           //      TIB TIB_SV:     ( -- addr of INITTIB )
  421                           //      Leave the address of the text input buffer TIB on the stack.
  422                           //      Typically at least 82 bytes long.
  423                           
  424                            SECTION .text : CONST (2)
  425                           TIB_NFA:
  426    00000000 83                    DC8     0x83
  427    00000001 5449                  DC8     'TI'
  428    00000003 C2                    DC8     'B'+0x80
  429                            ALIGNROM 2,0xFFFFFFFF
  430    00000004 ........              DC32    PAD_NFA
  431                           TIB_SV:
  432    00000008 .............         DC32    DOCON, TIB
                  ...          
  433                           
  434                           
  435                           //======================== END SYSTEM VARIABLES ==============================//
  436                           
  437                           
  438                           //      HERE HERE:      ( -- addr ) Value stored here is ALIGNED
  439                           //      Leave the address of the next available dictionary location.
  440                           
  441                            SECTION .text : CONST (2)
  442                           HERE_NFA:
  443    00000000 84                    DC8     0x84
  444    00000001 484552                DC8     'HER'
  445    00000004 C5                    DC8     'E'+0x80
  446    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  447    00000008 ........              DC32    TIB_NFA
  448                           HERE:
  449    0000000C ........              DC32    DOCOL
  450    00000010 ........              DC32    DP_SV
  451    00000014 ........              DC32    AT
  452    00000018 ........              DC32    SEMIS
  453                           
  454                           
  455                           //      ALLOT ALLOT:    ( sn -- ) Warning: UNALIGNED:
  456                           //      IF DICTIONAIRY FULL PRINT error MESSAGE AND abort.
  457                           //      Add the signed number to the dictionary pointer DP. May be used to
  458                           //      reserve dictionary space or re-origin memory.
  459                           //      CAUTION!
  460                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  461                           //      NOTE: USE ALIGN32_FF_PAD after ALLOT or C, (CCOMMA) .
  462                           
  463                            SECTION .text : CONST (2)
  464                           ALLOT_NFA:
  465    00000000 85                    DC8     0x85
  466    00000001 414C4C4F              DC8     'ALLO'
  467    00000005 D4                    DC8     'T'+0x80
  468    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  469    00000008 ........              DC32    HERE_NFA
  470                           ALLOT:
  471    0000000C ........              DC32    DOCOL
  472    00000010 ........              DC32    DICTSPACE       // ( -- n )
  473    00000014 .............         DC32    OVER, SUBB
                  ...          
  474    0000001C ........              DC32    ZLESS
  475    00000020 ........              DC32    ZBRAN
  476    00000024 08000000              DC32    ALLOTOK-.
  477                           
  478    00000028 ........              DC32    DICTFULL_ABORT
  479                           
  480                           ALLOTOK:
  481    0000002C ........              DC32    DP_SV
  482    00000030 ........              DC32    PSTORE
  483    00000034 ........              DC32    SEMIS
  484                           
  485                           
  486                           //      ALIGNED ALIGNED:        ( addr -- a-addr ) DPANS94
  487                           
  488                            SECTION .text : CONST (2)
  489                           ALIGNED_NFA:
  490    00000000 87                    DC8     0x87
  491    00000001 414C49474E45          DC8     'ALIGNE'
  492    00000007 C4                    DC8     'D'+0x80
  493                            ALIGNROM 2,0xFFFFFFFF
  494    00000008 ........              DC32    ALLOT_NFA
  495                           ALIGNED:
  496    0000000C ........              DC32    .+5
  497                            SECTION .text : CODE (2)
  498                                   POP2t
  498.1                         #ifndef TOSCT
  498.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  498.3                         #endif
  498.4  00000002 3F1D                  ADDS    p, p, #4
  498.5                                 ENDM
  499    00000004 C01C                  ADDS    t, t, #3
  500    00000006 0349                  LDR     n, =-4
  501    00000008 0840                  ANDS    t, t, n
  502                                   TPUSH
  502                                   PUSHt   // push t to p, pre decrement p
  502.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  502.2  0000000C 3860                  STR     t, [p]
  502.3                                 ENDM
  502                                   NEXT
  502.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  502                                   NEXT1
  502.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  502.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  502.3                                 ENDM
  502.4                                 ENDM
  502.5                                 ENDM
  503                            LTORG
  503.1                                  TABLE
  503.2  00000014 FCFFFFFF              Reference on line 500
  504                           
  505                           
  506                           //      ALIGN32_FF_PAD ALIGN:   ( -- ) DPANS94
  507                           //      Align DP_SV primitive. Pads current DP with 0xFF until aligned.
  508                           //      USED in , (COMMA:) .  Reflected by HERE .
  509                           //      CAUTION! USE AFTER ALLOT or C, (CCOMMA:) .
  510                           //      See , (COMMA:) which is ALIGNED.
  511                           
  512                            SECTION .text : CONST (2)
  513                           ALIGN_NFA:
  514    00000000 85                    DC8     0x85
  515    00000001 414C4947              DC8     'ALIG'
  516    00000005 CE                    DC8     'N'+0x80
  517    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  518    00000008 ........              DC32    ALIGNED_NFA
  519                           ALIGN32_FF_PAD:
  520    0000000C ........              DC32    DOCOL
  521    00000010 ........              DC32    HERE
  522                                   // COULD ADD CODE TO SEE IF ALIGNED ALREADY
  523    00000014 .............         DC32    THREE, PLUS             // 3PLUS
                  ...          
  524    0000001C .............         DC32    DUP, TOR
                  ...          
  525    00000024 ........              DC32    HERE
  526    00000028 ........              DC32    XDO
  527                           ALIGN_PAD_DO:
  528    0000002C ........FF000         DC32    LIT, 0xFF, I, CSTORE
                  000..........
                  ......       
  529    0000003C ........              DC32    XLOOP
  530    00000040 ECFFFFFF              DC32    ALIGN_PAD_DO-.
  531                           
  532    00000044 ........              DC32    RFROM
  533    00000048 ........FCFFF         DC32    LIT, 0xFFFFFFFC // -4
                  FFF          
  534    00000050 ........              DC32    ANDD
  535    00000054 .............         DC32    DP_SV, STORE
                  ...          
  536    0000005C ........              DC32    SEMIS
  537                           
  538                           
  539                           //      , COMMA:        ( n -- ) ALIGNED
  540                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  541                           //      Write n into next ALIGNED dictionary memory cell, DP reflected by HERE
  542                           
  543                            SECTION .text : CONST (2)
  544                           COMMA_NFA:
  545    00000000 81                    DC8     0x81
  546    00000001 AC                    DC8     ','+0x80
  547    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  548    00000004 ........              DC32    ALIGN_NFA
  549                           COMMA:
  550    00000008 ........              DC32    DOCOL
  551    0000000C ........              DC32    DICTSPACE       //      ( -- n )
  552    00000010 ........              DC32    ZLESS
  553    00000014 ........              DC32    ZBRAN
  554    00000018 08000000              DC32    COMMA_OK-.
  555                           
  556    0000001C ........              DC32    DICTFULL_ABORT
  557                           
  558                           COMMA_OK:
  559    00000020 ........              DC32    COMMA_PRIM
  560    00000024 ........              DC32    SEMIS
  561                           
  562                           
  563                           //      C, CCOMMA:      ( n -- ) Warning: UNALIGNED:
  564                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
  565                           //      Store LS 8 bits of n into the next available dictionary byte, advancing
  566                           //      the dictionary pointer.
  567                           //      CAUTION!
  568                           //      ALLOT and C, (CCOMMA:) ARE THE ONLY WORDS THAT CAN ALLOT UNEVEN AMOUNTS
  569                           //      NOTE: USE ALIGN32_FF_PAD after ALLOT or C, (CCOMMA) .
  570                           //      See , (COMMA:) which is ALIGNED.
  571                           
  572                            SECTION .text : CONST (2)
  573                           CCOMMA_NFA:
  574    00000000 82                    DC8     0x82
  575    00000001 43                    DC8     'C'
  576    00000002 AC                    DC8     ','+0x80
  577    00000003 FF             ALIGNROM 2,0xFFFFFFFF
  578    00000004 ........              DC32    COMMA_NFA
  579                           CCOMMA:
  580    00000008 ........              DC32    DOCOL
  581    0000000C ........              DC32    DICTSPACE       //      ( -- n )
  582    00000010 ........              DC32    ZLESS
  583    00000014 ........              DC32    ZBRAN
  584    00000018 08000000              DC32    CCOMMA_OK-.
  585                           
  586    0000001C ........              DC32    DICTFULL_ABORT
  587                           
  588                           CCOMMA_OK:
  589    00000020 ........              DC32    HERE
  590    00000024 ........              DC32    CSTORE
  591    00000028 ........              DC32    ONE
  592    0000002C ........              DC32    ALLOT_PRIM
  593    00000030 ........              DC32    SEMIS
  594                           
  595                           
  596                           //      VARALLOT VARALLOT:      ( n -- addr ) Value stored here is ALIGNED
  597                           //      IF USERVAR SPACE FULL PRINT Error MESSAGE AND Abort.
  598                           //      Add n * 32 bits to the RAMVARSPACE pointer UP.
  599                           //      Used to allocate space in Ram for VAR's and other system data structures
  600                           
  601                            SECTION .text : CONST (2)
  602                           VARALLOT_NFA:
  603    00000000 88                    DC8     0x88
  604    00000001 564152414C4C4         DC8     'VARALLO'
                  F            
  605    00000008 D4                    DC8     'T'+0x80
  606    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  607    0000000C ........              DC32    CCOMMA_NFA
  608                           VARALLOT:
  609    00000010 ........              DC32    DOCOL
  610    00000014 ........              DC32    VARSPACE                //      ( -- n )
  611    00000018 .............         DC32    FOUR, SLASH, OVER, SUBB
                  .............
                  ......       
  612    00000028 ........              DC32    ZLESS
  613    0000002C ........              DC32    ZBRAN
  614    00000030 18000000              DC32    VALLOT_OK-.
  615                           
  616    00000034 .............         DC32    LIT, msg_uvfull
                  ...          
  617    0000003C .............         DC32    NULLSTRLEN, TYPE
                  ...          
  618                           #ifdef IO2TP
  621                           #endif
  622    00000044 ........              DC32    ABORT
  623                           
  624                           VALLOT_OK:
  625    00000048 .............         DC32    UP_SV, AT       // Address of this allotment
                  ...          
  626    00000050 ........              DC32    SWAP            // n
  627    00000054 .............         DC32    FOUR, STAR      // n = 4 bytes
                  ...          
  628    0000005C ........              DC32    UP_SV
  629    00000060 ........              DC32    PSTORE          // Address of next var available
  630    00000064 ........              DC32    SEMIS
  631                           
  632                           
  633                           //      LATEST LATEST: ( -- nfa )
  634                           //      Initially ADDR OF LAST WORD in THE DICTIONARY
  635                           //      Leave the nfa of the topmost word in the dictionary.
  636                           
  637                            SECTION .text : CONST (2)
  638                           LATEST_NFA:
  639    00000000 86                    DC8     0x86
  640    00000001 4C41544553            DC8     'LATES'
  641    00000006 D4                    DC8     'T'+0x80
  642    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  643    00000008 ........              DC32    VARALLOT_NFA
  644                           LATEST:
  645    0000000C ........              DC32    DOCOL
  646    00000010 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
  647    00000014 ........              DC32    AT
  648    00000018 ........              DC32    SEMIS
  649                           
  650                           
  651                           //      LFA LFA:        ( pfa -- lfa )
  652                           //      Convert the parameter field address of a dictionary definition to
  653                           //      its link field address.
  654                           
  655                            SECTION .text : CONST (2)
  656                           LFA_NFA:
  657    00000000 83                    DC8     0x83
  658    00000001 4C46                  DC8     'LF'
  659    00000003 C1                    DC8     'A'+0x80
  660                            ALIGNROM 2,0xFFFFFFFF
  661    00000004 ........              DC32    LATEST_NFA
  662                           LFA:
  663    00000008 ........              DC32    .+5
  664                            SECTION .text : CODE (2)
  665                                   POP2t
  665.1                         #ifndef TOSCT
  665.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  665.3                         #endif
  665.4  00000002 3F1D                  ADDS    p, p, #4
  665.5                                 ENDM
  666    00000004 0838                  SUBS     t, t, #8
  667                                   TPUSH
  667                                   PUSHt   // push t to p, pre decrement p
  667.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  667.2  00000008 3860                  STR     t, [p]
  667.3                                 ENDM
  667                                   NEXT
  667.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  667                                   NEXT1
  667.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  667.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  667.3                                 ENDM
  667.4                                 ENDM
  667.5                                 ENDM
  668                           
  669                           
  670                           //      CFA CFA:        ( pfa -- cfa )
  671                           //      Convert the parameter field address of a dictionary definition to
  672                           //      its code field address. <if thumb2 execution addr smudged>
  673                           
  674                            SECTION .text : CONST (2)
  675                           CFA_NFA:
  676    00000000 83                    DC8     0x83
  677    00000001 4346                  DC8     'CF'
  678    00000003 C1                    DC8     'A'+0x80
  679                            ALIGNROM 2,0xFFFFFFFF
  680    00000004 ........              DC32    LFA_NFA
  681                           CFA:
  682    00000008 ........              DC32    .+5
  683                            SECTION .text : CODE (2)
  684                                   POP2t
  684.1                         #ifndef TOSCT
  684.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  684.3                         #endif
  684.4  00000002 3F1D                  ADDS    p, p, #4
  684.5                                 ENDM
  685    00000004 001F                  SUBS     t, t, #4
  686                                   TPUSH
  686                                   PUSHt   // push t to p, pre decrement p
  686.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  686.2  00000008 3860                  STR     t, [p]
  686.3                                 ENDM
  686                                   NEXT
  686.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  686                                   NEXT1
  686.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  686.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  686.3                                 ENDM
  686.4                                 ENDM
  686.5                                 ENDM
  687                           
  688                           
  689                           //      NFA NFA:        ( pfa -- nfa )
  690                           //      Convert the parameter field address of a definition to its name
  691                           //      field. Modified for nfa alighnment padding
  692                           
  693                            SECTION .text : CONST (2)
  694                           NFA_NFA:
  695    00000000 83                    DC8     0x83
  696    00000001 4E46                  DC8     'NF'
  697    00000003 C1                    DC8     'A'+0x80
  698                            ALIGNROM 2,0xFFFFFFFF
  699    00000004 ........              DC32    CFA_NFA
  700                           NFA:
  701    00000008 ........              DC32    DOCOL
  702    0000000C .............         DC32    EIGHT, SUBB     // Addr OF lfa, DUPED TO TRAVERSE Padding
                  ...          
  703                           
  704                           NFA_ALIGN_BEGIN:
  705    00000014 ........              DC32    ONEM            // ADDR 1 BEFORE lfa, eliminate padding
  706    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  707    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  708    0000002C ........              DC32    ZBRAN           // UNTIL
  709    00000030 E4FFFFFF              DC32    NFA_ALIGN_BEGIN-.
  710                                       
  711    00000034 ........FFFFF         DC32    LIT,-1          // DIRECTION FOR TRAVERSE = Toward nfa
                  FFF          
  712    0000003C ........              DC32    TRAVERSE                // ( -- addr2 )
  713    00000040 ........              DC32    SEMIS
  714                           
  715                           
  716                           //      PFA PFA:        ( nfa -- pfa )
  717                           //      Convert the name field address of a compiled definition to its
  718                           //      parameter field address.
  719                           
  720                            SECTION .text : CONST (2)
  721                           PFA_NFA:
  722    00000000 83                    DC8     0x83
  723    00000001 5046                  DC8     'PF'
  724    00000003 C1                    DC8     'A'+0x80
  725                            ALIGNROM 2,0xFFFFFFFF
  726    00000004 ........              DC32    NFA_NFA
  727                           PFA:
  728    00000008 ........              DC32    DOCOL           // ( NFA -- )
  729    0000000C ........              DC32    ONE             // DIRECTION FOR TRAVERSE = Toward CFA
  730    00000010 ........              DC32    TRAVERSE        // ( NFA 1 -- addr2 )
  731                           
  732                           PFA_ALIGN_BEGIN:
  733    00000014 ........              DC32    ONEP            // ADDR 1 BEFORE lfa, eliminate padding
  734    00000018 .............         DC32    DUP, CAT        // ALIGNROM FF padded?
                  ...          
  735    00000020 ........FF000         DC32    LIT, 0xFF, SUBB
                  000........  
  736    0000002C ........              DC32    ZBRAN           // UNTIL
  737    00000030 E4FFFFFF              DC32    PFA_ALIGN_BEGIN-.
  738                           
  739    00000034 ........              DC32    EIGHT
  740    00000038 ........              DC32    PLUS
  741    0000003C ........              DC32    SEMIS
  742                           
  743                           
  744                           //      ?ALIGNED QALIGNED: ( value -- )
  745                           //      If value not aligned by 4 issue message and ABORT.
  746                           
  747                            SECTION .text : CONST (2)
  748                           QALIGNED_NFA:
  749    00000000 88                    DC8     0x88
  750    00000001 3F414C49474E4         DC8     '?ALIGNE'
                  5            
  751    00000008 C4                    DC8     'D'+0x80
  752    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  753    0000000C ........              DC32    PFA_NFA
  754                           QALIGNED:
  755    00000010 ........              DC32    DOCOL
  756    00000014 ........03000         DC32    LIT, 3, ANDD
                  000........  
  757    00000020 ........              DC32    ZBRAN           //IF no err leave
  758    00000024 3C000000              DC32     QALIGN_OK-.
  759                           
  760    00000028 ........              DC32    PDOTQ
  761    0000002C 2E                    DC8     46
  762    0000002D 56414C5545204         DC8     'VALUE MUST BE EVEN NOT ODD AND MULTIPLE OF 4! '
                  D555354204245
                  204556454E204
                  E4F54204F4444
                  20414E44204D5
                  54C5449504C45
                  204F462034212
                  0            
  763    0000005B FF             ALIGNROM 2,0xFFFFFFFF
  764    0000005C ........              DC32    ABORT
  765                           
  766                           QALIGN_OK:
  767    00000060 ........              DC32    SEMIS
  768                           
  769                           
  770                           //      ?ERROR QERROR: ( f nullstr -- )
  771                           //      If f NON ZERO type error message (nullstr) and ABORT.
  772                           
  773                            SECTION .text : CONST (2)
  774                           QERROR_NFA:
  775    00000000 86                    DC8     0x86
  776    00000001 3F4552524F            DC8     '?ERRO'
  777    00000006 D2                    DC8     'R'+0x80
  778    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  779    00000008 ........              DC32    QALIGNED_NFA
  780                           QERROR:
  781    0000000C ........              DC32    DOCOL
  782    00000010 ........              DC32    SWAP
  783    00000014 ........              DC32    ZBRAN   //IF no err leave
  784    00000018 10000000              DC32     QERROR_FINISH-.
  785                           
  786    0000001C ........              DC32    ERROR // ( nullstr-addr --- ) ABORT's
  787    00000020 ........              DC32    BRAN    //ELSE
  788    00000024 08000000              DC32     QERROR_DONE-.
  789                           
  790                           QERROR_FINISH:
  791    00000028 ........              DC32    DROP    //endif
  792                           
  793                           QERROR_DONE:
  794    0000002C ........              DC32    SEMIS
  795                           
  796                           
  797                           //      DIGIT DIGIT:    ( c base -- digit 1 ) (ok)
  798                           //                      ( c base -- 0 (bad)
  799                           //      Converts the ascii character c using base to its binary
  800                           //      equivalent digit, accompanied by a true flag. If the conversion is
  801                           //      invalid, leaves only a false flag.
  802                           
  803                            SECTION .text : CONST (2)
  804                           DIGIT_NFA:
  805    00000000 85                    DC8     0x85
  806    00000001 44494749              DC8     'DIGI'
  807    00000005 D4                    DC8     'T'+0x80
  808    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
  809    00000008 ........              DC32    QERROR_NFA
  810                           DIGIT:
  811    0000000C ........              DC32    .+5
  812                            SECTION .text : CODE (2)
  813                                   POP2w                   // Number base
  813.1  00000000 3A68                  LDR     w, [p]
  813.2  00000002 3F1D                  ADDS    p, p, #4
  813.3                                 ENDM
  814                                   POP2t                   // ASCII DIGIT
  814.1                         #ifndef TOSCT
  814.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
  814.3                         #endif
  814.4  00000006 3F1D                  ADDS    p, p, #4
  814.5                                 ENDM
  815    00000008 3038                  SUBS   t, t, #'0'
  816    0000000A 0FD4                  BMI   DIGI2             // Number error
  817                           
  818    0000000C 0928                  CMP   t, #9
  819    0000000E 02DD                  BLE   DIGI1             // Number = 0 THRU 9
  820                           
  821                                   // Combine?
  822    00000010 C01F                  SUBS   t, t, #7
  823    00000012 0A28                  CMP   t, #10            // Number 'A' THRU 'Z'?
  824    00000014 0ADB                  BLT   DIGI2             // NO
  825                           
  826                           DIGI1:
  827    00000016 9042                  CMP     t, w            // COMPARE Number TO base
  828    00000018 08DA                  BGE     DIGI2
  829                           
  830    0000001A 0246                  MOV     w, t            // NEW BINARY Number
  831    0000001C 0120                  MOVS    t, #1           // TRUE FLAG
  832                                   DPUSH
  832                                   PUSHw   // push w to p, pre decrement p
  832.1  0000001E 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
  832.2  00000020 3A60                  STR     w, [p]
  832.3                                 ENDM
  832                                   TPUSH
  832                                   PUSHt   // push t to p, pre decrement p
  832.1  00000022 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  832.2  00000024 3860                  STR     t, [p]
  832.3                                 ENDM
  832                                   NEXT
  832.1  00000026 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  832                                   NEXT1
  832.1  00000028 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  832.2  0000002A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  832.3                                 ENDM
  832.4                                 ENDM
  832.5                                 ENDM
  832.6                                 ENDM
  833                           
  834                                   // Number error
  835                           DIGI2:
  836    0000002C 0020                  MOVS   t, #0            // FALSE FLAG
  837                                   TPUSH
  837                                   PUSHt   // push t to p, pre decrement p
  837.1  0000002E 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  837.2  00000030 3860                  STR     t, [p]
  837.3                                 ENDM
  837                                   NEXT
  837.1  00000032 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  837                                   NEXT1
  837.1  00000034 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  837.2  00000036 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  837.3                                 ENDM
  837.4                                 ENDM
  837.5                                 ENDM
  838                           
  839                           
  840                           //      ENCLOSE ENCL:   ( addr1 c -- addr1 n1 n2 n3 )
  841                           //      A text scanning iterative primitive used only in WORD.
  842                           //      IN is used before and after callS for the iteration
  843                           //      Typically TIB + IN = addr1
  844                           //      noop EX//( TIB   32 -- TIB   0 4 5 )
  845                           //      NULL EX//( TIB   32 -- ADDR-B4-NULL 0 1 1 ) So DFIND CAN FIND IT!
  846                           //      NULL EX//  WORD/ENCL -> TIB 1, 0, 20'S
  847                           //      From the text address addr1 and an ascii delimiting character c,
  848                           //      is determined the byte offset to the first non-delimiter character n1,
  849                           //      the offset to the first delimiter after the text n2,
  850                           //      and the offset to the first character not included.
  851                           //      This procedure will not process past an ASCII 'null', treating it
  852                           //      as an unconditional delimiter. NULL termination by EXPECT in QUERY.
  853                           
  854                            SECTION .text : CONST (2)
  855                           ENCL_NFA:
  856    00000000 87                    DC8     0x87
  857    00000001 454E434C4F53          DC8     'ENCLOS'
  858    00000007 C5                    DC8     'E'+0x80
  859                            ALIGNROM 2,0xFFFFFFFF
  860    00000008 ........              DC32    DIGIT_NFA
  861                           ENCL:
  862    0000000C ........              DC32    .+5
  863                            SECTION .text : CODE (2)
  864                                   POP2t                   // TERMINATOR CHAR
  864.1                         #ifndef TOSCT
  864.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  864.3                         #endif
  864.4  00000002 3F1D                  ADDS    p, p, #4
  864.5                                 ENDM
  865    00000004 3968                  LDR     n, [p]          // get text address but leave on stack
  866    00000006 0022                  MOVS    w, #0
  867    00000008 521E                  SUBS    w, w, #1        // CHAR  COUNTER
  868    0000000A 491E                  SUBS    n, n, #1        // ADDR -1
  869                           
  870                           //  SCAN TO FIRST NON-TERMINATOR CHARACTER
  871                           //      and PUSH count to stack leaving last 2 params to compute
  872                           ENCL1:
  873    0000000C 491C                  ADDS    n, n, #1        // ADDR+1
  874    0000000E 521C                  ADDS    w, w, #1        // COUNT+1
  875    00000010 0B78                  LDRB    x, [n]
  876    00000012 9842                  CMP     t, x            //CMP   AL,[BX]
  877    00000014 FAD0                  BEQ     ENCL1           //JZ    ENCL1   // WAIT FOR NON-TERMINATOR
  878                                   PUSHw                   //offset to the first non-delimiter character
  878.1  00000016 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
  878.2  00000018 3A60                  STR     w, [p]
  878.3                                 ENDM
  879                                                           //EXiT is now only DPUSH
  880    0000001A 002B                  CMP     x, #0           //CMP   AH,[BX] // null CHAR?
  881    0000001C 08D1                  BNE     ENCL2           //JNZ   ENCL2   // NO
  882                           
  883                           // FOUND null BEFORE 1ST NON-TERM CHAR
  884                           // RETURN ok args = NULL EX//
  885                           // ( TIB   32 -- ADDR-B4-NULL 0 1 1 ) So DFIND CAN FIND IT!
  886                           //
  887    0000001E 1846                  MOV     t, x
  888    00000020 521C                  ADDS    w, w, #1        // w = offset to the delimiter after the text
  889                                   DPUSH
  889                                   PUSHw   // push w to p, pre decrement p
  889.1  00000022 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
  889.2  00000024 3A60                  STR     w, [p]
  889.3                                 ENDM
  889                                   TPUSH
  889                                   PUSHt   // push t to p, pre decrement p
  889.1  00000026 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  889.2  00000028 3860                  STR     t, [p]
  889.3                                 ENDM
  889                                   NEXT
  889.1  0000002A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  889                                   NEXT1
  889.1  0000002C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  889.2  0000002E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  889.3                                 ENDM
  889.4                                 ENDM
  889.5                                 ENDM
  889.6                                 ENDM
  890                           
  891                           //   FOUND FIRST TEXT CHAR - COUNT THE CHARS
  892                           ENCL2:
  893    00000030 491C                  ADDS    n, n, #1        // ADDR+1
  894    00000032 521C                  ADDS    w, w, #1        //COUNT+1
  895    00000034 0B78                  LDRB    x, [n]
  896    00000036 9842                  CMP     t, x            //TERMINATOR CHAR?
  897    00000038 01D0                  BEQ     ENCL4           //YES
  898                           
  899    0000003A 002B                  CMP     x, #0           //null CHAR?
  900    0000003C F8D1                  BNE     ENCL2           //NO, LOOP AGAIN
  901                           
  902                           ENCL3:  //   FOUND null AT END OF TEXT
  903                           ENCL4:  //   FOUND TERMINATOR CHARACTER
  904    0000003E 1046                  MOV     t, w            // COUNT+1 =
  905    00000040 401C                  ADDS    t, t, #1        // offset to the first character not included
  906                                   DPUSH
  906                                   PUSHw   // push w to p, pre decrement p
  906.1  00000042 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
  906.2  00000044 3A60                  STR     w, [p]
  906.3                                 ENDM
  906                                   TPUSH
  906                                   PUSHt   // push t to p, pre decrement p
  906.1  00000046 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  906.2  00000048 3860                  STR     t, [p]
  906.3                                 ENDM
  906                                   NEXT
  906.1  0000004A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  906                                   NEXT1
  906.1  0000004C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  906.2  0000004E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  906.3                                 ENDM
  906.4                                 ENDM
  906.5                                 ENDM
  906.6                                 ENDM
  907                           
  908                           
  909                           //      0 NULL: ( -- ) IMMEDIATE
  910                           //      Don't return to Interpret, return to Quit at end of a line of input.
  911                           //      Executed at end of TIB when QUERY lenght or CR entered.
  912                           
  913                            SECTION .text : CONST (2)
  914                           NULL_NFA:
  915    00000000 C1                    DC8     0x0C1                   // A BINARY ZER
  916    00000001 80                    DC8     0x80
  917    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
  918    00000004 ........              DC32    ENCL_NFA
  919                           NULL:
  920                           //      DC32    SEMIS                   // Actual Semis code below
  921    00000008 ........              DC32    .+5
  922                            SECTION .text : CODE (2)
  923                                   POPr2i  // pop docol saved IP from Rstack
  923.1  00000000 3568                  LDR i, [r]              //  pop r to i, post increment r
  923.2  00000002 361D                  ADDS    r, r, #4
  923.3                                 ENDM
  924                                   NEXT
  924.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  924                                   NEXT1
  924.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  924.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  924.3                                 ENDM
  924.4                                 ENDM
  925                           
  926                           
  927                           //      WORD WORD:      ( c -- )
  928                           //      Parse the text in TIB , until a delimiter c is found, tokenizing input.
  929                           //      Move the token to HERE, with a count byte and 2 nulls at the end.
  930                           //      Leading occurrences of c are ignored. IN is incremented.
  931                           //      IN is initialized by FISH to 1 to account for the count byte in EXPECT.
  932                           //      See IN. Usually used inside a definition.
  933                           
  934                            SECTION .text : CONST (2)
  935                           WORD_NFA:
  936    00000000 84                    DC8     0x84
  937    00000001 574F52                DC8     'WOR'
  938    00000004 C4                    DC8     'D'+0x80
  939    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
  940    00000008 ........              DC32    NULL_NFA
  941                           WORD:
  942    0000000C ........              DC32    DOCOL
  943                           WORD1:
  944                           //      This is required for number suffix's at least ???
  945                           //      DC32    HERE, LIT, MAXWORDLEN+2, BLANKS
  946    00000010 ........              DC32    TIB_SV
  947                           WORD2:
  948    00000014 ........              DC32    IN_SV
  949    00000018 ........              DC32    AT
  950    0000001C ........              DC32    PLUS
  951    00000020 ........              DC32    SWAP    // ( TIB+IN CH-DELIM -- )
  952    00000024 ........              DC32    ENCL    // ( TIB+IN 32 -- TIB+IN   0 4 5 )
  953                           WENCL:
  954    00000028 ........              DC32    IN_SV   // encl TOS = end of word offset to be added to IN
  955    0000002C ........              DC32    PSTORE  // TIB+IN   0 4
  956    00000030 ........              DC32    OVER    // 
  957    00000034 ........              DC32    SUBB    // Char cnt going to R and HERE
  958    00000038 ........              DC32    TOR
  959    0000003C ........              DC32    R
  960    00000040 ........              DC32    HERE
  961    00000044 ........              DC32    CSTORE   // CHAR CNT OF word
  962    00000048 ........              DC32    PLUS
  963    0000004C ........              DC32    HERE
  964    00000050 ........              DC32    ONEP
  965                           //      DC32    RFROM
  966                           // MOVE word TO DICT FOR finding ENDING WITH NULLS
  967    00000054 ........              DC32    R
  968    00000058 ........              DC32    CMOVE   // ( from to count -- )
  969                           // add null to end of token - NUMBER adjusted        
  970    0000005C .............         DC32    ZERO, HERE, ONEP, RFROM, PLUS, CSTORE
                  .............
                  .............
                  .........    
  971                           #ifdef  IOBUFS_DEBUG
  973                           #endif        
  974    00000074 ........              DC32    SEMIS
  975                           
  976                           
  977                           //      NUMBER NUMBER:  ( addr -- sd )
  978                           //      If error print message and ABORT.
  979                           //      Convert a character string left at addr with a preceeding count,
  980                           //      and a terminating null, to a signed number, in the current numeric base.
  981                           //      If a decimal point is encountered in the text, its position will be
  982                           //      given in DPL, but no other effect occurs. If numeric conversion is
  983                           //      not possible, an error message will be given.
  984                           
  985                           //      Added support for , as a single number formatter.
  986                           
  987                           #define comma_test
  988                           
  989                            SECTION .text : CONST (2)
  990                           NUMBER_NFA:
  991    00000000 86                    DC8     0x86
  992    00000001 4E554D4245            DC8     'NUMBE'
  993    00000006 D2                    DC8     'R'+0x80
  994    00000007 FF             ALIGNROM 2,0xFFFFFFFF
  995    00000008 ........              DC32    WORD_NFA
  996                           NUMBER:
  997    0000000C ........              DC32    DOCOL
  998    00000010 ........              DC32    BASE_TO_R12     // Save current BASE.
  999    00000014 ........              DC32    NUMBERSUFFIX    // (addr -- sddr) Change BASE if suffix used.
 1000                           
 1001                           // SETUP: stack arguments for PNUMBER.
 1002    00000018 .............         DC32    ZERO, ZERO
                  ...          
 1003    00000020 ........              DC32    ROT             // ( 0 0 addr -- )
 1004                           
 1005                           // SETUP: reeturn stack with sign flag
 1006                           // NONAME CANDIDATE!
 1007                           // START: Handle minus sign by saving status on Return Stack.
 1008                           // and incrementing to addr after it.
 1009    00000024 .............         DC32    DUP, ONEP       // ( 0 0 addr addr+1 -- )
                  ...          
 1010    0000002C ........              DC32    CAT             // ( 0 0 addr 1rstchar -- )
 1011    00000030 ........2D000         DC32    LIT, '-'        // ( 0 0 addr 1rstchar 0x2D --- )
                  000          
 1012    00000038 ........              DC32    EQUAL           // ( 0 0 addr f -- )
 1013                           #ifdef TRUE_EQU_NEG_ONE         // EQUAL returns -1 NEED 0 or 1 here!
 1014    0000003C .............         DC32    ONE, ANDD       // ( 0 0 addr f -- ) MAKE FLAG ONE OR ZERO!
                  ...          
 1015                           #endif
 1016    00000044 .............         DC32    DUP, TOR        // ( 0 0 addr f -- ) copy of f >R
                  ...          
 1017                           // END: Handle - by saving status on Return Stack.
 1018                           
 1019                           // SETUP: addr pointing to 1rst digit.
 1020                           // If minus sign, flag from above will increment to next char.
 1021    0000004C ........              DC32    PLUS            // Increment (OR NOT) addr to next char
 1022                           
 1023                           // So could be at 1rst OR 2nd character in string here!
 1024                           
 1025                           // ENTER LOOP WITH -1 DPL = single number and sign flag on return stack.
 1026    00000050 ........FFFFF         DC32    LIT, -1
                  FFF          
 1027                           // PNUMBER is used in loop to convert string segment until non-mumeric chracter.
 1028                           // A period in the string manipulates DPL to create a double number.
 1029                           // A comma in the string resets DPL to create a single number.
 1030                           // A null indicates the end of the string.
 1031                           NUMB1:                          // Begin
 1032    00000058 .............         DC32    DPL_SV, STORE   // PNUMBER creates whole, dot or comma number segment
                  ...          
 1033                           
 1034                           // PNUMBER converts one or more characters until first unconvertable digit.
 1035                           // ud and addr in string is maintained while in loop.
 1036    00000060 ........              DC32    PNUMBER         // ( 0 0 addr -- ud=(LSW MSW) ADDR=PAST#)
 1037                           // Perform check for period, comma and null.
 1038                           // Any other character here invalidates this number conversion.
 1039                           
 1040                           // Null Test: = end of string.
 1041    00000064 .............         DC32    DUP, CAT
                  ...          
 1042    0000006C ........              DC32    ZERO            // End of string used to be BLANK, is now Null.
 1043    00000070 ........              DC32    SUBB
 1044    00000074 ........              DC32    ZBRAN           // IF emd of number string conversion is
 1045    00000078 6C000000              DC32      NUMB2-.       // DONE UNLESS IT NEEDS TO BE NEGATED.
 1046                           
 1047                           // Period Test: = increment DPL.
 1048    0000007C .............         DC32    DUP, CAT
                  ...          
 1049    00000084 ........2E000         DC32    LIT, '.'        // 2Eh = period.
                  000          
 1050    0000008C ........              DC32    SUBB
 1051    00000090 ........              DC32    ZBRAN
 1052    00000094 44000000              DC32      DPL_ZERO_INCR-.
 1053                           
 1054                           #ifdef  comma_test
 1055                           // Comma Test: = reset DPL.
 1056    00000098 .............         DC32    DUP, CAT
                  ...          
 1057    000000A0 ........2C000         DC32    LIT, ','        // 2CH comma
                  000          
 1058    000000A8 ........              DC32    EQUAL
 1059    000000AC ........              DC32    ZBRAN
 1060    000000B0 14000000              DC32      BASE_RESET_THEN_ERROR-.
 1061                           
 1062                           // Fall thru if comma so reset DPL to create a single number.
 1063                           DPL_RESET:        
 1064    000000B4 ........FFFFF         DC32    LIT, -1
                  FFF          
 1065    000000BC ........              DC32    BRAN
 1066    000000C0 98FFFFFF              DC32      NUMB1-.
 1067                           #endif
 1068                           
 1069                           BASE_RESET_THEN_ERROR:
 1070                           // GOING TO ERROR SO RESTORE BASE!
 1071    000000C4 ........              DC32    BASE_FROM_R12   // Restore BASE
 1072                           //NO_BASE_RESTORE:
 1073    000000C8 ........              DC32    ONE     // provide non zero flag for error
 1074    000000CC .............         DC32    LIT, msg_number_error
                  ...          
 1075    000000D4 ........              DC32    QERROR // ( f nullstr-addr -- ) IF f TRUE EXECUTE ERROR!
 1076                           
 1077                           DPL_ZERO_INCR:      // set DPL to zero
 1078    000000D8 ........              DC32    ZERO
 1079    000000DC ........              DC32    BRAN
 1080    000000E0 78FFFFFF              DC32      NUMB1-.
 1081                           
 1082                           NUMB2:
 1083    000000E4 ........              DC32    DROP
 1084    000000E8 ........              DC32    RFROM           // FLAG OF "-" TEST
 1085                                                           // IF
 1086    000000EC ........              DC32    ZBRAN
 1087    000000F0 08000000              DC32      NUMB3-.
 1088                           
 1089    000000F4 ........              DC32    DNEGATE
 1090                           
 1091                           NUMB3:                          // endif
 1092    000000F8 ........              DC32    BASE_FROM_R12   // Restore BASE
 1093    000000FC ........              DC32    SEMIS
 1094                           
 1095                           
 1096                           //      ERROR ERROR:    ( nullstr --- )
 1097                           //      Execute error notification and restart of system.
 1098                           
 1099                            SECTION .text : CONST (2)
 1100                           ERROR_NFA:
 1101    00000000 85                    DC8     0x85
 1102    00000001 4552524F              DC8     'ERRO'
 1103    00000005 D2                    DC8     'R'+0x80
 1104    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1105                           //      DC32    DFIND_NFA
 1106    00000008 ........              DC32    NUMBER_NFA
 1107                           ERROR:
 1108    0000000C ........              DC32    DOCOL
 1109    00000010 .............         DC32    HERE, COUNT, TYPE       // Offending item
                  ...........  
 1110    0000001C .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 1111                           #ifdef IO2TP
 1114                           #endif
 1115                           #ifdef XON_XOFF
 1116    00000024 ........              DC32    XOFF    // TEMP TEST THRE
 1117                           #endif
 1118                                   
 1119                           //      DO THIS WHERE STATE IS SET BACK TO ZERO
 1120    00000028 .............         DC32    STATE_SV, AT
                  ...          
 1121    00000030 ........              DC32    ZBRAN
 1122    00000034 40000000              DC32     CREATED_OK-.
 1123                           
 1124                           //      NON-ZERO CSDP = RESTORE DP TO forget DAMAGED WORDS
 1125    00000038 .............         DC32    CSDP_SV, AT   // Create saves dp here for if word exists err
                  ...          
 1126    00000040 ........              DC32    ZBRAN
 1127    00000044 30000000              DC32     CREATED_OK-.
 1128                           
 1129                           // assume ITS A CREATE'd WORD!!!!
 1130                           ERROR_FIXUP:     // CSDP_SV contains NFA of definition that has error.
 1131    00000048 .............         DC32    CSDP_SV, AT     // SHOULD BE AT NFA!!
                  ...          
 1132    00000050 ........              DC32    PFA     // ( nfa -- pfa )
 1133    00000054 .............         DC32    LFA, AT // ( pfa --- lfa )
                  ...          
 1134    0000005C .............         DC32    CURRENT_SV, STORE       // Has to be NFA of last good word
                  ...          
 1135                           // RESET DP!
 1136    00000064 .............         DC32    CSDP_SV, AT
                  ...          
 1137    0000006C .............         DC32    DP_SV, STORE
                  ...          
 1138                           
 1139                           CREATED_OK:
 1140    00000074 ........              DC32    SEMIC_CREATE            // RESET CSDP FOR AUTO FORGET
 1141                           
 1142                           BP1_ERROR:
 1143                           #ifdef IO2TP
 1145                           #endif
 1146                           //      DC32    SPSTO   // DONE in QUIT
 1147                           #ifdef ABORT_STOP_TILL_CO
 1148    00000078 ........              DC32    ABORT
 1149                           #else
 1151                           #endif
 1152                           
 1153                           
 1154                           //      ' TICK: ( -- pfa ) IMMEDIATE
 1155                           //      Used in the form: .
 1156                           //      ' CCcc
 1157                           //      Leaves the parameter field address of dictionary word CCcc.
 1158                           //      If the word is not found after a search of CURRENT,
 1159                           //      an appropriate error message is given.
 1160                           //      As a compiler directive, executed in a colon-definition to compile
 1161                           //      the address as a literal.
 1162                           //      Pronounced "TICK".
 1163                           
 1164                            SECTION .text : CONST (2)
 1165                           TICK_NFA:
 1166    00000000 C1                    DC8     0x0C1
 1167    00000001 A7                    DC8     ''''+0x80
 1168    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1169    00000004 ........              DC32    ERROR_NFA
 1170                           TICK:
 1171    00000008 ........              DC32    DOCOL
 1172    0000000C ........              DC32    DFIND   // noop there for TIB entry
 1173    00000010 ........              DC32    ZEQU
 1174    00000014 .............         DC32    LIT, msg_word_error
                  ...          
 1175    0000001C ........              DC32    QERROR    // ( f nullstr-addr -- )
 1176    00000020 ........              DC32    DROP
 1177    00000024 ........              DC32    LITERAL
 1178    00000028 ........              DC32    SEMIS
 1179                           
 1180                           
 1181                           //      EXPECT EXPECT:  ( addr count -- )
 1182                           //      Transfer characters from the terminal to the buffer starting at addr+1,
 1183                           //      until a "return" or the count of characters have been received.
 1184                           //      One or two nulls are added at the end creating a null-terminated string.
 1185                           //      A count byte is placed at addr, the count being derived by $LEN
 1186                           //      Use COUNT with TYPE for strings saved this way.
 1187                           //      Strings longer that 255 will have an invalid count byte. Use $LEN:
 1188                           //      $LEN and TYPE can be used when the argument to $LEN is addr+1.
 1189                           
 1190                           //      Comments below use TIB input (QUERY in INTERPRET) as an example.
 1191                           
 1192                            SECTION .text : CONST (2)
 1193                           EXPECT_NFA:
 1194    00000000 86                    DC8     0x86
 1195    00000001 4558504543            DC8     'EXPEC'
 1196    00000006 D4                    DC8     'T'+0x80
 1197    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1198    00000008 ........              DC32    TICK_NFA
 1199                           EXPECT:                 // ( NOS TOS -- NOS TOS )
 1200    0000000C ........              DC32    DOCOL   // ( TIB LEN -- )
 1201    00000010 ........              DC32    ONEP    // ( TIB LEN+1 -- ) (Index and Limit)+1 for count byte
 1202    00000014 ........              DC32    OVER    // ( TIB LEN+1 TIB -- )
 1203    00000018 ........              DC32    PLUS    // ( TIB TIB+LEN+1 -- )
 1204    0000001C ........              DC32    OVER    // ( TIB TIB+LEN+1 TIB -- )
 1205    00000020 ........              DC32    ONEP    // ( TIB TIB+LEN+1 TIB+1 -- ) SKIP COUNT BYTE
 1206                           
 1207                           ///* FISH System compiled KEY does not issue XON - user version does!
 1208                           #ifdef XON_XOFF
 1209    00000024 ........              DC32    XON
 1210                           #endif
 1211                           //*/
 1212                           
 1213                           // ( ORGIGINAL-TIB TIB+LEN+1 TIB+1 -- ORGIGINAL-TIB ) 
 1214                           //                (Index & Limit)+1 for count byte
 1215    00000028 ........              DC32    XDO     // DO   Index = addr, Limit = addr+cnt
 1216                           EXPE1:
 1217    0000002C ........              DC32    KEY     // CAN BREAKPOINT OR SET TO 0x0D - XON done there.
 1218                           #ifdef XON_XOFF
 1219    00000030 ........              DC32    IF_EOL_SEND_XOFF        // IF CR QUICK XOFF!
 1220                           #endif
 1221                           // goto main branch (EL1:)if not tab
 1222    00000034 .............         DC32    DUP, LIT, 9, EQUAL      // ? TAB
                  ...09000000..
                  ......       
 1223    00000044 ........              DC32    ZBRAN                   // Not tab
 1224    00000048 0C000000              DC32     EL1-.                  // Goto MAIN LOOP
 1225                                   
 1226                           // REPLACE TAB WITH SPACE               // -- ch f
 1227    0000004C .............         DC32    DROP, BLANK             // Convert tab to space
                  ...          
 1228                           EL1:
 1229                           // MAIN LOOP ENTERED WITH CHAR ON TOS
 1230    00000054 ........              DC32    DUP             // ( TIB key key -- )
 1231                           // FALL THRU IF BACKSPACE OR DELETE KEY
 1232    00000058 ........              DC32    BACKSPACE_CHAR
 1233    0000005C ........              DC32    EQUAL
 1234    00000060 ........              DC32    OVER
 1235    00000064 ........7F000         DC32    LIT, 07Fh       // DEL KEY
                  000          
 1236    0000006C ........              DC32    EQUAL
 1237    00000070 ........              DC32    OR
 1238                           // BRANCH IF NOT BACKSPACE OR DELETE KEY
 1239    00000074 ........              DC32    ZBRAN           // If not backspace
 1240    00000078 60000000              DC32     EXPE2-.        // go here
 1241                           
 1242                           // CASE OF BACKSPACE/DELETE KEY
 1243    0000007C ........              DC32    DROP            // ( TOS> 8 TIB -- TIB ) Drop Backspace on stack
 1244    00000080 ........              DC32    DUP             // ( TOS> TIB -- TOS> TIB TIB )  Current TIB addr
 1245    00000084 ........              DC32    I               // ( TOS> TIB TIB -- I=TIB+? TIB TIB )
 1246                           // COMPENSATE FOR COUNT BYTE - BUMP ADDR+1 (NEXT CHAR LOCATION) BACK TO CURRENT
 1247    00000088 ........              DC32    ONEM
 1248    0000008C ........              DC32    EQUAL           // ( TOS> I=TIB+? TIB TIB -- f TIB )
 1249    00000090 ........              DC32    DUP             // ( TOS> f TIB -- f f TIB )
 1250                           // I AND RFROM STARTS AT TIB+1 
 1251                           // REMOVE INDEX FROM LOOP TO REPLACE IT WITH BACKSPACE CORRECTED ADDRESS
 1252    00000094 ........              DC32    RFROM           // ( TOS> f f TIB -- TIB+1 f f TIB )
 1253                           // ADDING 2 BECAUSE TIB+1 IS FROM I AND FLAG MAKES IT = TO 1
 1254                           // WHEN AT THE BEGIINING (ADDR+1) OF THE ADDR BUFFER
 1255    00000098 ........              DC32    TWO
 1256    0000009C ........              DC32    SUBB
 1257                           // ADD FLAG 
 1258    000000A0 ........              DC32    PLUS
 1259    000000A4 ........              DC32    TOR
 1260    000000A8 ........              DC32    ZBRAN           // If not at beginning of line
 1261    000000AC 10000000              DC32     EXPE6-.        // Goto bsout
 1262                           
 1263    000000B0 ........              DC32    BELL            // At beginning of TIB issue bell
 1264    000000B4 ........              DC32    BRAN            // Goto end of loop
 1265    000000B8 70000000              DC32     EXPE33-.
 1266                           
 1267                           EXPE6:  // Fix OUTPUT and TIB
 1268                           // Getting 1rts BELL only - erased word being interpreted.
 1269    000000BC ........              DC32    BSOUT                   // Fix Output
 1270    000000C0 .............         DC32    ZERO, I, ONEP, CSTORE   // FIX TIB
                  .............
                  ......       
 1271                           EXPE7:  // LABEL NOT USED BECAUSE BELL AND BSOUT Emit THEMSELVES
 1272    000000D0 ........              DC32    BRAN            // Goto end of loop
 1273    000000D4 54000000              DC32     EXPE33-.
 1274                           
 1275                           EXPE2:
 1276    000000D8 ........              DC32    DUP
 1277    000000DC ........0D000         DC32    LIT, 0x0D       // cr
                  000          
 1278    000000E4 ........              DC32    EQUAL
 1279    000000E8 ........              DC32    ZBRAN           // If not cr
 1280    000000EC 1C000000              DC32     EXPE4-.        // Goto save this char and loop again
 1281                                   
 1282    000000F0 ........              DC32    LEAVE           // ( TOS> ODh TIB --  )
 1283                           #ifdef  IOBUFS_DEBUG        
 1285                           #endif
 1286                                   // CR DROPPED HERE I USED AT END FOR CASE OF EXPECT COUNT REACHED
 1287    000000F4 ........              DC32    DROP            // ( TOS> TIB -- )
 1288    000000F8 ........              DC32    BLANK           // ( TOS> 20h TIB -- ) space IS FOR EMIT!
 1289    000000FC ........              DC32    ZERO            // ( TOS> 0 20h TIB -- ) null
 1290    00000100 ........              DC32    BRAN            // Goto store these at end of loop
 1291    00000104 08000000              DC32     EXPE5-.
 1292                           
 1293                           EXPE4:
 1294    00000108 ........              DC32    DUP             // Regular char 
 1295                           
 1296                           EXPE5:
 1297    0000010C ........              DC32    I               // I=TIB Store char
 1298    00000110 ........              DC32    CSTORE          // or 1rst null in CASE OF CR
 1299    00000114 ........              DC32    ZERO            // 1rst or second null if cr
 1300                                   // CASE OF CR ( TOS> 0 20h TIB -- )
 1301    00000118 ........              DC32    I
 1302    0000011C ........              DC32    ONEP
 1303    00000120 ........              DC32    CSTORE
 1304                           EXPE3:
 1305                                   // CASE OF CR ( TOS> 20H TIB -- )
 1306    00000124 ........              DC32    EMIT
 1307                           EXPE33:
 1308    00000128 ........              DC32    XLOOP
 1309    0000012C 00FFFFFF              DC32     EXPE1-.        // Loop is LEAVE'd
 1310                           
 1311                           #ifdef XON_XOFF
 1312    00000130 ........              DC32    XOFF            // Count reached or cr = 2nd XOFF
 1313                           #endif
 1314                           // Create count byte        
 1315                                   // ( ORIGINAL ADDR -- )
 1316                                   // ORIGINAL ADDR (TIB) ON STACK HERE SO CORRECT FOR $LEN
 1317    00000134 ........              DC32    ONEP            // PAST COUNT BYTE FOR CORRECT COUNT
 1318                                   // NULLSTRLEN:          // ( addr -- addr len )
 1319    00000138 ........              DC32    NULLSTRLEN      // ( TOS> LEN TIB+1 -- )
 1320    0000013C .............         DC32    SWAP, ONEM      // BACK UP TO COUNT BYTE
                  ...          
 1321    00000144 ........              DC32    CSTORE
 1322    00000148 ........              DC32    SEMIS
 1323                           
 1324                           
 1325                           //      COUNT COUNT:    ( addr1 --- addr2 n )
 1326                           //      Leave the byte address addr2 and byte count n of a count byte string,
 1327                           //      beginning at address addr1. It is presumed that the first byte at
 1328                           //      addr1 contains the text byte count and the actual text starts with
 1329                           //      the second byte. NFA's may report SMUDGE'd byte counts, handled only
 1330                           //      by ID. User Strings may be up to 255 characters.
 1331                           //      Typically COUNT is followed by TYPE.
 1332                           //      See TYPE $LEN and EXPECT
 1333                           
 1334                            SECTION .text : CONST (2)
 1335                           COUNT_NFA:
 1336    00000000 85                    DC8     0x85
 1337    00000001 434F554E              DC8     'COUN'
 1338    00000005 D4                    DC8     'T'+0x80
 1339    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1340    00000008 ........              DC32    EXPECT_NFA
 1341                           COUNT:
 1342    0000000C ........              DC32    DOCOL
 1343    00000010 ........              DC32    DUP
 1344    00000014 ........              DC32    ONEP
 1345    00000018 ........              DC32    SWAP
 1346                           //        DC32    CATLT7F
 1347    0000001C ........              DC32    CAT     // n could be SMUDGE'd count from NFA's
 1348    00000020 ........              DC32    SEMIS   // Only internal usage of smudged count is ID.
 1349                           
 1350                           
 1351                           //      $LEN NULLSTRLEN:        ( addr - addr len )
 1352                           //      Count length of null terminated string.
 1353                           //      TYPE can be used after this word.
 1354                           
 1355                            SECTION .text : CONST (2)
 1356                           NULLSTRLEN_NFA:
 1357    00000000 84                    DC8     0x84
 1358    00000001 244C45                DC8     '$LE'
 1359    00000004 CE                    DC8     'N'+0x80
 1360    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1361    00000008 ........              DC32    COUNT_NFA
 1362                           NULLSTRLEN:
 1363    0000000C ........              DC32    .+5
 1364                            SECTION .text : CODE (2)
 1365                                   NDPOP2w                         // Get but leave addr on stack
 1365.1  00000000 3A68                  LDR     w, [p]
 1365.2                                 ENDM
 1366    00000002 4040                  EORS            t, t            // zero count
 1367                           
 1368                           NSLEN_LOOP:
 1369    00000004 115C                  LDRB            n, [w,t]
 1370    00000006 0943                  ORRS            n, n
 1371    00000008 01D0                  BEQ             NSLEN_DONE
 1372    0000000A 401C                  ADDS            t, t, #1
 1373    0000000C FAE7                  B               NSLEN_LOOP
 1374                           
 1375                           NSLEN_DONE:
 1376                                   TPUSH
 1376                                   PUSHt   // push t to p, pre decrement p
 1376.1  0000000E 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1376.2  00000010 3860                  STR     t, [p]
 1376.3                                 ENDM
 1376                                   NEXT
 1376.1  00000012 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1376                                   NEXT1
 1376.1  00000014 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1376.2  00000016 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1376.3                                 ENDM
 1376.4                                 ENDM
 1376.5                                 ENDM
 1377                           
 1378                           
 1379                           //      FORGET FORGET:  ( -- )
 1380                           //      PRINTS NEW HERE IF SUCCESSFUL. FIXED FIG VERSION MEMORY LEAK.
 1381                           //      Executed in the form:
 1382                           //      FORGET CCcc
 1383                           //      Deletes definition named CCcc from the dictionary with all entries
 1384                           //      physically following it. In fig-FORTH, an error message will occur
 1385                           //      if the CURRENT and CONTEXT vocabularies are not currently the same.
 1386                           //      MODIFIED: To update Current along with context and reset DP,
 1387                           //      and execute .DS and .VS
 1388                           
 1389                            SECTION .text : CONST (2)
 1390                           FORGET_NFA:
 1391    00000000 86                    DC8     0x86
 1392    00000001 464F524745            DC8     'FORGE'
 1393    00000006 D4                    DC8     'T'+0x80
 1394    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 1395    00000008 ........              DC32    NULLSTRLEN_NFA
 1396                           FORGET:
 1397    0000000C ........              DC32    DOCOL
 1398    00000010 ........              DC32    TICK                    // ( -- pfa ) ELSE error message
 1399    00000014 ........              DC32    DUP
 1400    00000018 ........00400         DC32    LIT, FLASH_SPAGE       // DONT FORGET FISH WORDS SAVED in FLASH
                  000          
 1401    00000020 ........              DC32    LESSTHAN
 1402    00000024 .............         DC32    LIT, msg_forget_fish
                  ...          
 1403    0000002C ........              DC32    QERROR                  // ( f nullstr-addr -- )
 1404    00000030 ........              DC32    DUP
 1405    00000034 ........00800         DC32    LIT, FLASH_PPAGE        // DONT FORGET USER WORDS in FLASH
                  000          
 1406    0000003C ........              DC32    LESSTHAN
 1407    00000040 .............         DC32    LIT, msg_forget_saved
                  ...          
 1408    00000048 ........              DC32    QERROR                  // ( f nullstr-addr -- )
 1409                           //      MOVE NFA update of the DP to after Currrent and Context
 1410    0000004C ........              DC32    DUP                     // PFA PFA --
 1411    00000050 ........              DC32    LFA                     // PFA LFA --
 1412                           
 1413                           // VAR space reclamation starts here:
 1414                           // PFA LFA --
 1415    00000054 ........              DC32    TOR                     // LFA_BOT
 1416                           
 1417                           VS_RECVR_LOOP:
 1418    00000058 .............         DC32    LATEST, PFA, LFA        // LFA_TOP
                  ...........  
 1419    00000064 .............         DC32    DUP, AT                 // LFA NEXT_LFA
                  ...          
 1420    0000006C .............         DC32    CURRENT_SV, STORE       // SET NEXT WORD TO CHECK
                  ...          
 1421    00000074 .............         DC32    DUP, FOURP, AT          // GET CFA
                  ...........  
 1422    00000080 .............         DC32    LIT, DOVAR, EQUAL       // IS IT A DOVAR
                  ...........  
 1423    0000008C ........              DC32    ZBRAN
 1424    00000090 14000000              DC32     VS_RECVR_NEXT-.
 1425                                   
 1426    00000094 ........FCFFF         DC32    LIT, -4, UP_SV, PSTORE  // DECREMENT UP
                  FFF..........
                  ......       
 1427                           
 1428                           VS_RECVR_NEXT:
 1429    000000A4 .............         DC32    R, EQUAL
                  ...          
 1430    000000AC ........              DC32    ZBRAN
 1431    000000B0 A8FFFFFF              DC32     VS_RECVR_LOOP-.
 1432                           
 1433    000000B4 ........              DC32    RFROM
 1434                           // VAR SPACE RECLAMATION DONE
 1435                           
 1436                           // PFA LFA --
 1437    000000B8 ........              DC32    AT              // LFA
 1438    000000BC ........              DC32    CURRENT_SV
 1439    000000C0 ........              DC32    STORE
 1440    000000C4 ........              DC32    NFA             // FROM PFA
 1441    000000C8 ........              DC32    DP_SV
 1442    000000CC ........              DC32    STORE
 1443    000000D0 .............         DC32    DOTVARSPACE, DOTDICTSPACE
                  ...          
 1444    000000D8 ........              DC32    SEMIS
 1445                           
 1446                           
 1447                           //      BYE BYE: ( -- ) COLD RESTART WITH SERIAL INITIALIZATION
 1448                           
 1449                            SECTION .text : CONST (2)
 1450                           BYE_NFA:
 1451    00000000 83                    DC8     0x83
 1452    00000001 4259                  DC8     'BY'
 1453    00000003 C5                    DC8     'E'+0x80
 1454                            ALIGNROM 2,0xFFFFFFFF
 1455    00000004 ........              DC32    FORGET_NFA
 1456                           BYE:
 1457    00000008 ........              DC32    .+5
 1458                            SECTION .text : CODE (2)
 1459    00000000 ........              BLX     FM0_COLD      // __iar_program_start
 1460                            LTORG
 1461                           
 1462                           
 1463                           //      ABORT ABORT:    ( -- )
 1464                           //      Clear the stacks, zero out and execute RUN or QUIT
 1465                           //      DOES NOT RESET DICTIONAIRY. SEE COLD.
 1466                           
 1467                            SECTION .text : CONST (2)
 1468                           ABORT_NFA:
 1469    00000000 85                    DC8     0x85
 1470    00000001 41424F52              DC8     'ABOR'
 1471    00000005 D4                    DC8     'T'+0x80
 1472    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1473    00000008 ........              DC32    BYE_NFA
 1474                           ABORT:
 1475    0000000C ........              DC32    DOCOL
 1476    00000010 ........              DC32    SPSTO
 1477    00000014 ........              DC32    RPSTO
 1478                           #ifdef IO2TP
 1482                           #endif
 1483    00000018 ........00000         DC32    STRVA, 0, OUT
                  000........  
 1484                           //      DC32    QSTACK  // IF STACK error abort using QERROR->ERROR
 1485                           
 1486                           // LOOK UP RUN AND EXEC IT
 1487    00000024 .............         DC32    LIT, msg_RUN, LATEST
                  ...........  
 1488    00000030 ........              DC32    PFIND   // 0 OR pfa len 1
 1489    00000034 ........              DC32    ZBRAN
 1490    00000038 10000000              DC32      ABORT_QUIT-.
 1491                           
 1492    0000003C ........              DC32    DROP    // LEN
 1493    00000040 .............         DC32    CFA, EXEC
                  ...          
 1494                           
 1495                           ABORT_QUIT:
 1496                           //      DC32    SEMIC_CREATE // Use ERROR if need to recover from bad definition
 1497                           #ifdef ABORT_STOP_TILL_CO
 1498    00000048 .............         DC32    LIT, ERROR_HALT, AT
                  ...........  
 1499    00000054 ........              DC32    ZBRAN
 1500    00000058 6C000000              DC32      CO_END-.
 1501                           // halt on all errors until "CO" entered
 1502                           // BEGIN
 1503    0000005C .............         DC32    LIT, msg_CO, NULLSTRLEN, TYPE
                  .............
                  ......       
 1504                           NOT_CO:
 1505    0000006C ........              DC32    QKEY
 1506    00000070 ........              DC32    ZBRAN
 1507    00000074 F8FFFFFF              DC32      NOT_CO-.
 1508                           // IF KEY = "C'
 1509    00000078 .............         DC32    KEY, LIT, 43h, EQUAL
                  ...43000000..
                  ......       
 1510    00000088 ........              DC32    ZBRAN
 1511    0000008C E0FFFFFF              DC32      NOT_CO-.
 1512                           // NEXT KEY "0"
 1513    00000090 .............         DC32    KEY, LIT, 4Fh, EQUAL
                  ...4F000000..
                  ......       
 1514    000000A0 ........              DC32    ZBRAN
 1515    000000A4 C8FFFFFF              DC32      NOT_CO-.
 1516                           // NEXT KEY "Enter"
 1517    000000A8 .............         DC32    KEY, LIT, 0Dh, EQUAL
                  ...0D000000..
                  ......       
 1518    000000B8 ........              DC32    ZBRAN
 1519    000000BC B0FFFFFF              DC32      NOT_CO-.
 1520                           // UNTIL
 1521    000000C0 ........              DC32    CR
 1522                           CO_END:
 1523                           #endif
 1524    000000C4 ........              DC32    QUIT    // OI
 1525                           #ifdef ABORT_STOP_TILL_CO
 1526                           $FISH_CO_MSGS.h
    1                           //------------------------------------------------------------------------------
    2                           
    3                            SECTION .text : CONST (2)
    4                           
    5                           // DC8 "?" IS A NULL TERMINATED STRING
    6                           // DC8 '?' IS NOT
    7                           
    8                            ALIGNROM 2,0xFFFFFFFF
    9                           
   10                           // IF this fits in 1114 move to FISH_RM_MSGS.h 
   11                           
   12                           msg_CO:
   13    00000000 204572726F722         DC8     " Error Halt (EHON/EHOFF) - To COntinue Type CO then Enter: "
                  048616C742028
                  45484F4E2F454
                  84F464629202D
                  20546F20434F6
                  E74696E756520
                  5479706520434
                  F207468656E20
                  456E7465723A2
                  000          
   14                           
 1527                           #endif
 1528    0000003C ........              DC32    QUIT    // OI
 1529                           
 1530                           
 1531                           //      COLD COLD:      ( -- )  MODIFIED:
 1532                           //      FIGISH SYSTEM COLD = WARM (INIT RAMVARSPACE) -> type signon MSG ->ABORT
 1533                           //      CLEARS DICTIONAIRY. SEE ABORT.
 1534                           
 1535                            SECTION .text : CONST (2)
 1536                           COLD_NFA:
 1537    00000000 84                    DC8     0x84
 1538    00000001 434F4C                DC8     'COL'
 1539    00000004 C4                    DC8     'D'+0x80
 1540    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1541    00000008 ........              DC32    ABORT_NFA
 1542                           COLD:
 1543    0000000C ........              DC32    DOCOL
 1544    00000010 ........              DC32    WARM            // RAMVARSPACE Init
 1545    00000014 ........              DC32    SIGNON
 1546                           //#ifdef ABORT_STOP_TILL_CO
 1547                           //        DC32    QUIT
 1548                           //#else
 1549    00000018 ........              DC32    ABORT
 1550                           //#endif
 1551                           
 1552                           
 1553                           //=============================== WORDCAT ====================================//
 1554                           //NOEXEC HEADERFORWORDCATEGORIES
 1555                           //      WC_FISH_SYS: = FISH System: CATEGORY
 1556                           
 1557                            SECTION .text : CONST (2)
 1558                           WC_FISH_SYS_NFA:
 1559    00000000 90                    DC8     0x80+4+12
 1560    00000001 0D0A                  DC8     0x0D, 0x0A
 1561    00000003 4649534820537         DC8     'FISH System:'
                  97374656D3A  
 1562    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1563    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1564    00000014 ........              DC32    COLD_NFA
 1565                           
 1566                           
 1567                           //----------------------------- DOTSTACK SECTION -------------------------------
 1568                           //      .SH DOTSHEX:    ( -- )
 1569                           //      Nondestructively print items on stack in HEX, preserving base.
 1570                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1571                           
 1572                            SECTION .text : CONST (2)
 1573                           DOTSHEX_NFA:
 1574    00000000 83                    DC8     0x83
 1575    00000001 2E53                  DC8     '.S'
 1576    00000003 C8                    DC8     'H'+0x80
 1577                            ALIGNROM 2,0xFFFFFFFF
 1578    00000004 ........              DC32    WC_FISH_SYS_NFA
 1579                           DOTSHEX:
 1580    00000008 ........              DC32    DOCOL
 1581                           #ifdef SRM
 1583                           #else
 1584    0000000C ........10000         DC32    LIT, 16, DOTSBASE
                  000........  
 1585                           #endif
 1586    00000018 ........              DC32    SEMIS
 1587                           
 1588                           #ifndef SRM
 1589                           //      .SD DOTSDEC:    ( -- )
 1590                           //      Nondestructively print items on stack in DECIMAL, preserving base.
 1591                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1592                           
 1593                            SECTION .text : CONST (2)
 1594                           DOTSDEC_NFA:
 1595    00000000 83                    DC8     0x83
 1596    00000001 2E53                  DC8     '.S'
 1597    00000003 C4                    DC8     'D'+0x80
 1598                            ALIGNROM 2,0xFFFFFFFF
 1599    00000004 ........              DC32    DOTSHEX_NFA
 1600                           DOTSDEC:
 1601    00000008 ........              DC32    DOCOL
 1602    0000000C ........0A000         DC32    LIT, 10, DOTSBASE
                  000........  
 1603    00000018 ........              DC32    SEMIS
 1604                           
 1605                           
 1606                           //      .SB DOTSBIN:    ( -- )
 1607                           //      Nondestructively print items on stack in BINARY, preserving base.
 1608                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1609                           
 1610                            SECTION .text : CONST (2)
 1611                           DOTSBIN_NFA:
 1612    00000000 83                    DC8     0x83
 1613    00000001 2E53                  DC8     '.S'
 1614    00000003 C2                    DC8     'B'+0x80
 1615                            ALIGNROM 2,0xFFFFFFFF
 1616    00000004 ........              DC32    DOTSDEC_NFA
 1617                           DOTSBIN:
 1618    00000008 ........              DC32    DOCOL
 1619    0000000C .............         DC32    TWO, DOTSBASE
                  ...          
 1620    00000014 ........              DC32    SEMIS
 1621                           #endif // not SRM
 1622                           
 1623                           //      .S DOTS:        ( -- )
 1624                           //      Nondestructively print items on stack in current base.
 1625                           //      Prints TOS 1rst, i.e. TOS, NOS, etc.
 1626                           
 1627                            SECTION .text : CONST (2)
 1628                           DOTS_NFA:
 1629    00000000 82                    DC8     0x82
 1630    00000001 2E                    DC8     '.'
 1631    00000002 D3                    DC8     'S'+0x80
 1632    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1633                           #ifdef SRM
 1635                           #else
 1636    00000004 ........              DC32    DOTSBIN_NFA
 1637                           #endif  // SRM
 1638                           DOTS:
 1639    00000008 ........              DC32    DOCOL
 1640    0000000C .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1641    0000001C .............         DC32    EQUAL, ZEQU, ZBRAN
                  ...........  
 1642    00000028 68000000              DC32    DOTSEND-.                       // IF NOTHING ON STACK
 1643                           
 1644    0000002C ........              DC32    PDOTQ
 1645    00000030 05                    DC8     5
 1646    00000031 544F533E20            DC8     'TOS> '
 1647    00000036 FFFF           ALIGNROM 2,0xFFFFFFFF
 1648                                 
 1649    00000038 .............         DC32    INITSO_SV, AT, SPAT, FOURP
                  .............
                  ......       
 1650    00000048 ........              DC32    XDO
 1651                           
 1652                           DOTSLOOP:
 1653    0000004C .............         DC32    I, AT
                  ...          
 1654    00000054 .............         DC32    BASE_SV, AT
                  ...          
 1655    0000005C ........0A000         DC32    LIT, 10, EQUAL                  // 
                  000........  
 1656    00000068 ........              DC32    ZBRAN                           // NOT = DECIMAL
 1657    0000006C 10000000              DC32    DBSUSEDUDOT-.
 1658                           #ifdef SRM
 1660                           #else
 1661    00000070 ........              DC32    DOT_BASE_SUFFIX
 1662                           #endif  // SRM
 1663    00000074 ........              DC32    BRAN
 1664    00000078 08000000              DC32    DBSUSEDOT-.
 1665                           
 1666                           DBSUSEDUDOT:
 1667                           #ifdef SRM
 1669                           #else
 1670    0000007C ........              DC32    UDOT_BASE_SUFFIX
 1671                           #endif  // SRM
 1672                           DBSUSEDOT:
 1673    00000080 ........              DC32    SPACE
 1674    00000084 .............         DC32    FOUR, XPLOOP
                  ...          
 1675    0000008C C0FFFFFF              DC32    DOTSLOOP-.
 1676                           
 1677                           DOTSEND:
 1678    00000090 ........              DC32    SEMIS
 1679                           
 1680                           
 1681                           //      2DUP TDUP:      ( n2 n1 -- n2 n1 n2 n1 )
 1682                           //      Duplicate top two stack items. The prefix 2 convention means
 1683                           //      an operation on the top two stack items.
 1684                           
 1685                            SECTION .text : CONST (2)
 1686                           TDUP_NFA:
 1687    00000000 84                    DC8     0x84
 1688    00000001 324455                DC8     '2DU'
 1689    00000004 D0                    DC8     'P'+0x80
 1690    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1691    00000008 ........              DC32    DOTS_NFA
 1692                           TDUP:
 1693    0000000C ........              DC32    .+5
 1694                            SECTION .text : CODE (2)
 1695                           // TDUP: OPT by picking pops
 1696    00000000 3868                  LDR     t, [p]          //
 1697    00000002 7A68                  LDR     w, [p, #4]      //
 1698                                   DPUSH                   // 
 1698                                   PUSHw   // push w to p, pre decrement p
 1698.1  00000004 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1698.2  00000006 3A60                  STR     w, [p]
 1698.3                                 ENDM
 1698                                   TPUSH
 1698                                   PUSHt   // push t to p, pre decrement p
 1698.1  00000008 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1698.2  0000000A 3860                  STR     t, [p]
 1698.3                                 ENDM
 1698                                   NEXT
 1698.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1698                                   NEXT1
 1698.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1698.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1698.3                                 ENDM
 1698.4                                 ENDM
 1698.5                                 ENDM
 1698.6                                 ENDM
 1699                           
 1700                           
 1701                           //      -DUP ZNDUP:     ( n1 -- n1 (if zero)
 1702                           //                      ( n1 -- n1 n1 (non-zero)
 1703                           //      Reproduce n1 only if it is non-zero. Used in type andSPACES.
 1704                           //      This is usually used to copy a value just before IF, to eliminate
 1705                           //      the need for an ELSE part to drop it. 
 1706                           
 1707                            SECTION .text : CONST (2)
 1708                           DDUP_NFA:
 1709    00000000 84                    DC8     0x84
 1710    00000001 2D4455                DC8     '-DU'
 1711    00000004 D0                    DC8     'P'+0x80
 1712    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1713    00000008 ........              DC32    TDUP_NFA
 1714                           ZNDUP:
 1715    0000000C ........              DC32    DOCOL
 1716    00000010 ........              DC32    DUP
 1717    00000014 ........              DC32    ZBRAN   // IF
 1718    00000018 08000000              DC32    DDUP1-.
 1719                           
 1720    0000001C ........              DC32    DUP     //endif
 1721                           DDUP1:
 1722    00000020 ........              DC32    SEMIS
 1723                           
 1724                           
 1725                           //      ROT ROT: ( nl n2 n3 --- n2 n3 nl )
 1726                           //      Rotate the top three values on the stack, bringing the third to the top.
 1727                           
 1728                            SECTION .text : CONST (2)
 1729                           ROT_NFA:
 1730    00000000 83                    DC8     0x83
 1731    00000001 524F                  DC8     'RO'
 1732    00000003 D4                    DC8     'T'+0x80
 1733                            ALIGNROM 2,0xFFFFFFFF
 1734    00000004 ........              DC32    DDUP_NFA
 1735                           ROT:
 1736    00000008 ........              DC32    .+5
 1737                            SECTION .text : CODE (2)
 1738                                   POP2w
 1738.1  00000000 3A68                  LDR     w, [p]
 1738.2  00000002 3F1D                  ADDS    p, p, #4
 1738.3                                 ENDM
 1739                                   POP2n
 1739.1  00000004 3968                  LDR     n, [p]
 1739.2  00000006 3F1D                  ADDS    p, p, #4
 1739.3                                 ENDM
 1740                           #ifdef TOSCT
 1742                           #endif
 1743                                   POP2t
 1743.1                         #ifndef TOSCT
 1743.2  00000008 3868                  LDR     t, [p]          // pop tos to t, post increment p
 1743.3                         #endif
 1743.4  0000000A 3F1D                  ADDS    p, p, #4
 1743.5                                 ENDM
 1744                                   PUSHn
 1744.1  0000000C 3F1F                  SUBS    p, p, #4        // push n to p, pre decrement p
 1744.2  0000000E 3960                  STR     n, [p]
 1744.3                                 ENDM
 1745                                   DPUSH                   //  --  LSW MSW )
 1745                                   PUSHw   // push w to p, pre decrement p
 1745.1  00000010 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1745.2  00000012 3A60                  STR     w, [p]
 1745.3                                 ENDM
 1745                                   TPUSH
 1745                                   PUSHt   // push t to p, pre decrement p
 1745.1  00000014 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1745.2  00000016 3860                  STR     t, [p]
 1745.3                                 ENDM
 1745                                   NEXT
 1745.1  00000018 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1745                                   NEXT1
 1745.1  0000001A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1745.2  0000001C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1745.3                                 ENDM
 1745.4                                 ENDM
 1745.5                                 ENDM
 1745.6                                 ENDM
 1746                           
 1747                           
 1748                           //      I I:    ( -- n )
 1749                           //      Used within a DO-LOOP to copy the loop index to the stack. Other use
 1750                           //      is implementation dependent.
 1751                           //      See R.
 1752                           
 1753                            SECTION .text : CONST (2)
 1754                           I_NFA:
 1755    00000000 81                    DC8     0x81
 1756    00000001 C9                    DC8     'I'+0x80
 1757    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1758    00000004 ........              DC32    ROT_NFA
 1759                           I:
 1760    00000008 ........              DC32    .+5
 1761                            SECTION .text : CODE (2)
 1762    00000000 3068                  LDR     t, [r]  // GET INDEX VALUE
 1763                                   TPUSH
 1763                                   PUSHt   // push t to p, pre decrement p
 1763.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1763.2  00000004 3860                  STR     t, [p]
 1763.3                                 ENDM
 1763                                   NEXT
 1763.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1763                                   NEXT1
 1763.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1763.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1763.3                                 ENDM
 1763.4                                 ENDM
 1763.5                                 ENDM
 1764                           
 1765                           
 1766                           //      SP@ SPAT:       ( -- addr )
 1767                           //      ( -- addr = Current TOP of the parameter stack (p) )
 1768                           //      Place the address of the TOP of the parameter stack (p)
 1769                           //      on the parameter stack (p) as it was before RP@ was executed.
 1770                           //      e.g.  1  2  SP@  @  .   .   .     would type 2  2  1
 1771                           
 1772                            SECTION .text : CONST (2)
 1773                           SPAT_NFA:
 1774    00000000 83                    DC8     0x83
 1775    00000001 5350                  DC8     'SP'
 1776    00000003 C0                    DC8     '@'+0x80
 1777                            ALIGNROM 2,0xFFFFFFFF
 1778    00000004 ........              DC32    I_NFA
 1779                           SPAT:
 1780    00000008 ........              DC32    .+5
 1781                            SECTION .text : CODE (2)
 1782    00000000 3846                  MOV     t, p
 1783                                   TPUSH
 1783                                   PUSHt   // push t to p, pre decrement p
 1783.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1783.2  00000004 3860                  STR     t, [p]
 1783.3                                 ENDM
 1783                                   NEXT
 1783.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1783                                   NEXT1
 1783.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1783.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1783.3                                 ENDM
 1783.4                                 ENDM
 1783.5                                 ENDM
 1784                           
 1785                           
 1786                           //      RP@ RPAT:       ( -- addr )
 1787                           //      ( -- addr = Current TOP of the Return Stack (r) )
 1788                           //      Place the address of the TOP of the return stack (r)
 1789                           //      on the parameter stack (p) as it was before RP@ was executed.
 1790                           //      e.g.  1 >R  2 >R  RP@  @  .   .   . would type 2  2  1
 1791                           
 1792                            SECTION .text : CONST (2)
 1793                           RPAT_NFA:
 1794    00000000 83                    DC8     0x83
 1795    00000001 5250                  DC8     'RP'
 1796    00000003 C0                    DC8     '@'+0x80
 1797                            ALIGNROM 2,0xFFFFFFFF
 1798    00000004 ........              DC32    SPAT_NFA
 1799                           RPAT:
 1800    00000008 ........              DC32    .+5
 1801                            SECTION .text : CODE (2)
 1802    00000000 3046                  MOV     t, r
 1803                                   TPUSH
 1803                                   PUSHt   // push t to p, pre decrement p
 1803.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1803.2  00000004 3860                  STR     t, [p]
 1803.3                                 ENDM
 1803                                   NEXT
 1803.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1803                                   NEXT1
 1803.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1803.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1803.3                                 ENDM
 1803.4                                 ENDM
 1803.5                                 ENDM
 1804                           
 1805                           
 1806                           //      LEAVE LEAVE:    ( -- )
 1807                           //      Force termination of a DO-LOOP at the next opportunity by setting
 1808                           //      the loop limit equal to the current value of the index. The index
 1809                           //      itself remains unchanged, and execution proceeds until LOOP
 1810                           //      or +LOOP is encountered.
 1811                           
 1812                            SECTION .text : CONST (2)
 1813                           LEAVE_NFA:
 1814    00000000 85                    DC8     0x85
 1815    00000001 4C454156              DC8     'LEAV'
 1816    00000005 C5                    DC8     'E'+0x80
 1817    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 1818                           //      DC32    RPSTO_NFA
 1819    00000008 ........              DC32    RPAT_NFA
 1820                           LEAVE:
 1821    0000000C ........              DC32    .+5
 1822                            SECTION .text : CODE (2)
 1823    00000000 3268                  LDR     w, [r]          // GET Index
 1824    00000002 7260                  STR     w, [r, #4]  // Store it at Limit
 1825                                   NEXT
 1825.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1825                                   NEXT1
 1825.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1825.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1825.3                                 ENDM
 1825.4                                 ENDM
 1826                           
 1827                           
 1828                           //      R> RFROM:       ( -- n )                           L0
 1829                           //      Remove the top value from the return stack and leave it on the
 1830                           //      computation stack. See >R and R.
 1831                           
 1832                            SECTION .text : CONST (2)
 1833                           RFROM_NFA:
 1834    00000000 82                    DC8     0x82
 1835    00000001 52                    DC8     'R'
 1836    00000002 BE                    DC8     '>'+0x80
 1837    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1838    00000004 ........              DC32    LEAVE_NFA
 1839                           RFROM:
 1840    00000008 ........              DC32    .+5
 1841                            SECTION .text : CODE (2)
 1842                                   POPr2t
 1842.1  00000000 3068                  LDR     t, [r]
 1842.2  00000002 361D                  ADDS    r, r, #4
 1842.3                                 ENDM
 1843                                   TPUSH
 1843                                   PUSHt   // push t to p, pre decrement p
 1843.1  00000004 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1843.2  00000006 3860                  STR     t, [p]
 1843.3                                 ENDM
 1843                                   NEXT
 1843.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1843                                   NEXT1
 1843.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1843.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1843.3                                 ENDM
 1843.4                                 ENDM
 1843.5                                 ENDM
 1844                           
 1845                           
 1846                           //      R R:    ( -- n )
 1847                           //      Copy the top of the return stack to the computation stack.
 1848                           
 1849                            SECTION .text : CONST (2)
 1850                           R_NFA:
 1851    00000000 81                    DC8     0x81
 1852    00000001 D2                    DC8     'R'+0x80
 1853    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 1854    00000004 ........              DC32    RFROM_NFA
 1855                           R:
 1856    00000008 ........              DC32    .+5
 1857                            SECTION .text : CODE (2)
 1858    00000000 3068                  LDR     t, [r]  // Get Index
 1859                                   TPUSH
 1859                                   PUSHt   // push t to p, pre decrement p
 1859.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1859.2  00000004 3860                  STR     t, [p]
 1859.3                                 ENDM
 1859                                   NEXT
 1859.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1859                                   NEXT1
 1859.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1859.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1859.3                                 ENDM
 1859.4                                 ENDM
 1859.5                                 ENDM
 1860                           
 1861                           //      >R TOR: ( n -- )
 1862                           //      Remove a number from the computation stack and place as the most
 1863                           //      accessable on the return stack. Use should be balanced with R> in
 1864                           //      the same definition.
 1865                           
 1866                            SECTION .text : CONST (2)
 1867                           TOR_NFA:
 1868    00000000 82                    DC8     0x82
 1869    00000001 3E                    DC8     '>'
 1870    00000002 D2                    DC8     'R'+0x80
 1871    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 1872    00000004 ........              DC32    R_NFA
 1873                           TOR:
 1874    00000008 ........              DC32    .+5
 1875                            SECTION .text : CODE (2)
 1876                                   POP2n   // preserve TOS
 1876.1  00000000 3968                  LDR     n, [p]
 1876.2  00000002 3F1D                  ADDS    p, p, #4
 1876.3                                 ENDM
 1877                                   PUSHn2r
 1877.1  00000004 361F                  SUBS    r, r, #4        //  push t to r, pre decrement r
 1877.2  00000006 3160                  STR     n, [r]
 1877.3                                 ENDM
 1878                           #ifdef TOSCT
 1880                           #endif
 1881                                   NEXT
 1881.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1881                                   NEXT1
 1881.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1881.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1881.3                                 ENDM
 1881.4                                 ENDM
 1882                           
 1883                           
 1884                           //      OVER OVER:      ( nl n2 -- nl n2 n1 )
 1885                           //      Copy the second stack value, placing it as the new top.
 1886                           
 1887                            SECTION .text : CONST (2)
 1888                           OVER_NFA:
 1889    00000000 84                    DC8     0x84
 1890    00000001 4F5645                DC8     'OVE'
 1891    00000004 D2                    DC8     'R'+0x80
 1892    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1893    00000008 ........              DC32    TOR_NFA
 1894                           OVER:
 1895    0000000C ........              DC32    .+5
 1896                            SECTION .text : CODE (2)
 1897                                   POP2w           // n2
 1897.1  00000000 3A68                  LDR     w, [p]
 1897.2  00000002 3F1D                  ADDS    p, p, #4
 1897.3                                 ENDM
 1898                           #ifdef TOSCT
 1902                           #else
 1903                                   POP2t           // n1
 1903.1                         #ifndef TOSCT
 1903.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 1903.3                         #endif
 1903.4  00000006 3F1D                  ADDS    p, p, #4
 1903.5                                 ENDM
 1904                           #endif
 1905                                   PUSHt           // -- n1 )
 1905.1  00000008 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1905.2  0000000A 3860                  STR     t, [p]
 1905.3                                 ENDM
 1906                                   DPUSH           //  --  LSW MSW )
 1906                                   PUSHw   // push w to p, pre decrement p
 1906.1  0000000C 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1906.2  0000000E 3A60                  STR     w, [p]
 1906.3                                 ENDM
 1906                                   TPUSH
 1906                                   PUSHt   // push t to p, pre decrement p
 1906.1  00000010 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1906.2  00000012 3860                  STR     t, [p]
 1906.3                                 ENDM
 1906                                   NEXT
 1906.1  00000014 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1906                                   NEXT1
 1906.1  00000016 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1906.2  00000018 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1906.3                                 ENDM
 1906.4                                 ENDM
 1906.5                                 ENDM
 1906.6                                 ENDM
 1907                           
 1908                           
 1909                           //      DROP DROP:      ( n1 -- )
 1910                           //      Drop n1 from the stack.
 1911                           
 1912                            SECTION .text : CONST (2)
 1913                           DROP_NFA:
 1914    00000000 84                    DC8     0x84
 1915    00000001 44524F                DC8     'DRO'
 1916    00000004 D0                    DC8     'P'+0x80
 1917    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1918    00000008 ........              DC32    OVER_NFA
 1919                           DROP:
 1920    0000000C ........              DC32    .+5
 1921                            SECTION .text : CODE (2)
 1922                           #ifdef TOSCT
 1926                           #else // DROP:
 1927                           //        POP2t         // Opt to just do p
 1928    00000000 3F1D                  ADDS    p, p, #4
 1929                           
 1930                           #endif
 1931                                   NEXT
 1931.1  00000002 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1931                                   NEXT1
 1931.1  00000004 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1931.2  00000006 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1931.3                                 ENDM
 1931.4                                 ENDM
 1932                           
 1933                           
 1934                           //      SWAP SWAP:      ( nl n2 -- n2 n1 )
 1935                           //      Exchange the top two values On the stack.
 1936                           
 1937                            SECTION .text : CONST (2)
 1938                           SWAP_NFA:
 1939    00000000 84                    DC8     0x84
 1940    00000001 535741                DC8     'SWA'
 1941    00000004 D0                    DC8     'P'+0x80
 1942    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1943    00000008 ........              DC32    DROP_NFA
 1944                           SWAP:
 1945    0000000C ........              DC32    .+5
 1946                            SECTION .text : CODE (2)
 1947                           #ifdef TOSCT
 1951                           #else // SWAP:
 1952                                   POP2w           // n2
 1952.1  00000000 3A68                  LDR     w, [p]
 1952.2  00000002 3F1D                  ADDS    p, p, #4
 1952.3                                 ENDM
 1953                                   POP2t           // n1
 1953.1                         #ifndef TOSCT
 1953.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 1953.3                         #endif
 1953.4  00000006 3F1D                  ADDS    p, p, #4
 1953.5                                 ENDM
 1954                           #endif
 1955                                   DPUSH           //  --  LSW MSW )
 1955                                   PUSHw   // push w to p, pre decrement p
 1955.1  00000008 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 1955.2  0000000A 3A60                  STR     w, [p]
 1955.3                                 ENDM
 1955                                   TPUSH
 1955                                   PUSHt   // push t to p, pre decrement p
 1955.1  0000000C 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1955.2  0000000E 3860                  STR     t, [p]
 1955.3                                 ENDM
 1955                                   NEXT
 1955.1  00000010 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1955                                   NEXT1
 1955.1  00000012 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1955.2  00000014 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1955.3                                 ENDM
 1955.4                                 ENDM
 1955.5                                 ENDM
 1955.6                                 ENDM
 1956                           
 1957                           
 1958                           //      DUP DUP:        ( n1 -- n1 n1 )
 1959                           //      Duplicate the value n1 on the stack.
 1960                           
 1961                            SECTION .text : CONST (2)
 1962                           DUP_NFA:
 1963    00000000 83                    DC8     0x83
 1964    00000001 4455                  DC8     'DU'
 1965    00000003 D0                    DC8     'P'+0x80
 1966                            ALIGNROM 2,0xFFFFFFFF
 1967    00000004 ........              DC32    SWAP_NFA
 1968                           DUP:
 1969    00000008 ........              DC32    .+5
 1970                            SECTION .text : CODE (2)
 1971                           //#ifdef TOSCT
 1972                           // NO NEED TO REFRESH t ?
 1973                           //#else DUP:
 1974                           // OPT by picking pops
 1975    00000000 3868                  LDR     t, [p]
 1976                           //#endif
 1977                                   TPUSH
 1977                                   PUSHt   // push t to p, pre decrement p
 1977.1  00000002 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 1977.2  00000004 3860                  STR     t, [p]
 1977.3                                 ENDM
 1977                                   NEXT
 1977.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 1977                                   NEXT1
 1977.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 1977.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 1977.3                                 ENDM
 1977.4                                 ENDM
 1977.5                                 ENDM
 1978                           
 1979                           //=============================== WORDCAT ====================================//
 1980                           //NOEXEC HEADERFORWORDCATEGORIES
 1981                           //      WC_STACK_NFA = Stack Stuff: CATEGORY
 1982                           
 1983                            SECTION .text : CONST (2)
 1984                           WC_STACK_NFA:
 1985    00000000 90                    DC8     0x80+4+12
 1986    00000001 0D0A                  DC8     0x0D, 0x0A
 1987    00000003 537461636B205         DC8     'Stack Stuff:'
                  3747566663A  
 1988    0000000F 0D8A                  DC8     0x0D, 0x0A+0x80
 1989    00000011 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 1990    00000014 ........              DC32    DUP_NFA
 1991                           
 1992                           
 1993                           //      ANDBITS ANDBITS:        ( addr val -- )
 1994                           
 1995                            SECTION .text : CONST (2)
 1996                           ANDBITS_NFA:
 1997    00000000 87                    DC8     0x87
 1998    00000001 414E44424954          DC8     'ANDBIT'
 1999    00000007 D3                    DC8     'S'+0x80
 2000                            ALIGNROM 2,0xFFFFFFFF
 2001    00000008 ........              DC32    WC_STACK_NFA
 2002                           ANDBITS:
 2003    0000000C ........              DC32    .+5
 2004                            SECTION .text : CODE (2)
 2005                                   POPp2w          // val
 2005.1                                 // as in xeq token at ToS setup for exec
 2005.2  00000000 04CF                  LDM     p!, {w} // fetch memory p points to into {w}, inc p
 2005.3                                 ENDM
 2006                                   POP2n           // addr
 2006.1  00000002 3968                  LDR     n, [p]
 2006.2  00000004 3F1D                  ADDS    p, p, #4
 2006.3                                 ENDM
 2007    00000006 0868                  LDR     t, [n]  // read [val]
 2008    00000008 1040                  ANDS    t, t, w // modify val
 2009    0000000A 0860                  STR     t, [n]  // Write val
 2010                                   NEXT
 2010.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2010                                   NEXT1
 2010.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2010.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2010.3                                 ENDM
 2010.4                                 ENDM
 2011                           
 2012                           
 2013                           //      SETBITS SETBITS:        ( addr val -- )
 2014                           //      OR val bits into addr. See also CLRBITS.
 2015                           //      Preserves bits at addr - useful for ARM SoC initialization.
 2016                           
 2017                            SECTION .text : CONST (2)
 2018                           SETBITS_NFA:
 2019    00000000 87                    DC8     0x87
 2020    00000001 534554424954          DC8     'SETBIT'
 2021    00000007 D3                    DC8     'S'+0x80
 2022                            ALIGNROM 2,0xFFFFFFFF
 2023    00000008 ........              DC32    ANDBITS_NFA
 2024                           SETBITS:
 2025    0000000C ........              DC32    .+5
 2026                            SECTION .text : CODE (2)
 2027                                   POPp2w          // val
 2027.1                                 // as in xeq token at ToS setup for exec
 2027.2  00000000 04CF                  LDM     p!, {w} // fetch memory p points to into {w}, inc p
 2027.3                                 ENDM
 2028                                   POP2n           // addr
 2028.1  00000002 3968                  LDR     n, [p]
 2028.2  00000004 3F1D                  ADDS    p, p, #4
 2028.3                                 ENDM
 2029    00000006 0868                  LDR     t, [n]  // read[val]
 2030    00000008 1043                  ORRS    t, t, w // modify val
 2031    0000000A 0860                  STR     t, [n]  // Write val
 2032                                   NEXT
 2032.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2032                                   NEXT1
 2032.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2032.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2032.3                                 ENDM
 2032.4                                 ENDM
 2033                           
 2034                           
 2035                           //      CLRBITS CLRBITS:        ( addr val -- )
 2036                           //      XOR val bits into addr. See also SETBITS.
 2037                           //      Preserves bits at addr - useful for ARM SoC initialization.
 2038                           
 2039                            SECTION .text : CONST (2)
 2040                           CLRBITS_NFA:
 2041    00000000 87                    DC8     0x87
 2042    00000001 434C52424954          DC8     'CLRBIT'
 2043    00000007 D3                    DC8     'S'+0x80
 2044                            ALIGNROM 2,0xFFFFFFFF
 2045    00000008 ........              DC32    SETBITS_NFA
 2046                           CLRBITS:
 2047    0000000C ........              DC32    .+5
 2048                            SECTION .text : CODE (2)
 2049                                   POPp2w                  // val
 2049.1                                 // as in xeq token at ToS setup for exec
 2049.2  00000000 04CF                  LDM     p!, {w} // fetch memory p points to into {w}, inc p
 2049.3                                 ENDM
 2050                                   POP2n                   // addr
 2050.1  00000002 3968                  LDR     n, [p]
 2050.2  00000004 3F1D                  ADDS    p, p, #4
 2050.3                                 ENDM
 2051    00000006 0868                  LDR     t, [n]          // read [val]
 2052    00000008 9043                  BICS    t, t, w         // modify val  - AND-NOT
 2053    0000000A 0860                  STR     t, [n]          // write val
 2054                                   NEXT
 2054.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2054                                   NEXT1
 2054.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2054.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2054.3                                 ENDM
 2054.4                                 ENDM
 2055                           
 2056                           
 2057                           //      CMOVE CMOVE:    ( from to count -- )
 2058                           //      Move the specified quantity of bytes beginning at address from to
 2059                           //      address to. The contents of address from is moved first proceeding
 2060                           //      toward high memory. Further specification is necessary on word
 2061                           //      addressing computers.
 2062                           
 2063                            SECTION .text : CONST (2)
 2064                           CMOVE_NFA:
 2065    00000000 85                    DC8     0x85
 2066    00000001 434D4F56              DC8     'CMOV'
 2067    00000005 C5                    DC8     'E'+0x80
 2068    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2069    00000008 ........              DC32    CLRBITS_NFA
 2070                           CMOVE:
 2071    0000000C ........              DC32    .+5
 2072                            SECTION .text : CODE (2)
 2073                                   POP2n //    ldr n, [p],#4      //COUNT
 2073.1  00000000 3968                  LDR     n, [p]
 2073.2  00000002 3F1D                  ADDS    p, p, #4
 2073.3                                 ENDM
 2074                                   POP2w //    ldr w, [p],#4      //DEST
 2074.1  00000004 3A68                  LDR     w, [p]
 2074.2  00000006 3F1D                  ADDS    p, p, #4
 2074.3                                 ENDM
 2075                                   POP2x //    ldr x, [p],#4      //SOURCE
 2075.1  00000008 3B68                  LDR     x, [p]
 2075.2  0000000A 3F1D                  ADDS    p, p, #4
 2075.3                                 ENDM
 2076    0000000C 0029                  CMP     n, #0
 2077    0000000E 07D0                  BEQ     CM2
 2078                           CM1:
 2079                           //not for THUMB
 2080                           //strcpy  LDRB R2, [R1], #1
 2081                           //        STRB R2, [R0], #1
 2082                           //        TST R2, R2      // repeat if R2 is nonzero
 2083                           //        BNE strcpy
 2084    00000010 1878                  LDRB    t, [x]
 2085    00000012 1070                  STRB    t, [w]
 2086    00000014 491E                  SUBS    n, n, #1
 2087    00000016 0029                  CMP     n, #0
 2088    00000018 02D0                  BEQ     CM2
 2089                           
 2090    0000001A 521C                  ADDS    w, w, #1
 2091    0000001C 5B1C                  ADDS    x, x, #1
 2092    0000001E F7D1                  BNE     CM1
 2093                           CM2:
 2094                           #ifdef TOSCT
 2096                           #endif
 2097                                   NEXT
 2097.1  00000020 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2097                                   NEXT1
 2097.1  00000022 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2097.2  00000024 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2097.3                                 ENDM
 2097.4                                 ENDM
 2098                           
 2099                           
 2100                           //      FILL FILL:      ( addr quan b -- )
 2101                           //      Fill memory at the address with the specified quantity of bytes b.
 2102                           
 2103                            SECTION .text : CONST (2)
 2104                           FILL_NFA:
 2105    00000000 84                    DC8     0x84
 2106    00000001 46494C                DC8     'FIL'
 2107    00000004 CC                    DC8     'L'+0x80
 2108    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2109    00000008 ........              DC32    CMOVE_NFA
 2110                           FILL:
 2111    0000000C ........              DC32    .+5
 2112                            SECTION .text : CODE (2)
 2113                                   POP2t                   // Fill CHAR
 2113.1                         #ifndef TOSCT
 2113.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 2113.3                         #endif
 2113.4  00000002 3F1D                  ADDS    p, p, #4
 2113.5                                 ENDM
 2114                                   POP2n                   // Fill COUNT
 2114.1  00000004 3968                  LDR     n, [p]
 2114.2  00000006 3F1D                  ADDS    p, p, #4
 2114.3                                 ENDM
 2115                                   POP2w                   // Beginning ADDR
 2115.1  00000008 3A68                  LDR     w, [p]
 2115.2  0000000A 3F1D                  ADDS    p, p, #4
 2115.3                                 ENDM
 2116    0000000C 0029                  CMP     n, #0
 2117    0000000E 04D0                  BEQ     FEND            // Count is zero
 2118    00000010 8B18                  ADDS    x, n, w
 2119                           FLOOP:
 2120    00000012 1070                  STRB    t, [w]
 2121    00000014 521C                  ADDS    w, w, #1
 2122    00000016 9A42                  CMP     w, x
 2123    00000018 FBD1                  BNE     FLOOP
 2124                           FEND:
 2125                           #ifdef TOSCT
 2127                           #endif
 2128                                   NEXT
 2128.1  0000001A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2128                                   NEXT1
 2128.1  0000001C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2128.2  0000001E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2128.3                                 ENDM
 2128.4                                 ENDM
 2129                           
 2130                           
 2131                           //      ERASE ERASE:    ( addr n -- )
 2132                           //      Clear a region of memory to zero from addr over n addresses.
 2133                           
 2134                            SECTION .text : CONST (2)
 2135                           ERASE_NFA:
 2136    00000000 85                    DC8     0x85
 2137    00000001 45524153              DC8     'ERAS'
 2138    00000005 C5                    DC8     'E'+0x80
 2139    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2140    00000008 ........              DC32    FILL_NFA
 2141                           ERASE:
 2142    0000000C ........              DC32    DOCOL
 2143    00000010 ........              DC32    ZERO
 2144    00000014 ........              DC32    FILL
 2145    00000018 ........              DC32    SEMIS
 2146                           
 2147                           
 2148                           //      BLANKS BLANKS:  ( addr count -- )
 2149                           //      Fill an area of memory beginning at addr with blanks (0x20).
 2150                           
 2151                            SECTION .text : CONST (2)
 2152                           BLANKS_NFA:
 2153    00000000 86                    DC8     0x86
 2154    00000001 424C414E4B            DC8     'BLANK'
 2155    00000006 D3                    DC8     'S'+0x80
 2156    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2157    00000008 ........              DC32    ERASE_NFA
 2158                           BLANKS:
 2159    0000000C ........              DC32    DOCOL
 2160    00000010 ........              DC32    BLANK
 2161    00000014 ........              DC32    FILL
 2162    00000018 ........              DC32    SEMIS
 2163                           
 2164                           
 2165                           //      +! PSTORE:      ( n addr -- )
 2166                           //      Add n to the value at the address.
 2167                           //      Pronounced Plus Store
 2168                           
 2169                            SECTION .text : CONST (2)
 2170                           PSTORE_NFA:
 2171    00000000 82                    DC8     0x82
 2172    00000001 2B                    DC8     '+'
 2173    00000002 A1                    DC8     '!'+0x80
 2174    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2175    00000004 ........              DC32    BLANKS_NFA
 2176                           PSTORE:
 2177    00000008 ........              DC32    .+5
 2178                            SECTION .text : CODE (2)
 2179                                   POP2n                   // ADDRESS
 2179.1  00000000 3968                  LDR     n, [p]
 2179.2  00000002 3F1D                  ADDS    p, p, #4
 2179.3                                 ENDM
 2180                           #ifdef TOSCT
 2182                           #endif
 2183                                   POP2t                   // INCREMENT
 2183.1                         #ifndef TOSCT
 2183.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 2183.3                         #endif
 2183.4  00000006 3F1D                  ADDS    p, p, #4
 2183.5                                 ENDM
 2184    00000008 0A68                  LDR     w, [n]
 2185    0000000A 8018                  ADDS    t, t, w
 2186    0000000C 0860                  STR     t, [n]
 2187                                   NEXT
 2187.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2187                                   NEXT1
 2187.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2187.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2187.3                                 ENDM
 2187.4                                 ENDM
 2188                           
 2189                           
 2190                           //      @ AT:   ( addr -- n )
 2191                           //      Read 32 bit contents of address to TOS.
 2192                           //      Pronounced Fetch, as in Fetch word at addr.
 2193                           
 2194                            SECTION .text : CONST (2)
 2195                           AT_NFA:
 2196    00000000 81                    DC8     0x81
 2197    00000001 C0                    DC8     '@'+0x80 //C0H
 2198    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2199                           //      DC32    TOGGLE_NFA
 2200    00000004 ........              DC32    PSTORE_NFA
 2201                           AT:
 2202    00000008 ........              DC32    .+5
 2203                            SECTION .text : CODE (2)
 2204                           //#ifdef TOSCT
 2205                           //        LDR     t, [t]
 2206                           //        STR     t, [p]
 2207                           //        NEXT
 2208                           //#else AT:
 2209                                   POP2n
 2209.1  00000000 3968                  LDR     n, [p]
 2209.2  00000002 3F1D                  ADDS    p, p, #4
 2209.3                                 ENDM
 2210    00000004 0868                  LDR     t, [n]
 2211                                   TPUSH
 2211                                   PUSHt   // push t to p, pre decrement p
 2211.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 2211.2  00000008 3860                  STR     t, [p]
 2211.3                                 ENDM
 2211                                   NEXT
 2211.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2211                                   NEXT1
 2211.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2211.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2211.3                                 ENDM
 2211.4                                 ENDM
 2211.5                                 ENDM
 2212                           //#endif
 2213                                   
 2214                           //      C@ CAT: ( addr -- b )
 2215                           //      Leave the 8 bit contents of addr on the stack.
 2216                           //      Pronounced "Char Fetch", as in Fetch byte at addr.
 2217                           
 2218                            SECTION .text : CONST (2)
 2219                           CAT_NFA:
 2220    00000000 82                    DC8     0x82
 2221    00000001 43                    DC8     'C'
 2222    00000002 C0                    DC8     '@'+0x80 //C0H
 2223    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2224    00000004 ........              DC32    AT_NFA
 2225                           CAT:
 2226    00000008 ........              DC32    .+5
 2227                            SECTION .text : CODE (2)
 2228                                   POP2n
 2228.1  00000000 3968                  LDR     n, [p]
 2228.2  00000002 3F1D                  ADDS    p, p, #4
 2228.3                                 ENDM
 2229    00000004 0878                  LDRB    t, [n]
 2230                                   TPUSH
 2230                                   PUSHt   // push t to p, pre decrement p
 2230.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 2230.2  00000008 3860                  STR     t, [p]
 2230.3                                 ENDM
 2230                                   NEXT
 2230.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2230                                   NEXT1
 2230.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2230.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2230.3                                 ENDM
 2230.4                                 ENDM
 2230.5                                 ENDM
 2231                           
 2232                           
 2233                           //      ! STORE:        ( n addr -- )
 2234                           //      Store n at address. Pronounced "Store".
 2235                           
 2236                            SECTION .text : CONST (2)
 2237                           STORE_NFA:
 2238    00000000 81                    DC8     0x81
 2239    00000001 A1                    DC8     '!'+0x80
 2240    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2241    00000004 ........              DC32    CAT_NFA
 2242                           STORE:
 2243    00000008 ........              DC32    .+5
 2244                            SECTION .text : CODE (2)
 2245                                   POP2t           // ADDR
 2245.1                         #ifndef TOSCT
 2245.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 2245.3                         #endif
 2245.4  00000002 3F1D                  ADDS    p, p, #4
 2245.5                                 ENDM
 2246                                   POP2n           // DATA
 2246.1  00000004 3968                  LDR     n, [p]
 2246.2  00000006 3F1D                  ADDS    p, p, #4
 2246.3                                 ENDM
 2247    00000008 0160                  STR     n, [t]
 2248                                   NEXT
 2248.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2248                                   NEXT1
 2248.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2248.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2248.3                                 ENDM
 2248.4                                 ENDM
 2249                           
 2250                           
 2251                           //      C! CSTORE:      ( n addr -- )
 2252                           //      Store LS 8 bits of n at address. Pronounced "Char Store".
 2253                           
 2254                            SECTION .text : CONST (2)
 2255                           CSTORE_NFA:
 2256    00000000 82                    DC8     0x82
 2257    00000001 43                    DC8     'C'
 2258    00000002 A1                    DC8     '!'+0x80
 2259    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2260    00000004 ........              DC32    STORE_NFA
 2261                           CSTORE:
 2262    00000008 ........              DC32    .+5
 2263                            SECTION .text : CODE (2)
 2264                                   POP2t
 2264.1                         #ifndef TOSCT
 2264.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 2264.3                         #endif
 2264.4  00000002 3F1D                  ADDS    p, p, #4
 2264.5                                 ENDM
 2265                                   POP2n
 2265.1  00000004 3968                  LDR     n, [p]
 2265.2  00000006 3F1D                  ADDS    p, p, #4
 2265.3                                 ENDM
 2266    00000008 0170                  STRB    n, [t]
 2267                                   NEXT
 2267.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 2267                                   NEXT1
 2267.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 2267.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 2267.3                                 ENDM
 2267.4                                 ENDM
 2268                           
 2269                           
 2270                           //=============================== WORDCAT ====================================//
 2271                           //NOEXEC HEADERFORWORDCATEGORIES
 2272                           //      WC_RWMEMORY_NFA = Read and Write Memory With: CATEGORY
 2273                           
 2274                            SECTION .text : CONST (2)
 2275                           WC_RWMEMORY_NFA:
 2276    00000000 9F                    DC8     0x80+31
 2277    00000001 0D0A                  DC8     0x0D, 0x0A
 2278    00000003 5265616420616         DC8     'Read and Write Memory With:'
                  E642057726974
                  65204D656D6F7
                  2792057697468
                  3A           
 2279    0000001E 0D8A                  DC8     0x0D, 0x0A+0x80
 2280                            ALIGNROM 2,0xFFFFFFFF
 2281    00000020 ........              DC32    CSTORE_NFA
 2282                           
 2283                           
 2284                           //      ] RBRAC:        ( -- )
 2285                           //      Resume compilation, by STATE back to 0xC0 (zero is interpreting)
 2286                           //      0xC0 STATE  used in INTERPRET to execute Immediate words while compiling
 2287                           //      See [.
 2288                           
 2289                            SECTION .text : CONST (2)
 2290                           RBRAC_NFA:
 2291    00000000 81                    DC8     0x81
 2292    00000001 DD                    DC8     ']'+0x80
 2293    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2294                           //      DC32    SMUDGE_NFA
 2295    00000004 ........              DC32    WC_RWMEMORY_NFA
 2296                           RBRAC:
 2297    00000008 ........              DC32    DOCOL
 2298    0000000C ........C0000         DC32    STRVA, 0xC0, CSTATE
                  000........  
 2299    00000018 ........              DC32    SEMIS
 2300                           
 2301                           
 2302                           //      [ LBRAC:        ( -- ) IMMEDIATE
 2303                           //      Used in a colon-definition in form
 2304                           //              xxx    [  words   ]    more
 2305                           //      Suspend compilation by setting STATE to zero (0xC0 is compiling).
 2306                           //      The words after [ are executed, not compiled. This allows calculation
 2307                           //      or compilation exceptions before resuming compilation with ] .
 2308                           //      See LITERAL and ]
 2309                           
 2310                            SECTION .text : CONST (2)
 2311                           LBRAC_NFA:
 2312    00000000 C1                    DC8     0x0C1
 2313    00000001 DB                    DC8     '['+0x80
 2314    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2315    00000004 ........              DC32    RBRAC_NFA
 2316                           LBRAC:
 2317    00000008 ........              DC32    DOCOL
 2318    0000000C ........00000         DC32    STRVA, 0, CSTATE
                  000........  
 2319    00000018 ........              DC32    SEMIS
 2320                           
 2321                           
 2322                           //      [COMPILE] BCOMP:        ( -- ) IMMEDIATE
 2323                           //      Used in a colon-definition in form:
 2324                           //              :  xxx    [COMPILE]   immediate_word   ;
 2325                           //      [COMPILE] will force the compilation of an IMMEDIATE WORD
 2326                           //      that would otherwise execute during compilation. The above example
 2327                           //      will select the FORTH vocabulary then xxx executes, rather than at
 2328                           //      compile time.
 2329                           
 2330                            SECTION .text : CONST (2)
 2331                           BCOMP_NFA:
 2332    00000000 C9                    DC8     0x0C9
 2333    00000001 5B434F4D50494         DC8     '[COMPILE'
                  C45          
 2334    00000009 DD                    DC8     ']'+0x80
 2335    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2336    0000000C ........              DC32    LBRAC_NFA
 2337                           BCOMP:
 2338    00000010 ........              DC32    DOCOL
 2339    00000014 ........              DC32    DFIND   // noop there for TIB entry
 2340                           //      -FIND ( --- pfa len tf )(found) ( --- ff ) (not found)
 2341    00000018 ........              DC32    ZEQU
 2342    0000001C .............         DC32    LIT, msg_qstack
                  ...          
 2343    00000024 ........              DC32    QERROR    // ( f nullstr-addr -- )
 2344    00000028 ........              DC32    DROP
 2345    0000002C ........              DC32    CFA
 2346    00000030 ........              DC32    COMMA   // alighned, INCREMENTS DP REFLECTED by HERE
 2347    00000034 ........              DC32    SEMIS
 2348                           
 2349                           
 2350                           //      DLITERAL DLITERAL:      ( d -- d ) IMMEDIATE
 2351                           //                              ( d -- )   (compiling)
 2352                           //      If compiling, compile a stack double number into a literal. Later
 2353                           //      execution of the definition containing the literal will push it to
 2354                           //      the stack. If executing, the number will remain on the stack.
 2355                           //      : xxx    [ calculate ]  DLITERAL  ; //
 2356                           
 2357                            SECTION .text : CONST (2)
 2358                           DLITERAL_NFA:
 2359    00000000 C8                    DC8     0x0C8
 2360    00000001 444C495445524         DC8     'DLITERA'
                  1            
 2361    00000008 CC                    DC8     'L'+0x80
 2362    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2363    0000000C ........              DC32    BCOMP_NFA
 2364                           DLITERAL:
 2365    00000010 ........              DC32    DOCOL
 2366    00000014 ........              DC32    STATE_SV
 2367    00000018 ........              DC32    AT
 2368    0000001C ........              DC32    ZBRAN   // IF
 2369    00000020 10000000              DC32     DLIT1-.
 2370                           
 2371    00000024 ........              DC32    SWAP
 2372    00000028 ........              DC32    LITERAL
 2373    0000002C ........              DC32    LITERAL // endif
 2374                           DLIT1:
 2375    00000030 ........              DC32    SEMIS
 2376                           
 2377                           
 2378                           //      LITERAL LITERAL:        ( n -- ) IMMEDIATE
 2379                           //      If compiling, then compile the stack value n as a 32 bit literal.
 2380                           //      This definition is immediate so that it will execute during a colon
 2381                           //      definition. The intended use is:
 2382                           //      : xxx    [ calculate ]  LITERAL  ; //
 2383                           //      Compilation is suspended for the compile time calculation of value.
 2384                           //      Compilation is resumed and LITERAL compiles this value.
 2385                           
 2386                            SECTION .text : CONST (2)
 2387                           LITERAL_NFA:
 2388    00000000 C7                    DC8     0x0C7
 2389    00000001 4C4954455241          DC8     'LITERA'
 2390    00000007 CC                    DC8     'L'+0x80
 2391                            ALIGNROM 2,0xFFFFFFFF
 2392    00000008 ........              DC32    DLITERAL_NFA
 2393                           LITERAL:
 2394    0000000C ........              DC32    DOCOL
 2395    00000010 ........              DC32    STATE_SV
 2396    00000014 ........              DC32    AT
 2397    00000018 ........              DC32    ZBRAN           // If not compiling
 2398    0000001C 10000000              DC32     LITE1-.        // go here
 2399                           
 2400    00000020 ........              DC32    COMP            // Compile
 2401    00000024 ........              DC32    LIT             // Literal
 2402    00000028 ........              DC32    COMMA           // Then COMPILE THE LITERAL VALUE
 2403                           LITE1:
 2404    0000002C ........              DC32    SEMIS
 2405                           
 2406                           
 2407                           //      #> EDIGS:       ( d=(LSW MSW) -- addr count )
 2408                           //      Terminates numeric output conversion by dropping dnum,
 2409                           //      leaving the text address and character count suitable for type.
 2410                           
 2411                            SECTION .text : CONST (2)
 2412                           EDIGS_NFA:
 2413    00000000 82                    DC8     0x82
 2414    00000001 23                    DC8     '#'
 2415    00000002 BE                    DC8     '>'+0x80
 2416    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2417    00000004 ........              DC32    LITERAL_NFA
 2418                           EDIGS:
 2419    00000008 ........              DC32    DOCOL
 2420    0000000C ........              DC32    DROP
 2421    00000010 ........              DC32    DROP
 2422    00000014 ........              DC32    HLD_SV
 2423    00000018 ........              DC32    AT
 2424    0000001C ........              DC32    PAD_SV
 2425    00000020 ........              DC32    OVER
 2426    00000024 ........              DC32    SUBB
 2427    00000028 ........              DC32    SEMIS
 2428                           
 2429                           
 2430                           //      HOLD HOLD:      ( c -- )
 2431                           //      Used between <# and #> to insert an ascii character into a pictured
 2432                           //      numeric output string.
 2433                           //      e.g. 0x2E HOLD will place a decimal point.
 2434                           
 2435                            SECTION .text : CONST (2)
 2436                           HOLD_NFA:
 2437    00000000 84                    DC8     0x84
 2438    00000001 484F4C                DC8     'HOL'
 2439    00000004 C4                    DC8     'D'+0x80
 2440    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2441    00000008 ........              DC32    EDIGS_NFA
 2442                           HOLD:
 2443    0000000C ........              DC32    DOCOL
 2444    00000010 ........FFFFF         DC32    LIT,-1
                  FFF          
 2445    00000018 ........              DC32    HLD_SV
 2446    0000001C ........              DC32    PSTORE
 2447    00000020 ........              DC32    HLD_SV
 2448    00000024 ........              DC32    AT
 2449    00000028 ........              DC32    CSTORE
 2450    0000002C ........              DC32    SEMIS
 2451                           
 2452                           
 2453                           //      SIGN SIGN:      ( n d=<LSW MSW> -- d=<LSW MSW> )
 2454                           //      Place an ascii "-" sign just before a converted numeric output
 2455                           //      string in the text output buffer when n is negative. n is discarded
 2456                           //      but double number dnum is maintained. Must be used between <# and #>.
 2457                           
 2458                            SECTION .text : CONST (2)
 2459                           SIGN_NFA:
 2460    00000000 84                    DC8     0x84
 2461    00000001 534947                DC8     'SIG'
 2462    00000004 CE                    DC8     'N'+0x80
 2463    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2464    00000008 ........              DC32    HOLD_NFA
 2465                           SIGN:
 2466    0000000C ........              DC32    DOCOL
 2467    00000010 ........              DC32    ROT
 2468    00000014 ........              DC32    ZLESS
 2469    00000018 ........              DC32    ZBRAN           // If
 2470    0000001C 10000000              DC32     SIGN1-.
 2471                           
 2472    00000020 ........2D000         DC32    LIT, '-'        // 0x2D
                  000          
 2473    00000028 ........              DC32    HOLD            // Endif
 2474                           SIGN1:
 2475    0000002C ........              DC32    SEMIS
 2476                           
 2477                           
 2478                           //      #S DIGS:        ( d1=<LSW MSW> -- d2=<LSW MSW> )
 2479                           //      Generates ascii text in the text output buffer, by the use of #,
 2480                           //      until a zero double number d2 results.
 2481                           //      Used between <# and #>.
 2482                           //      EACH NUMBER = BASE*number+(character-'0')
 2483                           
 2484                            SECTION .text : CONST (2)
 2485                           DIGS_NFA:
 2486    00000000 82                    DC8     0x82
 2487    00000001 23                    DC8     '#'
 2488    00000002 D3                    DC8     'S'+0x80
 2489    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2490    00000004 ........              DC32    SIGN_NFA
 2491                           DIGS:
 2492    00000008 ........              DC32    DOCOL
 2493                           DIGS1:                          // Begin generating ascii chars by DIG
 2494    0000000C ........              DC32    DIG             //( d1=<LSW MSW> -- d2=QUO=<LSW MSW> )
 2495    00000010 ........              DC32    OVER
 2496    00000014 ........              DC32    OVER
 2497    00000018 ........              DC32    OR
 2498    0000001C ........              DC32    ZEQU
 2499    00000020 ........              DC32    ZBRAN           //UNTIL
 2500    00000024 E8FFFFFF              DC32     DIGS1-.
 2501    00000028 ........              DC32    SEMIS
 2502                           
 2503                           
 2504                           //      # DIG:  ( d1=<LSW MSW> -- d2=QUO=<LSW MSW> ) BASE MUST BE SET!
 2505                           //      Generate from a double number d1, the next ascii character which is
 2506                           //      placed in an output string. Result d2 is the quotient after division
 2507                           //      by base, and is maintained for further processing.
 2508                           //      Used between <# and #>.
 2509                           //      See #S.
 2510                           //      EACH NUMBER = BASE*number+(character-'0')
 2511                           
 2512                            SECTION .text : CONST (2)
 2513                           DIG_NFA:
 2514    00000000 81                    DC8     0x81
 2515    00000001 A3                    DC8     '#'+0x80
 2516    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 2517    00000004 ........              DC32    DIGS_NFA
 2518                           DIG:
 2519    00000008 ........              DC32    DOCOL
 2520    0000000C ........              DC32    BASE_SV         // EX 0 1 0
 2521    00000010 ........              DC32    AT              // -- 0 1 0 A
 2522    00000014 ........              DC32    MSMOD           // -- 0 1 0 0
 2523    00000018 ........              DC32    ROT             // -- 0 0 0 1
 2524    0000001C ........09000         DC32    LIT,9
                  000          
 2525    00000024 ........              DC32    OVER
 2526    00000028 ........              DC32    LESSTHAN
 2527    0000002C ........              DC32    ZBRAN           // If
 2528    00000030 10000000              DC32     DIG1-.
 2529                           
 2530    00000034 ........07000         DC32    LIT,7
                  000          
 2531    0000003C ........              DC32    PLUS            // Endif
 2532                           DIG1:
 2533    00000040 ........30000         DC32    LIT, 0x30
                  000          
 2534    00000048 ........              DC32    PLUS
 2535    0000004C ........              DC32    HOLD
 2536    00000050 ........              DC32    SEMIS
 2537                           
 2538                           
 2539                           //      <# BDIGS:       ( -- )
 2540                           //      Setup for pictured numeric output formatting using the words:
 2541                           //              <# # #S SIGN HOLD #>
 2542                           //      The conversion is done on a double number producing text at Pad
 2543                           
 2544                            SECTION .text : CONST (2)
 2545                           BDIGS_NFA:
 2546    00000000 82                    DC8     0x82
 2547    00000001 3C                    DC8     '<'
 2548    00000002 A3                    DC8     '#'+0x80
 2549    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2550    00000004 ........              DC32    DIG_NFA
 2551                           BDIGS:
 2552    00000008 ........              DC32    DOCOL
 2553    0000000C .............         DC32    STRVA, PAD, NHLD
                  ...........  
 2554    00000018 ........              DC32    SEMIS
 2555                           
 2556                           
 2557                           //      DOES> DOES:     ( pfa -- ) MODIFIED:
 2558                           //      A word which defines the run-time action within a high-level
 2559                           //      defining word. DOES> alters the code field and first parameter of
 2560                           //      the new word to execute the sequence of compiled word addresses
 2561                           //      following DOES>. Used in combination with <BUILDS. When the DOES>
 2562                           //      part executes it begins with the address of the first parameter of
 2563                           //      the new word on the stack. This allows interpretation using this
 2564                           //      area or its contents. Typical uses include the Forth assembler,
 2565                           //      multidimensional arrays, and compiler generation.
 2566                           
 2567                            SECTION .text : CONST (2)
 2568                           DOES_NFA:
 2569    00000000 85                    DC8     0x85
 2570    00000001 444F4553              DC8     'DOES'
 2571    00000005 BE                    DC8     '>'+0x80
 2572    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2573    00000008 ........              DC32    BDIGS_NFA
 2574                           DOES:
 2575    0000000C ........              DC32    DOCOL
 2576    00000010 ........              DC32    RFROM   // Get the addr of the first word after DOES>
 2577    00000014 ........              DC32    LATEST  // ( -- addr ) nfa OF the current <creator> word
 2578    00000018 ........              DC32    PFA     // Use the pfa to store a run-time cfa
 2579    0000001C .............         DC32    DUP, CFA
                  ...          
 2580    00000024 .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
 2581    0000002C .............         DC32    SWAP, STORE     // STORE GOTO
                  ...          
 2582    00000034 ........              DC32    STORE   // Store the run-time cfa as 1rst pfa Parameter.
 2583    00000038 ........              DC32    SEMIS
 2584                           
 2585                           
 2586                           //      <BUILDS BUILDS: ( -- )  MODIFIED: See CREATE and DOES>
 2587                           //      Used within a colon-definition
 2588                           //              CCcc  <BUILDS  ...  DOES>     ...
 2589                           //      Each time CCcc is executed, <BUILDS defines a new word with a
 2590                           //      high-level execution proceedure. Executing CCcc in the form
 2591                           //              CCcc nnnn
 2592                           //      uses <BUILDS to create a dictionary entry for nnnn with a call to
 2593                           //      the DOES> part for nnnn. When nnnn is later executed, it has the
 2594                           //      address of its parameter area on the stack and executes the words
 2595                           //      after DOES> in CCcc. <BUILDS and DOES> allow runtime proceedures to
 2596                           //      written in high-level code.
 2597                           
 2598                            SECTION .text : CONST (2)
 2599                           BUILDS_NFA:
 2600    00000000 87                    DC8     0x87
 2601    00000001 3C4255494C44          DC8     '<BUILD'
 2602    00000007 D3                    DC8     'S'+0x80
 2603                            ALIGNROM 2,0xFFFFFFFF
 2604    00000008 ........              DC32    DOES_NFA
 2605                           BUILDS:
 2606    0000000C ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 2607    00000010 ........              DC32    CREATE                  // CREATE's A CON POINTING TO IT'S PFA
 2608    00000014 ........              DC32    SEMIS
 2609                           
 2610                           
 2611                           //      +LOOP PLOOP:    ( n1 -- ) IMMEDIATE
 2612                           //                      ( addr n2 -- ) COMPILE
 2613                           //      At run time, DO begins a sequence with repetitive execution
 2614                           //      controlled by a loop limit n1 and an index with initial value n2. DO
 2615                           //      removes these from the stack. Upon reaching LOOP the index is
 2616                           //      incremented by one.
 2617                           //      Until the new index equals or exceeds the limit, execution loops
 2618                           //      back to just after DO// otherwise the loop parameters are discarded
 2619                           //      and execution continues ahead. Both n1 and n2 are determined at
 2620                           //      run-time and may be the result of other operations.
 2621                           //      Within a loop 'I' will copy the current value of the index to the
 2622                           //      stack. See I, LOOP, +LOOP, LEAVE.
 2623                           //
 2624                           //      When compiling within the colon definition, DO compiles (DO), leaves
 2625                           //      the following address addr and n for later error checking.
 2626                           
 2627                            SECTION .text : CONST (2)
 2628                           PLOOP_NFA:
 2629    00000000 C5                    DC8     0x0C5
 2630    00000001 2B4C4F4F              DC8     '+LOO'
 2631    00000005 D0                    DC8     'P'+0x80
 2632    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2633    00000008 ........              DC32    BUILDS_NFA
 2634                           PLOOP:
 2635    0000000C ........              DC32    DOCOL
 2636    00000010 ........              DC32    THREE
 2637    00000014 ........              DC32    QPAIR
 2638    00000018 ........              DC32    COMP
 2639    0000001C ........              DC32    XPLOOP
 2640    00000020 ........              DC32    BACK
 2641    00000024 ........              DC32    SEMIS
 2642                           
 2643                           
 2644                           //      LOOP LOOP:      ( addr n -- ) IMMEDIATE
 2645                           //      Occurs in a colon-definition in form:
 2646                           //              DO ... LOOP
 2647                           //      At run-time, LOOP selectively controls branching back to the
 2648                           //      corresponding DO based on the loop index and limit. The loop index
 2649                           //      is incremented by one and compared to the limit. The branch back to
 2650                           //      DO occurs until the index equals or exceeds the limit, then
 2651                           //      the parameters are discarded and execution continues ahead.
 2652                           //
 2653                           //      At compile-time. LOOP compiles (LOOP) and uses addr to calculate an
 2654                           //      offset to DO. n is used for error testing.
 2655                           
 2656                            SECTION .text : CONST (2)
 2657                           LOOP_NFA:
 2658    00000000 C4                    DC8     0x0C4
 2659    00000001 4C4F4F                DC8     'LOO'
 2660    00000004 D0                    DC8     'P'+0x80
 2661    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2662    00000008 ........              DC32    PLOOP_NFA
 2663                           LOOP:
 2664    0000000C ........              DC32    DOCOL
 2665    00000010 ........              DC32    THREE
 2666    00000014 ........              DC32    QPAIR
 2667    00000018 ........              DC32    COMP
 2668    0000001C ........              DC32    XLOOP
 2669    00000020 ........              DC32    BACK
 2670    00000024 ........              DC32    SEMIS
 2671                           
 2672                           
 2673                           //      DO DO:  ( n1 n2 -- ) IMMEDIATE
 2674                           //              (addr n -- ) COMPILE
 2675                           //      Occurs in a colon-definition in form:
 2676                           //      DO ... LOOP
 2677                           
 2678                            SECTION .text : CONST (2)
 2679                           DO_NFA:
 2680    00000000 C2                    DC8     0x0C2
 2681    00000001 44                    DC8     'D'
 2682    00000002 CF                    DC8     'O'+0x80
 2683    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2684    00000004 ........              DC32    LOOP_NFA
 2685                           DO:
 2686    00000008 ........              DC32    DOCOL
 2687    0000000C ........              DC32    COMP
 2688    00000010 ........              DC32    XDO
 2689    00000014 ........              DC32    HERE
 2690    00000018 ........              DC32    THREE
 2691    0000001C ........              DC32    SEMIS
 2692                           
 2693                           
 2694                           //      ENDIF ENDIF:    ( addr n -- ) IMMEDIATE
 2695                           //      Occurs in a colon-definition in form:
 2696                           //              IF ... ENDIF
 2697                           //              IF ... ELSE ... ENDIF
 2698                           //      At run-time, ENDIF serves only as the destination of a forward
 2699                           //      branch from IF or ELSE. It marks the conclusion of the conditional
 2700                           //      structure. THEN is another name for ENDIF. Both names are supported
 2701                           //      in fig-FORTH. See also IF and ELSE.
 2702                           //
 2703                           //      At compile-time, ENDIF computes the forward branch offset from addr
 2704                           //      to HERE and stores it at addr. n is used for error tests.
 2705                           
 2706                            SECTION .text : CONST (2)
 2707                           ENDIF_NFA:
 2708    00000000 C5                    DC8     0x0C5
 2709    00000001 454E4449              DC8     'ENDI'
 2710    00000005 C6                    DC8     'F'+0x80
 2711    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2712    00000008 ........              DC32    DO_NFA
 2713                           ENDIF:
 2714    0000000C ........              DC32    DOCOL
 2715    00000010 ........              DC32    QCOMP
 2716    00000014 ........              DC32    TWO     // 2 is the Error checking number for if.
 2717    00000018 ........              DC32    QPAIR
 2718    0000001C ........              DC32    HERE
 2719    00000020 ........              DC32    OVER
 2720    00000024 ........              DC32    SUBB
 2721    00000028 ........              DC32    SWAP
 2722    0000002C ........              DC32    STORE
 2723    00000030 ........              DC32    SEMIS
 2724                           
 2725                           
 2726                           //      THEN THEN:      ( -- ) IMMEDIATE
 2727                           //      An alias for ENDIF.
 2728                           
 2729                            SECTION .text : CONST (2)
 2730                           THEN_NFA:
 2731    00000000 C4                    DC8     0x0C4
 2732    00000001 544845                DC8     'THE'
 2733    00000004 CE                    DC8     'N'+0x80
 2734    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2735    00000008 ........              DC32    ENDIF_NFA
 2736                           THEN:
 2737    0000000C ........              DC32    DOCOL
 2738    00000010 ........              DC32    ENDIF
 2739    00000014 ........              DC32    SEMIS
 2740                           
 2741                           
 2742                           //      ELSE ELSE:      ( addr1 n1 -- ) IMMEDIATE
 2743                           //                      ( addr2 n2 -- ) COMPILING
 2744                           //      Occurs within a colon-definition in the form:
 2745                           //              IF ... ELSE ... ENDIF
 2746                           //      At run-time, ELSE executes after the true part following IF. ELSE
 2747                           //      forces execution to skip over the following false part and resumes
 2748                           //      execution after the ENDIF. It has no stack effect.
 2749                           //
 2750                           //      At compile-time ELSE emplaces BRANCH reserving a branch offset,
 2751                           //      leaves the address addr2 and n2 for error testing. ELSE also
 2752                           //      resolves the pending forward branch from IF by calculating the
 2753                           //      offset from addr1 to HERE and storing at addr1.
 2754                           
 2755                            SECTION .text : CONST (2)
 2756                           ELSE_NFA:
 2757    00000000 C4                    DC8     0x0C4
 2758    00000001 454C53                DC8     'ELS'
 2759    00000004 C5                    DC8     'E'+0x80
 2760    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 2761    00000008 ........              DC32    THEN_NFA
 2762                           ELSE:
 2763    0000000C ........              DC32    DOCOL
 2764    00000010 ........              DC32    TWO
 2765    00000014 ........              DC32    QPAIR
 2766    00000018 ........              DC32    COMP
 2767    0000001C ........              DC32    BRAN
 2768    00000020 ........              DC32    HERE
 2769    00000024 ........              DC32    ZERO
 2770    00000028 ........              DC32    COMMA   // aligned, INCREMENTS DP REFLECTED by HERE
 2771    0000002C ........              DC32    SWAP
 2772    00000030 ........              DC32    TWO
 2773    00000034 ........              DC32    ENDIF
 2774    00000038 ........              DC32    TWO
 2775    0000003C ........              DC32    SEMIS
 2776                           
 2777                           
 2778                           //      IF IF:  ( f -- ) IMMEDIATE
 2779                           //              ( -- addr n ) COMPILE
 2780                           //      Occurs is a colon-definition in form:
 2781                           //              IF (tp) ...  ENDIF      .
 2782                           //              IF (tp) ... ELSE (fp) ... ENDIF
 2783                           //      At run-time, IF selects execution based on a boolean flag. If f is
 2784                           //      true (non-zero), execution continues ahead thru the true part. If f
 2785                           //      is false (zero), execution skips till just after ELSE to execute
 2786                           //      the false part. After either part, execution resumes after ENDIF.
 2787                           //      ELSE and its false part are optional.; if missing, false execution
 2788                           //      skips to just after ENDIF..
 2789                           //
 2790                           //      At compile-time IF compiles 0BRANCH and reserves space for an offset
 2791                           //      at addr. addr and n are used later for resolution of the offset and
 2792                           //      error testing.
 2793                           
 2794                            SECTION .text : CONST (2)
 2795                           IF_NFA:
 2796    00000000 C2                    DC8     0x0C2
 2797    00000001 49                    DC8     'I'
 2798    00000002 C6                    DC8     'F'+0x80
 2799    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 2800    00000004 ........              DC32    ELSE_NFA
 2801                           IF:
 2802    00000008 ........              DC32    DOCOL
 2803    0000000C ........              DC32    COMP
 2804    00000010 ........              DC32    ZBRAN
 2805    00000014 ........              DC32    HERE
 2806    00000018 ........              DC32    ZERO
 2807    0000001C ........              DC32    COMMA
 2808    00000020 ........              DC32    TWO     // 2 is the Error checking number for if.
 2809    00000024 ........              DC32    SEMIS
 2810                           
 2811                           
 2812                           //      UNTIL UNTIL:    ( f -- ) IMMEDIATE
 2813                           //                      ( addr n -- ) COMPILE:
 2814                           //      Occurs within a colon-definition in the form:
 2815                           //              BEGIN ... UNTIL
 2816                           //      At run-time, UNTIL controls the conditional branch back to the
 2817                           //      corresponding BEGIN. If f is false, execution returns to just after.
 2818                           //      BEGIN:  if true, execution continues ahead.
 2819                           //      At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to
 2820                           //      addr. n is used for error tests.
 2821                           
 2822                            SECTION .text : CONST (2)
 2823                           UNTIL_NFA:
 2824    00000000 C5                    DC8     0x0C5
 2825    00000001 554E5449              DC8     'UNTI'
 2826    00000005 CC                    DC8     'L'+0x80
 2827    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2828    00000008 ........              DC32    IF_NFA
 2829                           UNTIL:
 2830    0000000C ........              DC32    DOCOL
 2831    00000010 ........              DC32    ONE
 2832    00000014 ........              DC32    QPAIR
 2833    00000018 ........              DC32    COMP
 2834    0000001C ........              DC32    ZBRAN
 2835    00000020 ........              DC32    BACK
 2836    00000024 ........              DC32    SEMIS
 2837                           
 2838                           
 2839                           //      AGAIN AGAIN:    ( addr n -- ) IMMEDIATE
 2840                           //      Used in a colon-definition in the form:
 2841                           //                      BEGIN ... AGAIN
 2842                           //      At run-time, AGAIN forces execution to return to corresponding BEGIN.
 2843                           //      There is no effect on the stack. Execution cannot leave this loop
 2844                           //      (unless R> DROP is executed one level below).
 2845                           //
 2846                           //      At compile time, AGAIN compiles BRANCH with an offset from HERE to
 2847                           //      addr. n is used for compile-time error checking.
 2848                           
 2849                            SECTION .text : CONST (2)
 2850                           AGAIN_NFA:
 2851    00000000 C5                    DC8     0x0C5
 2852    00000001 41474149              DC8     'AGAI'
 2853    00000005 CE                    DC8     'N'+0x80
 2854    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2855    00000008 ........              DC32    UNTIL_NFA
 2856                           AGAIN:
 2857    0000000C ........              DC32    DOCOL
 2858    00000010 ........              DC32    ONE
 2859    00000014 ........              DC32    QPAIR
 2860    00000018 ........              DC32    COMP
 2861    0000001C ........              DC32    BRAN
 2862    00000020 ........              DC32    BACK
 2863    00000024 ........              DC32    SEMIS
 2864                           
 2865                           
 2866                           //      REPEAT REPEAT:  ( addr n -- ) IMMEDIATE
 2867                           //      Used within a colon-definition in the form:
 2868                           //              BEGIN ... WHILE ... REPEAT
 2869                           //      At run-time, REPEAT forces an unconditional branch back to just
 2870                           //      after the corresponding BEGIN.
 2871                           //
 2872                           //      At compile-time, REPEAT compiles BRANCH and the offset from HERE to
 2873                           //      addr. n is used for error testing.
 2874                           
 2875                            SECTION .text : CONST (2)
 2876                           REPEAT_NFA:
 2877    00000000 C6                    DC8     0x0C6
 2878    00000001 5245504541            DC8     'REPEA'
 2879    00000006 D4                    DC8     'T'+0x80
 2880    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 2881    00000008 ........              DC32    AGAIN_NFA
 2882                           REPEAT:
 2883    0000000C ........              DC32    DOCOL
 2884    00000010 ........              DC32    TOR
 2885    00000014 ........              DC32    TOR
 2886    00000018 ........              DC32    AGAIN
 2887    0000001C ........              DC32    RFROM
 2888    00000020 ........              DC32    RFROM
 2889    00000024 ........              DC32    TWO
 2890    00000028 ........              DC32    SUBB
 2891    0000002C ........              DC32    ENDIF
 2892    00000030 ........              DC32    SEMIS
 2893                           
 2894                           
 2895                           //      WHILE WHILE:    ( f -- ) IMMEDIATE
 2896                           //                      (ad1 nl -- ad1 n1 ad2 n2 ) COMPILE
 2897                           //      Occurs in a colon-definition in the form:
 2898                           //              BEGIN ... WHILE (tp) ... REPEAT
 2899                           //      At run-time, WHILE selects conditional execution based on boolean
 2900                           //      flag f. If f is true (non-zero), WHILE continues execution of the
 2901                           //      true part thru to REPEAT, which then branches back to BEGIN. If f is
 2902                           //      false (zero), execution skips to just after REPEAT, exiting the
 2903                           //      structure.
 2904                           //
 2905                           //      At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the
 2906                           //      reserved offset. The stack values will be resolved by REPEAT.
 2907                           
 2908                            SECTION .text : CONST (2)
 2909                           WHILE_NFA:
 2910    00000000 C5                    DC8     0x0C5
 2911    00000001 5748494C              DC8     'WHIL'
 2912    00000005 C5                    DC8     'E'+0x80
 2913    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2914    00000008 ........              DC32    REPEAT_NFA
 2915                           WHILE:
 2916    0000000C ........              DC32    DOCOL
 2917    00000010 ........              DC32    IF
 2918    00000014 ........              DC32    TWOP
 2919    00000018 ........              DC32    SEMIS
 2920                           
 2921                           
 2922                           //      BEGIN BEGIN:    ( -- addr n ) IMMEDIATE
 2923                           //      Occurs in a colon-definition in form:
 2924                           //      BEGIN ... UNTIL
 2925                           //      BEGIN ... AGAIN
 2926                           //      BEGIN ... WHILE ... REPEAT
 2927                           //      At run-time, BEGIN marks the start of a sequence that may be
 2928                           //      repetitively executed. It serves as a return point from the
 2929                           //      corresponding UNTIL, AGAIN or REPEAT. When executing UNTIL, a return
 2930                           //      to BEGIN will occur if the top of the stack is false//
 2931                           //      for AGAIN and REPEAT a return to BEGIN always occurs.
 2932                           //
 2933                           //      At compile time BEGIN leaves its return address and n for compiler
 2934                           //      error checking.
 2935                           
 2936                            SECTION .text : CONST (2)
 2937                           BEGIN_NFA:
 2938    00000000 C5                    DC8     0x0C5
 2939    00000001 42454749              DC8     'BEGI'
 2940    00000005 CE                    DC8     'N'+0x80
 2941    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 2942    00000008 ........              DC32    WHILE_NFA
 2943                           BEGIN:
 2944    0000000C ........              DC32    DOCOL
 2945    00000010 ........              DC32    QCOMP
 2946    00000014 ........              DC32    HERE
 2947    00000018 ........              DC32    ONE
 2948    0000001C ........              DC32    SEMIS
 2949                           
 2950                           
 2951                           //=============================== WORDCAT ====================================//
 2952                           //NOEXEC HEADERFORWORDCATEGORIES
 2953                           //      WC_COMPILE_NFA = Inside Colon WORDS: CATEGORY
 2954                           
 2955                            SECTION .text : CONST (2)
 2956                           WC_COMPILE_NFA:
 2957    00000000 97                    DC8     0x80+4+19
 2958    00000001 0D0A                  DC8     0x0D, 0x0A
 2959    00000003 496E736964652         DC8     'Inside Colon WORDS:'
                  0436F6C6F6E20
                  574F5244533A 
 2960    00000016 0D8A                  DC8     0x0D, 0x0A+0x80
 2961                            ALIGNROM 2,0xFFFFFFFF
 2962    00000018 ........              DC32    BEGIN_NFA
 2963                           
 2964                           
 2965                           //      IMMEDIATE IMMED:        ( -- )
 2966                           //      Mark the most recently made definition so that when encountered at
 2967                           //      compile time, it will be executed rather than being compiled. i.e.
 2968                           //      the precedence bit in its header is set.
 2969                           //      This method allows definitions to handle unusual compiling
 2970                           //      situations, rather. than build them into the fundamental compiler.
 2971                           //      The system may force compilation of an immediate definition by
 2972                           //      preceeding it with [COMPILE].
 2973                           
 2974                            SECTION .text : CONST (2)
 2975                           IMMED_NFA:
 2976    00000000 89                    DC8     0x89
 2977    00000001 494D4D4544494         DC8     'IMMEDIAT'
                  154          
 2978    00000009 C5                    DC8     'E'+0x80
 2979    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 2980    0000000C ........              DC32    WC_COMPILE_NFA
 2981                           IMMED:
 2982    00000010 ........              DC32    DOCOL
 2983    00000014 ........              DC32    LATEST
 2984    00000018 ........40000         DC32    LIT, 0x40
                  000          
 2985    00000020 ........              DC32    TOGGLE
 2986    00000024 ........              DC32    SEMIS
 2987                           
 2988                           
 2989                           //      CREATE CREATE:  ( -- )
 2990                           //      Create a word in The Dictionary.
 2991                           //      Make searchable and forgetable NFA/LFA, DOCON, ADDR->PFA
 2992                           //      USE <BUILDS with DOES> instead of CREATE.
 2993                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 2994                           //
 2995                           //      Saves HERE in CSDP in case there's an error creating a word.
 2996                           //      CSDP is reset when a word is completed, by ; <BUILDS (?) CON and VAR.
 2997                           //
 2998                           //      A defining word used in the form:
 2999                           //              CREATE CCcc
 3000                           //      by such words as VAR, CON AND <BUILDS to create a dictionary header for
 3001                           //      a new word. The code field contains the address of the words
 3002                           //      parameter field.
 3003                           
 3004                            SECTION .text : CONST (2)
 3005                           CREATE_NFA:
 3006    00000000 86                    DC8     0x86
 3007    00000001 4352454154            DC8     'CREAT'
 3008    00000006 C5                    DC8     'E'+0x80
 3009    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3010    00000008 ........              DC32    IMMED_NFA
 3011                           CREATE:
 3012    0000000C ........              DC32    DOCOL
 3013    00000010 ........              DC32    DICTSPACE       //      ( -- n )
 3014    00000014 ........0F000         DC32    LIT, 15, SUBB   // One less than smallest definition
                  000........  
 3015    00000020 ........              DC32    ZLESS
 3016    00000024 ........              DC32    ZBRAN
 3017    00000028 08000000              DC32    CREATEOK-.
 3018                           
 3019    0000002C ........              DC32    DICTFULL_ABORT
 3020                           
 3021                           CREATEOK:
 3022    00000030 ........              DC32    DFIND                   // Parse nfa
 3023                           //      -FIND DFIND ( --- pfa len tf )(found) ( --- ff ) (not found)
 3024    00000034 ........              DC32    ZBRAN
 3025    00000038 24000000              DC32     CREA1-.
 3026                           
 3027                           #ifdef IO2TP
 3030                           #endif
 3031    0000003C ........              DC32    DROP
 3032    00000040 ........              DC32    NFA
 3033    00000044 ........              DC32    IDDOT
 3034    00000048 .............         DC32    LIT, msg_wordexists
                  ...          
 3035                           // Nothing created yet so ABORT is correct.
 3036                           //        DC32    ERROR
 3037    00000050 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 3038    00000058 ........              DC32    ABORT
 3039                           
 3040                           CREA1:
 3041                           // Save HERE in CSDP so ERROR can reset DP if this definition fails.
 3042                           // CSDP is reset by SEMIC_CREATE when this definition is completed.
 3043                           // SEMIC_CREATE used in ; CON and VAR to reset CSDP.
 3044                           
 3045                           // This new definitions cstring name has been moved to HERE 
 3046    0000005C .............         DC32    HERE, DUP       // This will become the new CURRENT (this NFA).
                  ...          
 3047    00000064 .............         DC32    CSDP_SV, STORE  // HERE to CSDP to restore in case of error.
                  ...          
 3048                           // Dup HERE-NFA to allot NFAx
 3049    0000006C ........              DC32    DUP
 3050                           // Limit NFA allot to maxwordlen. DOES NOT CHANGE actual count!
 3051                           // If count is larger than MAXWORDLEN behaviour of this def is unpredictable!
 3052    00000070 ........              DC32    CAT
 3053    00000074 ........1F000         DC32    LIT, MAXWORDLEN // ELIMINATED WIDTH AND WIDTH_SV 
                  000          
 3054    0000007C ........              DC32    MIN
 3055    00000080 ........              DC32    ALLOT_PRIM      // HERE (DP) at end of NFA with padding.
 3056                           // Dup HERE-NFA to set count byte, and to be consumed later
 3057                           // for setting CURRENT after previous CURRENT compiled into LFA.
 3058    00000084 ........              DC32    DUP
 3059                           // Make regular (not immediate) NFA count byte
 3060    00000088 ........80000         DC32    LIT, 0x80
                  000          
 3061    00000090 ........              DC32    TOGGLE          // Count Byte = 80+count
 3062                           // HERE is new now. Mark end of NFA for PFIND search
 3063    00000094 ........              DC32    HERE            // DP after allot of NFA
 3064    00000098 ........80000         DC32    LIT,0x80        // Set last character in NFA
                  000          
 3065    000000A0 ........              DC32    TOGGLE          // smudge bit
 3066                           // Bump DP to LFA
 3067    000000A4 .............         DC32    ONE, DP_SV      // MOVE HERE (DP)
                  ...          
 3068    000000AC ........              DC32    PSTORE          // TO LFA
 3069                           // Set LFA
 3070    000000B0 ........              DC32    LATEST          // LATEST = CURRENT_SV -> MOST RECENT DEF NFA
 3071    000000B4 ........              DC32    COMMA           // Compile last words NFA into this link field.
 3072                                                           // DUP'd HERE should be on stack
 3073                           // Have to set CURRENT with last dup's HERE-NFA after LATEST is compiled
 3074    000000B8 ........              DC32    CURRENT_SV      // LATEST = CURRENT_SV
 3075    000000BC ........              DC32    STORE           // so storing NEWWORD_NFA into CURRENT.
 3076    000000C0 .............         DC32    COMP, DOCON     // Compile DOCON as CFA
                  ...          
 3077    000000C8 .............         DC32    HERE, FOURP     // Compute and
                  ...          
 3078    000000D0 ........              DC32    COMMA           // COMPILE Addr of PFA
 3079                           //      DC32    SMUDGE          // ELIMINATED
 3080                           //      DC32    SEMIC_CREATE    // USED in CALLERS OF CREATE, NOT HERE!
 3081    000000D4 ........              DC32    SEMIS
 3082                           
 3083                           
 3084                           //      CON CON:        ( n -- )  MODIFIED: and CONSTANT renamed CON
 3085                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3086                           //      A defining word used in the form:
 3087                           //              n CONSTANT CCcc
 3088                           //      to create word CCcc, with its parameter field containing n. When
 3089                           //      CCcc is later executed, it will push the value of n to the stack.
 3090                            SECTION .text : CONST (2)
 3091                           CONSTANT_NFA:
 3092    00000000 88                    DC8     0x88
 3093    00000001 434F4E5354414         DC8     'CONSTAN'
                  E            
 3094    00000008 D4                    DC8     'T'+0x80
 3095    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3096    0000000C ........              DC32    CREATE_NFA
 3097                           CONSTANT:
 3098    00000010 .............         DC32    DOCOL, CON, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3099                           
 3100                            SECTION .text : CONST (2)
 3101                           CON_NFA:
 3102    00000000 83                    DC8     0x83
 3103    00000001 434F                  DC8     'CO'
 3104    00000003 CE                    DC8     'N'+0x80
 3105                            ALIGNROM 2,0xFFFFFFFF
 3106                           //      DC32    CREATE_NFA
 3107    00000004 ........              DC32    CONSTANT_NFA
 3108                           CON:
 3109    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3110    0000000C ........              DC32    CREATE  // Make Header NFA/LFA, DOCON, ADDR->PFA
 3111    00000010 ........FCFFF         DC32    LIT, -4, DP_SV, PSTORE  // back up to ADDR->PFA
                  FFF..........
                  ......       
 3112    00000020 ........              DC32    COMMA                   // Replace with Con value
 3113    00000024 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3114                           //        DC32    DOTDICTSPACE
 3115    00000028 ........              DC32    SEMIS
 3116                           
 3117                           
 3118                           //      VAR VAR:        ( -- ) RENAMED: VARIABLE to VAR
 3119                           //      IF RAMVARSPACE FULL PRINT Error MESSAGE AND Abort.
 3120                           //      A defining word used in the form:
 3121                           //              VARIABLE CCcc
 3122                           //      When VARIABLE is executed, it creates the definition CCcc with its
 3123                           //      with its cell space uninitialized. When CCcc is executed,
 3124                           //      its cell space address is put on the stack. Use with @ or !
 3125                           //      NOTE: VAR's cell space is allocated in ram. See UP and VARALLOT.
 3126                           
 3127                            SECTION .text : CONST (2)
 3128                           VARIABLE_NFA:
 3129    00000000 88                    DC8     0x88
 3130    00000001 5641524941424         DC8     'VARIABL'
                  C            
 3131    00000008 C5                    DC8     'E'+0x80
 3132    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3133    0000000C ........              DC32    CON_NFA
 3134                           VARIABLE:
 3135    00000010 .............         DC32    DOCOL, VAR_, SEMIS   // CREATE DOES DICTSPACE CHECK
                  ...........  
 3136                           
 3137                            SECTION .text : CONST (2)
 3138                           VAR_NFA:
 3139    00000000 83                    DC8     0x83
 3140    00000001 5641                  DC8     'VA'
 3141    00000003 D2                    DC8     'R'+0x80
 3142                            ALIGNROM 2,0xFFFFFFFF
 3143                           //      DC32    CON_NFA
 3144    00000004 ........              DC32    VARIABLE_NFA
 3145                           VAR_:
 3146    00000008 ........              DC32    DOCOL   // CREATE DOES DICTSPACE CHECK
 3147    0000000C ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3148    00000010 ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3149    00000020 .............         DC32    COMP, DOVAR     // CFA of VAR's
                  ...          
 3150                           //        DC32    COMP, DOCON     // CFA of VAR's
 3151                           // aligned, INCREMENTS DP REFLECTED by HERE
 3152                           // compile the value ( v -- )
 3153    00000028 ........              DC32    ONE
 3154    0000002C ........              DC32    VARALLOT        // Do .VS check and return VAR addr.
 3155    00000030 ........              DC32    COMMA           // Compile address of the ram allotment.
 3156    00000034 ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3157                           //        DC32    DOTDICTSPACE
 3158                           //        DC32    DOTVARSPACE
 3159    00000038 ........              DC32    SEMIS
 3160                           
 3161                           
 3162                           //      ; SEMI: ( -- ) IMMEDIATE
 3163                           //      Terminate a colon-definition and stop further compilation.
 3164                           //      Compiles the run-time ;S.
 3165                           
 3166                            SECTION .text : CONST (2)
 3167                           SEMI_NFA:
 3168    00000000 C1                    DC8     0x0C1
 3169    00000001 BB                    DC8     ';'+0x80
 3170    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3171    00000004 ........              DC32    VAR_NFA
 3172                           SEMI:
 3173    00000008 ........              DC32    DOCOL
 3174    0000000C ........              DC32    QCSP
 3175    00000010 ........              DC32    COMP
 3176    00000014 ........              DC32    SEMIS
 3177    00000018 ........              DC32    LBRAC
 3178    0000001C ........              DC32    SEMIC_CREATE            // RESET AUTO FORGET
 3179                           //        DC32    DOTDICTSPACE
 3180    00000020 ........              DC32    SEMIS
 3181                           
 3182                           
 3183                           //      : COLON:        ( -- ) IMMEDIATE
 3184                           //      IF DICTIONAIRY FULL PRINT Error MESSAGE AND Abort.
 3185                           //      Used in the form called a colon-definition:
 3186                           //              : CCcc     ...     //
 3187                           //      Creates a dictionary entry defining CCcc as equivalent to the
 3188                           //      following sequence of Forth word definitions '...' until the next
 3189                           //      ';' or ';CODE'.
 3190                           //      The compiling process is done by the text interpreter as long as
 3191                           //      STATE is non-zero. Other details are that the CONTEXT vocabulary is
 3192                           //      set to the CURRENT vocabulary and that words with the precedence bit
 3193                           //      set (P) are executed rather than being compiled.
 3194                           
 3195                            SECTION .text : CONST (2)
 3196                           COLON_NFA:
 3197    00000000 C1                    DC8     0x0C1
 3198    00000001 BA                    DC8     ':'+0x80
 3199    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3200    00000004 ........              DC32    SEMI_NFA
 3201                           COLON:
 3202    00000008 ........              DC32    DOCOL
 3203                           //      DICTSPACE TEST DONE in CREATE
 3204    0000000C ........              DC32    QEXEC
 3205    00000010 ........              DC32    SCSP    // Save the stack position in CSP. Compiler security.
 3206    00000014 ........              DC32    CREATE  // Make Header NFA and LFA, update CURRENT
 3207    00000018 ........              DC32    RBRAC   // Resume compiliting by setting STATE_SV to 0xC0
 3208    0000001C ........F8FFF         DC32    LIT, -8, DP_SV, PSTORE
                  FFF..........
                  ......       
 3209    0000002C .............         DC32    COMP, DOCOL     // aligned, INCREMENTS DP REFLECTED by HERE
                  ...          
 3210    00000034 ........              DC32    SEMIS
 3211                           
 3212                           
 3213                           //=============================== WORDCAT ====================================//
 3214                           //NOEXEC HEADERFORWORDCATEGORIES
 3215                           //      WC_CREATE_NFA = CREATE WORDS With: CATEGORY
 3216                           
 3217                            SECTION .text : CONST (2)
 3218                           WC_CREATE_NFA:
 3219    00000000 96                    DC8     0x80+22
 3220    00000001 0D0A                  DC8     0x0D, 0x0A
 3221    00000003 4352454154452         DC8     'CREATE WORDS With:'
                  0574F52445320
                  576974683A   
 3222    00000015 0D8A                  DC8     0x0D, 0x0A+0x80
 3223    00000017 FF             ALIGNROM 2,0xFFFFFFFF
 3224    00000018 ........              DC32    COLON_NFA
 3225                           
 3226                           //      DABS DABS: ( sd=(LSW MSW) -- ud=(LSW MSW) )
 3227                           //      Leave the absolute value ud of a signed double number.
 3228                           
 3229                            SECTION .text : CONST (2)
 3230                           DABS_NFA:
 3231    00000000 84                    DC8     0x84
 3232    00000001 444142                DC8     'DAB'
 3233    00000004 D3                    DC8     'S'+0x80
 3234    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3235    00000008 ........              DC32    WC_CREATE_NFA
 3236                           DABSF:
 3237                           DABS:
 3238    0000000C ........              DC32    DOCOL
 3239    00000010 ........              DC32    DUP
 3240    00000014 ........              DC32    DPM
 3241    00000018 ........              DC32    SEMIS
 3242                           
 3243                           
 3244                           //      DNEGATE DNEGATE: ( d1 -- d<2>=(LSW MSW) ) RENAMED: DMINUS to DNEGATE
 3245                           //      Convert d1 to its double number two's complement d2.
 3246                           
 3247                            SECTION .text : CONST (2)
 3248                           DNEGATE_NFA:
 3249    00000000 87                    DC8     0x87
 3250    00000001 444E45474154          DC8     'DNEGAT'
 3251    00000007 C5                    DC8     'E'+0x80
 3252                            ALIGNROM 2,0xFFFFFFFF
 3253    00000008 ........              DC32    DABS_NFA
 3254                           DNEGATE:
 3255    0000000C ........              DC32    .+5
 3256                            SECTION .text : CODE (2)
 3257                                   POP2t                   // MSW   //POP  BX
 3257.1                         #ifndef TOSCT
 3257.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3257.3                         #endif
 3257.4  00000002 3F1D                  ADDS    p, p, #4
 3257.5                                 ENDM
 3258                                   POP2w                   // LSW   //POP  CX
 3258.1  00000004 3A68                  LDR     w, [p]
 3258.2  00000006 3F1D                  ADDS    p, p, #4
 3258.3                                 ENDM
 3259    00000008 C043                  MVNS    t, t            // negate MSW
 3260    0000000A D243                  MVNS    w, w            // negate LSW
 3261    0000000C 521C                  ADDS    w, w, #1        // add 1 to LSW
 3262                                   DPUSH                   //  --  LSW MSW )
 3262                                   PUSHw   // push w to p, pre decrement p
 3262.1  0000000E 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 3262.2  00000010 3A60                  STR     w, [p]
 3262.3                                 ENDM
 3262                                   TPUSH
 3262                                   PUSHt   // push t to p, pre decrement p
 3262.1  00000012 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3262.2  00000014 3860                  STR     t, [p]
 3262.3                                 ENDM
 3262                                   NEXT
 3262.1  00000016 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3262                                   NEXT1
 3262.1  00000018 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3262.2  0000001A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3262.3                                 ENDM
 3262.4                                 ENDM
 3262.5                                 ENDM
 3262.6                                 ENDM
 3263                           
 3264                           
 3265                           //      DPL_SV: ( -- addr of NDPL ) Contains # of digits after . in double number
 3266                           //      A system variable containing the number of digits to the right of the
 3267                           //      decimal on double integer input. It may also be used to hold output
 3268                           //      column location of a decimal point, in system generated formating. The
 3269                           //      default value on single number input is -1.
 3270                            SECTION .text : CONST (2)
 3271                           DPL_NFA:
 3272    00000000 83                    DC8     0x83
 3273    00000001 4450                  DC8     'DP'
 3274    00000003 CC                    DC8     'L'+0x80
 3275                            ALIGNROM 2,0xFFFFFFFF
 3276    00000004 ........              DC32    DNEGATE_NFA
 3277                           DPL_SV:
 3278    00000008 .............         DC32    DOCON, NDPL
                  ...          
 3279                           
 3280                           
 3281                           //      D.R DDOTR:      ( sd=<LSW MSW> n -- ) SIGNED:
 3282                           //      Print a signed double number sd right aligned
 3283                           //      in a field n characters wide.
 3284                           
 3285                            SECTION .text : CONST (2)
 3286                           DDOTR_NFA:
 3287    00000000 83                    DC8     0x83
 3288    00000001 442E                  DC8     'D.'
 3289    00000003 D2                    DC8     'R'+0x80
 3290                            ALIGNROM 2,0xFFFFFFFF
 3291    00000004 ........              DC32    DPL_NFA
 3292                           DDOTR:
 3293    00000008 ........              DC32    DOCOL
 3294    0000000C ........              DC32    TOR     // N CHAR FIELD LEN to r
 3295    00000010 ........              DC32    SWAP    // ( LSW MSW -- MSW LSW )
 3296    00000014 ........              DC32    OVER    // ( MSW LSW -- MSW LSW MSW )
 3297    00000018 ........              DC32    DABS    // ( MSW LSW MSW -- MSW uLSW uMSW )
 3298    0000001C ........              DC32    BDIGS   // <# SET HLD to Pad
 3299    00000020 ........              DC32    DIGS    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3300    00000024 ........              DC32    SIGN    // ( d=<LSW MSW> -- d=<LSW MSW> )
 3301    00000028 ........              DC32    EDIGS   //      #>  ( d=<LSW MSW>  ---  addr  count )
 3302    0000002C ........              DC32    RFROM   // GET THE N CHAR FIELD LEN
 3303    00000030 ........              DC32    OVER    // ( addr count n -- addr count n count )
 3304    00000034 ........              DC32    SUBB    // ( n addr count addr -- n addr count-n )
 3305    00000038 ........              DC32    SPACES  // SPACES  ( n -- )
 3306    0000003C ........              DC32    TYPE    // ( n addr -- )
 3307    00000040 ........              DC32    SEMIS
 3308                           
 3309                           
 3310                           //      D. DDOT:        ( S32-2'S COMPLEMET = (d=<LSW MSW> -- )
 3311                           //      Print a signed double number from a 32 bit two's complement value.
 3312                           //      The high-order 32 bits are most accessable on the stack. Conversion
 3313                           //      is performed according to the current base. A blank follows.
 3314                           
 3315                            SECTION .text : CONST (2)
 3316                           DDOT_NFA:
 3317    00000000 82                    DC8     0x82
 3318    00000001 44                    DC8     'D'
 3319    00000002 AE                    DC8     '.'+0x80
 3320    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3321    00000004 ........              DC32    DDOTR_NFA
 3322                           DDOT:
 3323    00000008 ........              DC32    DOCOL
 3324    0000000C ........              DC32    ZERO
 3325    00000010 ........              DC32    DDOTR
 3326    00000014 ........              DC32    SPACE
 3327    00000018 ........              DC32    SEMIS
 3328                           
 3329                           
 3330                           //      D+ DPLUS:       ( LSW1 MSW1 LSW2 MSW2 --- LSW MSW )  SIGNED:
 3331                           //      Leave the signed double number sum of two signed double numbers.
 3332                           
 3333                            SECTION .text : CONST (2)
 3334                           DPLUS_NFA:
 3335    00000000 82                    DC8     0x82
 3336    00000001 44                    DC8     'D'
 3337    00000002 AB                    DC8     '+'+0x80
 3338    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3339    00000004 ........              DC32    DDOT_NFA
 3340                           DPLUS:
 3341    00000008 ........              DC32    .+5
 3342                            SECTION .text : CODE (2)
 3343                                   POP2t   //    ldr     t, [p],#4       // MS
 3343.1                         #ifndef TOSCT
 3343.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3343.3                         #endif
 3343.4  00000002 3F1D                  ADDS    p, p, #4
 3343.5                                 ENDM
 3344                                   POP2n   //    ldr     n, [p],#4       // LS
 3344.1  00000004 3968                  LDR     n, [p]
 3344.2  00000006 3F1D                  ADDS    p, p, #4
 3344.3                                 ENDM
 3345                                   POP2x   //    ldr     x, [p],#4       // MS
 3345.1  00000008 3B68                  LDR     x, [p]
 3345.2  0000000A 3F1D                  ADDS    p, p, #4
 3345.3                                 ENDM
 3346                                   POP2w   //    ldr     w, [p],#4       // LS
 3346.1  0000000C 3A68                  LDR     w, [p]
 3346.2  0000000E 3F1D                  ADDS    p, p, #4
 3346.3                                 ENDM
 3347    00000010 5218                  ADDS    w, w, n         // LS sum, set status flags
 3348    00000012 5841                  ADCS    t, t, x         // MS sum + carry
 3349                                   DPUSH                   //  --  LSW MSW )
 3349                                   PUSHw   // push w to p, pre decrement p
 3349.1  00000014 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 3349.2  00000016 3A60                  STR     w, [p]
 3349.3                                 ENDM
 3349                                   TPUSH
 3349                                   PUSHt   // push t to p, pre decrement p
 3349.1  00000018 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3349.2  0000001A 3860                  STR     t, [p]
 3349.3                                 ENDM
 3349                                   NEXT
 3349.1  0000001C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3349                                   NEXT1
 3349.1  0000001E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3349.2  00000020 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3349.3                                 ENDM
 3349.4                                 ENDM
 3349.5                                 ENDM
 3349.6                                 ENDM
 3350                           
 3351                           
 3352                           //      S->D STOD:      ( n -- d=<LSW MSW> ) SIGNED:
 3353                           //      Sign extend a single number to form a double number.
 3354                           //      : S->D DUP 0< NEGATE // hi level equivalent
 3355                           
 3356                            SECTION .text : CONST (2)
 3357                           STOD_NFA:
 3358    00000000 84                    DC8     0x84
 3359    00000001 532D3E                DC8     'S->'
 3360    00000004 C4                    DC8     'D'+0x80
 3361    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3362    00000008 ........              DC32    DPLUS_NFA
 3363                           STOD:
 3364    0000000C ........              DC32    .+5
 3365                            SECTION .text : CODE (2)
 3366                                   POP2w                   // POP LSW
 3366.1  00000000 3A68                  LDR     w, [p]
 3366.2  00000002 3F1D                  ADDS    p, p, #4
 3366.3                                 ENDM
 3367    00000004 4040                  EORS    t, t            // Zero MSW
 3368    00000006 1243                  ORRS    w, w, w         // OR LSW
 3369    00000008 00D5                  BPL     STOD1           // LSW is POS
 3370                           
 3371    0000000A 401E                  SUBS     t, t, #1       // LSW is NEG
 3372                           STOD1:
 3373                                   DPUSH                   //  --  LSW MSW )
 3373                                   PUSHw   // push w to p, pre decrement p
 3373.1  0000000C 3F1F                  SUBS    p, p, #4        //  push w to p, pre decrement p
 3373.2  0000000E 3A60                  STR     w, [p]
 3373.3                                 ENDM
 3373                                   TPUSH
 3373                                   PUSHt   // push t to p, pre decrement p
 3373.1  00000010 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3373.2  00000012 3860                  STR     t, [p]
 3373.3                                 ENDM
 3373                                   NEXT
 3373.1  00000014 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3373                                   NEXT1
 3373.1  00000016 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3373.2  00000018 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3373.3                                 ENDM
 3373.4                                 ENDM
 3373.5                                 ENDM
 3373.6                                 ENDM
 3374                           
 3375                           
 3376                           //      2* TWOSTAR:     ( n -- n*2 ) LSL 1
 3377                           
 3378                            SECTION .text : CONST (2)
 3379                           TWOSTAR_NFA:
 3380    00000000 82                    DC8     0x82
 3381    00000001 32                    DC8     '2'
 3382    00000002 AA                    DC8     '*'+0x80
 3383    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3384    00000004 ........              DC32    STOD_NFA
 3385                           TWOSTAR:
 3386    00000008 ........              DC32    .+5
 3387                            SECTION .text : CODE (2)
 3388                                   POP2t
 3388.1                         #ifndef TOSCT
 3388.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3388.3                         #endif
 3388.4  00000002 3F1D                  ADDS    p, p, #4
 3388.5                                 ENDM
 3389    00000004 4000                  LSLS    t, t, #1        //
 3390                                   TPUSH
 3390                                   PUSHt   // push t to p, pre decrement p
 3390.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3390.2  00000008 3860                  STR     t, [p]
 3390.3                                 ENDM
 3390                                   NEXT
 3390.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3390                                   NEXT1
 3390.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3390.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3390.3                                 ENDM
 3390.4                                 ENDM
 3390.5                                 ENDM
 3391                           
 3392                           
 3393                           //      2/ TWOSLASH:    ( n -- n/1 ) ASR 1 (FLOORED)
 3394                           
 3395                            SECTION .text : CONST (2)
 3396                           TWOSLASH_NFA:
 3397    00000000 82                    DC8     0x82
 3398    00000001 32                    DC8     '2'
 3399    00000002 AF                    DC8     '/'+0x80
 3400    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3401    00000004 ........              DC32    TWOSTAR_NFA
 3402                           TWOSLASH:
 3403    00000008 ........              DC32    .+5
 3404                            SECTION .text : CODE (2)
 3405                                   POP2t
 3405.1                         #ifndef TOSCT
 3405.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3405.3                         #endif
 3405.4  00000002 3F1D                  ADDS    p, p, #4
 3405.5                                 ENDM
 3406    00000004 4010                  ASRS    t, t, #1        //
 3407                                   TPUSH
 3407                                   PUSHt   // push t to p, pre decrement p
 3407.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3407.2  00000008 3860                  STR     t, [p]
 3407.3                                 ENDM
 3407                                   NEXT
 3407.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3407                                   NEXT1
 3407.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3407.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3407.3                                 ENDM
 3407.4                                 ENDM
 3407.5                                 ENDM
 3408                                   
 3409                           
 3410                           //      1- ONEM:        ( n -- n-1 )
 3411                           
 3412                            SECTION .text : CONST (2)
 3413                           ONEM_NFA:
 3414    00000000 82                    DC8     0x82
 3415    00000001 31                    DC8     '1'
 3416    00000002 AD                    DC8     '-'+0x80
 3417    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3418    00000004 ........              DC32    TWOSLASH_NFA
 3419                           ONEM:
 3420    00000008 ........              DC32    .+5
 3421                            SECTION .text : CODE (2)
 3422                                   POP2t
 3422.1                         #ifndef TOSCT
 3422.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3422.3                         #endif
 3422.4  00000002 3F1D                  ADDS    p, p, #4
 3422.5                                 ENDM
 3423    00000004 401E                  SUBS    t, t, #1        //
 3424                                   TPUSH
 3424                                   PUSHt   // push t to p, pre decrement p
 3424.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3424.2  00000008 3860                  STR     t, [p]
 3424.3                                 ENDM
 3424                                   NEXT
 3424.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3424                                   NEXT1
 3424.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3424.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3424.3                                 ENDM
 3424.4                                 ENDM
 3424.5                                 ENDM
 3425                           
 3426                           
 3427                           //      1+ ONEP:        ( n -- n+1 )
 3428                           
 3429                            SECTION .text : CONST (2)
 3430                           ONEP_NFA:
 3431    00000000 82                    DC8     0x82
 3432    00000001 31                    DC8     '1'
 3433    00000002 AB                    DC8     '+'+0x80
 3434    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3435    00000004 ........              DC32    ONEM_NFA
 3436                           ONEP:
 3437    00000008 ........              DC32    .+5
 3438                            SECTION .text : CODE (2)
 3439                                   POP2t
 3439.1                         #ifndef TOSCT
 3439.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3439.3                         #endif
 3439.4  00000002 3F1D                  ADDS    p, p, #4
 3439.5                                 ENDM
 3440    00000004 401C                  ADDS    t, t, #1        //
 3441                                   TPUSH
 3441                                   PUSHt   // push t to p, pre decrement p
 3441.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3441.2  00000008 3860                  STR     t, [p]
 3441.3                                 ENDM
 3441                                   NEXT
 3441.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3441                                   NEXT1
 3441.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3441.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3441.3                                 ENDM
 3441.4                                 ENDM
 3441.5                                 ENDM
 3442                           
 3443                           
 3444                           //      2+ TWOP:        ( n -- n+2 )
 3445                           
 3446                            SECTION .text : CONST (2)
 3447                           TWOP_NFA:
 3448    00000000 82                    DC8     0x82
 3449    00000001 32                    DC8     '2'
 3450    00000002 AB                    DC8     '+'+0x80
 3451    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3452    00000004 ........              DC32    ONEP_NFA
 3453                           TWOP:
 3454    00000008 ........              DC32    .+5
 3455                            SECTION .text : CODE (2)
 3456                                   POP2t
 3456.1                         #ifndef TOSCT
 3456.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3456.3                         #endif
 3456.4  00000002 3F1D                  ADDS    p, p, #4
 3456.5                                 ENDM
 3457    00000004 801C                  ADDS    t, t, #2
 3458                                   TPUSH
 3458                                   PUSHt   // push t to p, pre decrement p
 3458.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3458.2  00000008 3860                  STR     t, [p]
 3458.3                                 ENDM
 3458                                   NEXT
 3458.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3458                                   NEXT1
 3458.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3458.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3458.3                                 ENDM
 3458.4                                 ENDM
 3458.5                                 ENDM
 3459                           
 3460                           
 3461                           //      4+ FOURP:       ( n -- n+4 )
 3462                           
 3463                            SECTION .text : CONST (2)
 3464                           FOURP_NFA:
 3465    00000000 82                    DC8     0x82
 3466    00000001 34                    DC8     '4'
 3467    00000002 AB                    DC8     '+'+0x80
 3468    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3469    00000004 ........              DC32    TWOP_NFA
 3470                           FOURP:
 3471    00000008 ........              DC32    .+5
 3472                            SECTION .text : CODE (2)
 3473                                   POP2t
 3473.1                         #ifndef TOSCT
 3473.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3473.3                         #endif
 3473.4  00000002 3F1D                  ADDS    p, p, #4
 3473.5                                 ENDM
 3474    00000004 001D                  ADDS    t, t, #4
 3475                                   TPUSH
 3475                                   PUSHt   // push t to p, pre decrement p
 3475.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3475.2  00000008 3860                  STR     t, [p]
 3475.3                                 ENDM
 3475                                   NEXT
 3475.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3475                                   NEXT1
 3475.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3475.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3475.3                                 ENDM
 3475.4                                 ENDM
 3475.5                                 ENDM
 3476                           
 3477                           
 3478                           //      4- FOURM:       ( n -- n-4 )
 3479                           
 3480                            SECTION .text : CONST (2)
 3481                           FOURM_NFA:
 3482    00000000 82                    DC8     0x82
 3483    00000001 34                    DC8     '4'
 3484    00000002 AD                    DC8     '-'+0x80
 3485    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3486    00000004 ........              DC32    FOURP_NFA
 3487                           FOURM:
 3488    00000008 ........              DC32    .+5
 3489                            SECTION .text : CODE (2)
 3490                                   POP2t
 3490.1                         #ifndef TOSCT
 3490.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3490.3                         #endif
 3490.4  00000002 3F1D                  ADDS    p, p, #4
 3490.5                                 ENDM
 3491    00000004 001F                  SUBS    t, t, #4
 3492                                   TPUSH
 3492                                   PUSHt   // push t to p, pre decrement p
 3492.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3492.2  00000008 3860                  STR     t, [p]
 3492.3                                 ENDM
 3492                                   NEXT
 3492.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3492                                   NEXT1
 3492.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3492.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3492.3                                 ENDM
 3492.4                                 ENDM
 3492.5                                 ENDM
 3493                           
 3494                           
 3495                           //      0 ZERO: ( -- 0 )
 3496                           
 3497                            SECTION .text : CONST (2)
 3498                           ZERO_NFA:
 3499    00000000 81                    DC8     0x81
 3500    00000001 B0                    DC8     '0'+0x80
 3501    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3502    00000004 ........              DC32    FOURM_NFA
 3503                           ZERO:
 3504    00000008 ........00000         DC32    DOCON, 0x0
                  000          
 3505                           
 3506                           
 3507                           //      1 ONE: ( -- 1 )
 3508                           
 3509                            SECTION .text : CONST (2)
 3510                           ONE_NFA:
 3511    00000000 81                    DC8     0x81
 3512    00000001 B1                    DC8     '1'+0x80
 3513    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3514    00000004 ........              DC32    ZERO_NFA
 3515                           ONE:
 3516    00000008 ........01000         DC32    DOCON, 0x1
                  000          
 3517                           
 3518                           
 3519                           //      2 TWO: ( -- 2 )
 3520                           
 3521                            SECTION .text : CONST (2)
 3522                           TWO_NFA:
 3523    00000000 81                    DC8     0x81
 3524    00000001 B2                    DC8     '2'+0x80
 3525    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3526    00000004 ........              DC32    ONE_NFA
 3527                           TWO:
 3528    00000008 ........02000         DC32    DOCON, 0x2
                  000          
 3529                           
 3530                           
 3531                           //      3 THREE: ( -- 3 )
 3532                           
 3533                            SECTION .text : CONST (2)
 3534                           THREE_NFA:
 3535    00000000 81                    DC8     0x81
 3536    00000001 B3                    DC8     '3'+0x80
 3537    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3538    00000004 ........              DC32    TWO_NFA
 3539                           THREE:
 3540    00000008 ........03000         DC32    DOCON, 0x3
                  000          
 3541                           
 3542                           
 3543                           //      4 FOUR: ( -- 4 )
 3544                           
 3545                            SECTION .text : CONST (2)
 3546                           FOUR_NFA:
 3547    00000000 81                    DC8     0x81
 3548    00000001 B4                    DC8     '4'+0x80
 3549    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3550    00000004 ........              DC32    THREE_NFA
 3551                           FOUR:
 3552    00000008 ........04000         DC32    DOCON, 0x4
                  000          
 3553                           
 3554                           
 3555                           //      M* MSTAR:       ( n1 n2 -- d=<S32LSW S32MSW> )  SIGNED:
 3556                           //      A mixed magnitude math operation which leaves the double number
 3557                           //      signed product of two signed number.
 3558                           
 3559                            SECTION .text : CONST (2)
 3560                           MSTAR_NFA:
 3561    00000000 82                    DC8     0x82
 3562    00000001 4D                    DC8     'M'
 3563    00000002 AA                    DC8     '*'+0x80
 3564    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3565    00000004 ........              DC32    FOUR_NFA
 3566                           MSTAR:
 3567    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3568    00000010 ........              DC32    XORR
 3569    00000014 ........              DC32    TOR
 3570    00000018 ........              DC32    ABS
 3571    0000001C ........              DC32    SWAP
 3572    00000020 ........              DC32    ABS
 3573    00000024 ........              DC32    USTAR
 3574    00000028 ........              DC32    RFROM
 3575    0000002C ........              DC32    DPM
 3576    00000030 ........              DC32    SEMIS
 3577                           
 3578                           
 3579                           //      M/ MSLASH:      ( sd  n1  ---  d=<s32REM  S32QUO> )
 3580                           //      A mixed magnitude math operator which leaves the signed remainder
 3581                           //      and signed quotient from sd, a double number dividend and divisor n1.
 3582                           //      The remainder takes its sign from the dividend.
 3583                           
 3584                            SECTION .text : CONST (2)
 3585                           MSLASH_NFA:
 3586    00000000 82                    DC8     0x82
 3587    00000001 4D                    DC8     'M'
 3588    00000002 AF                    DC8     '/'+0x80
 3589    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3590    00000004 ........              DC32    MSTAR_NFA
 3591                           MSLASH:
 3592    00000008 ........              DC32    DOCOL
 3593    0000000C ........              DC32    OVER
 3594    00000010 ........              DC32    TOR
 3595    00000014 ........              DC32    TOR
 3596    00000018 ........              DC32    DABS    // ( LSW MSW -- uLSW uMSW )
 3597    0000001C ........              DC32    R
 3598    00000020 ........              DC32    ABS
 3599    00000024 ........              DC32    USLASH
 3600    00000028 ........              DC32    RFROM
 3601    0000002C ........              DC32    R
 3602    00000030 ........              DC32    XORR
 3603    00000034 ........              DC32    PM
 3604    00000038 ........              DC32    SWAP
 3605    0000003C ........              DC32    RFROM
 3606    00000040 ........              DC32    PM
 3607    00000044 ........              DC32    SWAP
 3608    00000048 ........              DC32    SEMIS
 3609                           
 3610                           
 3611                           //      * STAR: ( n1 n2 -- prod=n3 )
 3612                           //      Leave the signed product n3 of two (32bit) signed numbers n1 and n2.
 3613                           
 3614                            SECTION .text : CONST (2)
 3615                           STAR_NFA:
 3616    00000000 81                    DC8     0x81
 3617    00000001 AA                    DC8     '*'+0x80
 3618    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3619    00000004 ........              DC32    MSLASH_NFA
 3620                           STAR:
 3621    00000008 ........              DC32    DOCOL
 3622    0000000C ........              DC32    MSTAR
 3623    00000010 ........              DC32    DROP
 3624    00000014 ........              DC32    SEMIS
 3625                           
 3626                           
 3627                           //      /MOD SLMOD:     ( n1 n2 -- rem quot )   SIGNED:
 3628                           //      Leave the remainder and signed quotient of n1/n2. The remainder has
 3629                           //      the sign of the dividend.
 3630                           
 3631                            SECTION .text : CONST (2)
 3632                           SLMOD_NFA:
 3633    00000000 84                    DC8     0x84
 3634    00000001 2F4D4F                DC8     '/MO'
 3635    00000004 C4                    DC8     'D'+0x80
 3636    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 3637    00000008 ........              DC32    STAR_NFA
 3638                           SLMOD:
 3639    0000000C ........              DC32    DOCOL
 3640    00000010 ........              DC32    TOR
 3641    00000014 ........              DC32    STOD
 3642    00000018 ........              DC32    RFROM
 3643    0000001C ........              DC32    MSLASH
 3644    00000020 ........              DC32    SEMIS
 3645                           
 3646                           
 3647                           //      / SLASH:        ( sn1 sn2 -- sn ) SIGNED:
 3648                           //      Leave the signed quotient sn of sn1/sn2.
 3649                           
 3650                            SECTION .text : CONST (2)
 3651                           SLASH_NFA:
 3652    00000000 81                    DC8     0x81
 3653    00000001 AF                    DC8     '/'+0x80
 3654    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3655    00000004 ........              DC32    SLMOD_NFA
 3656                           SLASH:
 3657    00000008 ........              DC32    DOCOL
 3658    0000000C ........              DC32    SLMOD
 3659    00000010 ........              DC32    SWAP
 3660    00000014 ........              DC32    DROP
 3661    00000018 ........              DC32    SEMIS
 3662                           
 3663                           
 3664                           //      MOD MOD:        ( sn1 n2 -- modulo )
 3665                           //      Leave the remainder of sn1/n2, with the same sign as sn1.
 3666                           
 3667                            SECTION .text : CONST (2)
 3668                           MODD_NFA:
 3669    00000000 83                    DC8     0x83
 3670    00000001 4D4F                  DC8     'MO'
 3671    00000003 C4                    DC8     'D'+0x80
 3672                            ALIGNROM 2,0xFFFFFFFF
 3673    00000004 ........              DC32    SLASH_NFA
 3674                           MOD:
 3675    00000008 ........              DC32    DOCOL
 3676    0000000C ........              DC32    SLMOD
 3677    00000010 ........              DC32    DROP
 3678    00000014 ........              DC32    SEMIS
 3679                           
 3680                           
 3681                           //      */MOD SSMOD:    ( n1 n2 n3 -- n4 n5 )
 3682                           //      Leave the quotient n5 and remainder n4 of the operation n1*n2/n3 A
 3683                           //      31 bit intermediate product is used as for */.
 3684                           
 3685                            SECTION .text : CONST (2)
 3686                           SSMOD_NFA:
 3687    00000000 85                    DC8     0x85
 3688    00000001 2A2F4D4F              DC8     '*/MO'
 3689    00000005 C4                    DC8     'D'+0x80
 3690    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 3691    00000008 ........              DC32    MODD_NFA
 3692                           SSMOD:
 3693    0000000C ........              DC32    DOCOL
 3694    00000010 ........              DC32    TOR
 3695    00000014 ........              DC32    MSTAR
 3696    00000018 ........              DC32    RFROM
 3697    0000001C ........              DC32    MSLASH
 3698    00000020 ........              DC32    SEMIS
 3699                           
 3700                           
 3701                           //      */ SSLASH:      ( n1 n2 n3 -- n4 )
 3702                           //      Leave the ratio n4 = n1*n2/n3 where all are signed numbers.
 3703                           //      Retention of an intermediate 31 bit product permits greater accuracy
 3704                           //      than would. be available with the sequence:
 3705                           //              n1  n2  *  n3  /
 3706                           
 3707                            SECTION .text : CONST (2)
 3708                           SSLASH_NFA:
 3709    00000000 82                    DC8     0x82
 3710    00000001 2A                    DC8     '*'
 3711    00000002 AF                    DC8     '/'+0x80
 3712    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3713    00000004 ........              DC32    SSMOD_NFA
 3714                           SSLASH:
 3715    00000008 ........              DC32    DOCOL
 3716    0000000C ........              DC32    SSMOD
 3717    00000010 ........              DC32    SWAP
 3718    00000014 ........              DC32    DROP
 3719    00000018 ........              DC32    SEMIS
 3720                           
 3721                           
 3722                           //      + PLUS: ( n1 n2 -- n3 )
 3723                           //      Add n1 and n2, leaving sum n3
 3724                           
 3725                            SECTION .text : CONST (2)
 3726                           PLUS_NFA:
 3727    00000000 81                    DC8     0x81
 3728    00000001 AB                    DC8     0xAB    // '+' + 0x80
 3729    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3730    00000004 ........              DC32    SSLASH_NFA
 3731                           PLUS:
 3732    00000008 ........              DC32    .+5
 3733                            SECTION .text : CODE (2)
 3734                                   POP2t
 3734.1                         #ifndef TOSCT
 3734.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3734.3                         #endif
 3734.4  00000002 3F1D                  ADDS    p, p, #4
 3734.5                                 ENDM
 3735                                   POP2n
 3735.1  00000004 3968                  LDR     n, [p]
 3735.2  00000006 3F1D                  ADDS    p, p, #4
 3735.3                                 ENDM
 3736    00000008 4018                  ADDS    t, t, n
 3737                                   TPUSH
 3737                                   PUSHt   // push t to p, pre decrement p
 3737.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3737.2  0000000C 3860                  STR     t, [p]
 3737.3                                 ENDM
 3737                                   NEXT
 3737.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3737                                   NEXT1
 3737.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3737.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3737.3                                 ENDM
 3737.4                                 ENDM
 3737.5                                 ENDM
 3738                           
 3739                           
 3740                           //      - SUBB: ( n1 n2 -- n3 )
 3741                           //      Leave the difference of n1-n2 as n3.
 3742                           //      1 2 - . -1
 3743                           //      2 1 - .  1
 3744                           
 3745                            SECTION .text : CONST (2)
 3746                           SUB_NFA:
 3747    00000000 81                    DC8     0x81
 3748    00000001 AD                    DC8     '-'+0x80
 3749    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3750    00000004 ........              DC32    PLUS_NFA
 3751                           SUBB:
 3752    00000008 ........              DC32    .+5
 3753                            SECTION .text : CODE (2)
 3754                                   POP2t
 3754.1                         #ifndef TOSCT
 3754.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3754.3                         #endif
 3754.4  00000002 3F1D                  ADDS    p, p, #4
 3754.5                                 ENDM
 3755                                   POP2n
 3755.1  00000004 3968                  LDR     n, [p]
 3755.2  00000006 3F1D                  ADDS    p, p, #4
 3755.3                                 ENDM
 3756    00000008 081A                  SUBS    t, n, t
 3757                                   TPUSH
 3757                                   PUSHt   // push t to p, pre decrement p
 3757.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3757.2  0000000C 3860                  STR     t, [p]
 3757.3                                 ENDM
 3757                                   NEXT
 3757.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3757                                   NEXT1
 3757.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3757.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3757.3                                 ENDM
 3757.4                                 ENDM
 3757.5                                 ENDM
 3758                           
 3759                           
 3760                           //      = EQUAL:        (n1 n2 -- f )
 3761                           //      Leave a non-zero true flag if n1=n2// otherwise leave a false flag.
 3762                           
 3763                            SECTION .text : CONST (2)
 3764                           EQUAL_NFA:
 3765    00000000 81                    DC8     0x81
 3766    00000001 BD                    DC8     '='+0x80
 3767    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3768    00000004 ........              DC32    SUB_NFA
 3769                           EQUAL:
 3770    00000008 ........              DC32    .+5
 3771                            SECTION .text : CODE (2)
 3772                           #ifdef TRUE_EQU_NEG_ONE
 3773    00000000 4040                  EORS    t, t
 3774                           #endif
 3775                                   POP2n
 3775.1  00000002 3968                  LDR     n, [p]
 3775.2  00000004 3F1D                  ADDS    p, p, #4
 3775.3                                 ENDM
 3776                                   POP2w
 3776.1  00000006 3A68                  LDR     w, [p]
 3776.2  00000008 3F1D                  ADDS    p, p, #4
 3776.3                                 ENDM
 3777    0000000A 891A                  SUBS    n, n, w
 3778    0000000C 04D0                  BEQ     EQUAL_TRUE
 3779                                   TPUSH   // zero
 3779                                   PUSHt   // push t to p, pre decrement p
 3779.1  0000000E 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3779.2  00000010 3860                  STR     t, [p]
 3779.3                                 ENDM
 3779                                   NEXT
 3779.1  00000012 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3779                                   NEXT1
 3779.1  00000014 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3779.2  00000016 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3779.3                                 ENDM
 3779.4                                 ENDM
 3779.5                                 ENDM
 3780                           
 3781                           EQUAL_TRUE:
 3782                           #ifdef TRUE_EQU_NEG_ONE
 3783    00000018 0138                  SUBS    t, #1 // -1
 3784                           #else
 3786                           #endif
 3787                                   TPUSH
 3787                                   PUSHt   // push t to p, pre decrement p
 3787.1  0000001A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3787.2  0000001C 3860                  STR     t, [p]
 3787.3                                 ENDM
 3787                                   NEXT
 3787.1  0000001E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3787                                   NEXT1
 3787.1  00000020 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3787.2  00000022 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3787.3                                 ENDM
 3787.4                                 ENDM
 3787.5                                 ENDM
 3788                           /*
 3789                                   DC32    DOCOL
 3790                                   DC32    SUBB
 3791                                   DC32    ZEQU
 3792                                   DC32    SEMIS
 3793                           */
 3794                           
 3795                           
 3796                           //      < LESSTHAN:     ( n1 n2 -- f ) SIGNED:
 3797                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3798                           //      C0 1 < . 0  -1 C0 < . 1
 3799                           
 3800                            SECTION .text : CONST (2)
 3801                           LESSTHAN_NFA:
 3802    00000000 81                    DC8     0x81
 3803    00000001 BC                    DC8     '<'+0x80
 3804    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3805    00000004 ........              DC32    EQUAL_NFA
 3806                           LESSTHAN:
 3807    00000008 ........              DC32    .+5
 3808                            SECTION .text : CODE (2)
 3809                           #ifdef TRUE_EQU_NEG_ONE
 3810    00000000 4040                  EORS    t, t    // zero t
 3811    00000002 0138                  SUBS    t, #1   // -1
 3812                           #else
 3814                           #endif
 3815                                   POP2n           // n2
 3815.1  00000004 3968                  LDR     n, [p]
 3815.2  00000006 3F1D                  ADDS    p, p, #4
 3815.3                                 ENDM
 3816                                   POP2w           // n1
 3816.1  00000008 3A68                  LDR     w, [p]
 3816.2  0000000A 3F1D                  ADDS    p, p, #4
 3816.3                                 ENDM
 3817    0000000C 9142                  CMP     n, w    // n1 < n2
 3818    0000000E 00DC                  BGT     LESS1
 3819                           
 3820    00000010 4040                  EORS    t, t    // zero t =< n
 3821                           LESS1:
 3822                                   TPUSH
 3822                                   PUSHt   // push t to p, pre decrement p
 3822.1  00000012 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3822.2  00000014 3860                  STR     t, [p]
 3822.3                                 ENDM
 3822                                   NEXT
 3822.1  00000016 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3822                                   NEXT1
 3822.1  00000018 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3822.2  0000001A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3822.3                                 ENDM
 3822.4                                 ENDM
 3822.5                                 ENDM
 3823                           
 3824                           
 3825                           //      U< ULESSTHAN:   ( n1 n2 -- f )  UNSIGNED:
 3826                           //      Leave a true flag if n1 is less than n2 otherwise leave a false flag.
 3827                           //      -1 -2 U< . 0  -1 2 U< . 0  1 2 U< . 1
 3828                           
 3829                            SECTION .text : CONST (2)
 3830                           ULESSTHAN_NFA:
 3831    00000000 82                    DC8     0x82
 3832    00000001 55                    DC8     'U'
 3833    00000002 BC                    DC8     '<'+0x80
 3834    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3835    00000004 ........              DC32    LESSTHAN_NFA
 3836                           ULESSTHAN:
 3837    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 3838    00000010 .............         DC32    XORR, ZLESS
                  ...          
 3839    00000018 ........              DC32    ZBRAN
 3840    0000001C 18000000              DC32    ULES1-. //IF
 3841                           
 3842    00000020 .............         DC32    DROP, ZLESS
                  ...          
 3843    00000028 ........              DC32    ZEQU
 3844    0000002C ........              DC32    BRAN
 3845    00000030 0C000000              DC32    ULES2-.
 3846                           
 3847                           ULES1:
 3848    00000034 .............         DC32    SUBB,ZLESS      //ELSE
                  ...          
 3849                           
 3850                           ULES2:
 3851    0000003C ........              DC32    SEMIS           //endif
 3852                           
 3853                           
 3854                           //      > GREATERTHAN:  ( n1 n2 -- f )  SIGNED: L0
 3855                           //      Leave a true flag if n1 is greater than n2 otherwise a false flag.
 3856                           //      -1 1 > . 0  1 -1 > . 1
 3857                           
 3858                            SECTION .text : CONST (2)
 3859                           GREATERTHAN_NFA:
 3860    00000000 81                    DC8     0x81
 3861    00000001 BE                    DC8     '>'+0x80
 3862    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 3863    00000004 ........              DC32    ULESSTHAN_NFA
 3864                           GREATERTHAN:
 3865    00000008 ........              DC32    DOCOL
 3866    0000000C ........              DC32    SWAP
 3867    00000010 ........              DC32    LESSTHAN
 3868    00000014 ........              DC32    SEMIS
 3869                           
 3870                           
 3871                           //      0= ZEQU:        ( n -- f )
 3872                           //      Leave a true flag is the number is equal to zero, otherwise leave a
 3873                           //      false flag. CHANGED Code dependent on true flag being 1 FOR -1 TRUE
 3874                           
 3875                            SECTION .text : CONST (2)
 3876                           ZEQU_NFA:
 3877    00000000 82                    DC8     0x82
 3878    00000001 30                    DC8     '0'
 3879    00000002 BD                    DC8     '='+0x80
 3880    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3881    00000004 ........              DC32    GREATERTHAN_NFA
 3882                           ZEQU:
 3883    00000008 ........              DC32    .+5
 3884                            SECTION .text : CODE (2)
 3885    00000000 4040                  EORS    t, t
 3886                                   POP2n
 3886.1  00000002 3968                  LDR     n, [p]
 3886.2  00000004 3F1D                  ADDS    p, p, #4
 3886.3                                 ENDM
 3887    00000006 0029                  CMP     n, #0
 3888    00000008 00D1                  BNE     ZEQU1
 3889                           
 3890                           #ifdef TRUE_EQU_NEG_ONE
 3891    0000000A 401E                  SUBS    t, t, #1
 3892                           #else
 3894                           #endif
 3895                           
 3896                           ZEQU1:
 3897                                   TPUSH
 3897                                   PUSHt   // push t to p, pre decrement p
 3897.1  0000000C 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3897.2  0000000E 3860                  STR     t, [p]
 3897.3                                 ENDM
 3897                                   NEXT
 3897.1  00000010 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3897                                   NEXT1
 3897.1  00000012 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3897.2  00000014 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3897.3                                 ENDM
 3897.4                                 ENDM
 3897.5                                 ENDM
 3898                           
 3899                           
 3900                           //      0< ZLESS:       ( n -- f )
 3901                           //      Leave a true flag if the number is less than zero (negative),
 3902                           //      otherwise leave a false flag.
 3903                           
 3904                            SECTION .text : CONST (2)
 3905                           ZLESS_NFA:
 3906    00000000 82                    DC8     0x82
 3907    00000001 30                    DC8     '0'
 3908    00000002 BC                    DC8     '<'+0x80
 3909    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 3910    00000004 ........              DC32    ZEQU_NFA
 3911                           ZLESS:
 3912    00000008 ........              DC32    .+5
 3913                            SECTION .text : CODE (2)
 3914                           #ifdef TOSCT    // REPLACING t SO THIS IS FASTER THAN POP2n
 3917                           #else
 3918                                   POP2n
 3918.1  00000000 3968                  LDR     n, [p]
 3918.2  00000002 3F1D                  ADDS    p, p, #4
 3918.3                                 ENDM
 3919                           #endif
 3920                           #ifdef TRUE_EQU_NEG_ONE
 3921    00000004 4040                  EORS    t, t
 3922    00000006 0138                  SUBS    t, #1   // TRUE -1
 3923                           #else
 3925                           #endif
 3926    00000008 0943                  ORRS    n, n, n // SET FLAGS
 3927    0000000A 00D4                  BMI     ZLESS1  // JS   ZLESS1
 3928                           
 3929    0000000C 4040                  EORS    t, t    // FALSE
 3930                           ZLESS1:
 3931                                   TPUSH
 3931                                   PUSHt   // push t to p, pre decrement p
 3931.1  0000000E 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3931.2  00000010 3860                  STR     t, [p]
 3931.3                                 ENDM
 3931                                   NEXT
 3931.1  00000012 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3931                                   NEXT1
 3931.1  00000014 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3931.2  00000016 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3931.3                                 ENDM
 3931.4                                 ENDM
 3931.5                                 ENDM
 3932                           
 3933                           
 3934                           //      BIN BIN:        ( -- )
 3935                           //      Set the numeric conversion base to TWO (bianry).
 3936                           
 3937                            SECTION .text : CONST (2)
 3938                           BIN_NFA:
 3939    00000000 83                    DC8     0x83
 3940    00000001 4249                  DC8     'BI'
 3941    00000003 CE                    DC8     'N'+0x80
 3942                            ALIGNROM 2,0xFFFFFFFF
 3943    00000004 ........              DC32    ZLESS_NFA
 3944                           BIN:
 3945    00000008 ........              DC32    DOCOL
 3946    0000000C ........02000         DC32    STRVA, 2, NBASE
                  000........  
 3947    00000018 ........              DC32    SEMIS
 3948                           
 3949                           
 3950                           //      HEX HEX:        ( -- )
 3951                           //      Set the numeric conversion base to sixteen (hexadecimal).
 3952                           
 3953                            SECTION .text : CONST (2)
 3954                           HEX_NFA:
 3955    00000000 83                    DC8     0x83
 3956    00000001 4845                  DC8     'HE'
 3957    00000003 D8                    DC8     'X'+0x80
 3958                            ALIGNROM 2,0xFFFFFFFF
 3959    00000004 ........              DC32    BIN_NFA
 3960                           HEX:
 3961    00000008 ........              DC32    DOCOL
 3962    0000000C ........10000         DC32    STRVA, 16, NBASE
                  000........  
 3963    00000018 ........              DC32    SEMIS
 3964                           
 3965                           
 3966                           //      DECIMAL DECIMAL:        ( -- )
 3967                           //      Set the numeric conversion base to TEN (decimal).
 3968                           //      DEC IS A NUMBER!
 3969                           
 3970                            SECTION .text : CONST (2)
 3971                           DECIMAL_NFA:
 3972    00000000 87                    DC8     0x87
 3973    00000001 444543494D41          DC8     'DECIMA'
 3974    00000007 CC                    DC8     'L'+0x80
 3975                            ALIGNROM 2,0xFFFFFFFF
 3976    00000008 ........              DC32    HEX_NFA
 3977                           DECIMAL:
 3978    0000000C ........              DC32    DOCOL
 3979    00000010 ........0A000         DC32    STRVA, 10, NBASE
                  000........  
 3980    0000001C ........              DC32    SEMIS
 3981                           
 3982                           
 3983                           //      NEGATE NEGATE: ( n1 -- n2 ) RENAMED: MINUS to NEGATE
 3984                           //      Leave the two's complement of a number.
 3985                           
 3986                            SECTION .text : CONST (2)
 3987                           NEGATE_NFA:
 3988    00000000 86                    DC8     0x86
 3989    00000001 4E45474154            DC8     'NEGAT'
 3990    00000006 C5                    DC8     'E'+0x80
 3991    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 3992    00000008 ........              DC32    DECIMAL_NFA
 3993                           NEGATE:
 3994    0000000C ........              DC32    .+5
 3995                            SECTION .text : CODE (2)
 3996                                   POP2t                   // MVN YES
 3996.1                         #ifndef TOSCT
 3996.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 3996.3                         #endif
 3996.4  00000002 3F1D                  ADDS    p, p, #4
 3996.5                                 ENDM
 3997    00000004 C043                  MVNS     t, t           // 1's compliment
 3998    00000006 401C                  ADDS     t, t, #1       // 2's compliment
 3999                                   TPUSH
 3999                                   PUSHt   // push t to p, pre decrement p
 3999.1  00000008 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 3999.2  0000000A 3860                  STR     t, [p]
 3999.3                                 ENDM
 3999                                   NEXT
 3999.1  0000000C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 3999                                   NEXT1
 3999.1  0000000E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 3999.2  00000010 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 3999.3                                 ENDM
 3999.4                                 ENDM
 3999.5                                 ENDM
 4000                           
 4001                           
 4002                           //      ABS ABS:        ( n -- ub )
 4003                           //      Leave the absolute value of n as un.
 4004                           
 4005                            SECTION .text : CONST (2)
 4006                           ABS1_NFA:
 4007    00000000 83                    DC8     0x83
 4008    00000001 4142                  DC8     'AB'
 4009    00000003 D3                    DC8     'S'+0x80
 4010                            ALIGNROM 2,0xFFFFFFFF
 4011    00000004 ........              DC32    NEGATE_NFA
 4012                           ABS:
 4013    00000008 ........              DC32    DOCOL
 4014    0000000C ........              DC32    DUP
 4015    00000010 ........              DC32    PM
 4016    00000014 ........              DC32    SEMIS
 4017                           
 4018                           
 4019                           //      MIN MIN:        ( n1 n2 -- min )
 4020                           //      Leave the smaller of two numbers.
 4021                           
 4022                            SECTION .text : CONST (2)
 4023                           MIN_NFA:
 4024    00000000 83                    DC8     0x83
 4025    00000001 4D49                  DC8     'MI'
 4026    00000003 CE                    DC8     'N'+0x80
 4027                            ALIGNROM 2,0xFFFFFFFF
 4028    00000004 ........              DC32    ABS1_NFA
 4029                           MIN:
 4030    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 4031    00000010 ........              DC32    GREATERTHAN
 4032    00000014 ........              DC32    ZBRAN   //IF
 4033    00000018 08000000              DC32     MIN1-.
 4034                           
 4035    0000001C ........              DC32    SWAP    //endif
 4036                           MIN1:
 4037    00000020 ........              DC32    DROP
 4038    00000024 ........              DC32    SEMIS
 4039                           
 4040                           
 4041                           //      MAX MAX:        ( n1 n2 -- max )
 4042                           //      Leave the greater of two numbers.
 4043                           
 4044                            SECTION .text : CONST (2)
 4045                           MAX_NFA:
 4046    00000000 83                    DC8     0x83
 4047    00000001 4D41                  DC8     'MA'
 4048    00000003 D8                    DC8     'X'+0x80
 4049                            ALIGNROM 2,0xFFFFFFFF
 4050    00000004 ........              DC32    MIN_NFA
 4051                           MAX:
 4052    00000008 .............         DC32    DOCOL,TDUP
                  ...          
 4053    00000010 ........              DC32    LESSTHAN
 4054    00000014 ........              DC32    ZBRAN   //IF
 4055    00000018 08000000              DC32     MAX1-.
 4056                           
 4057    0000001C ........              DC32    SWAP    //endif
 4058                           MAX1:
 4059    00000020 ........              DC32    DROP
 4060    00000024 ........              DC32    SEMIS
 4061                           
 4062                           
 4063                           //      AND ANDD:       ( n1 n2 -- n2 )
 4064                           //      Leave the bitwise logical and of n1 and n2 as n3.
 4065                           
 4066                            SECTION .text : CONST (2)
 4067                           ANDD_NFA:
 4068    00000000 83                    DC8     0x83
 4069    00000001 414E                  DC8     'AN'
 4070    00000003 C4                    DC8     'D'+0x80
 4071                            ALIGNROM 2,0xFFFFFFFF
 4072    00000004 ........              DC32    MAX_NFA
 4073                           ANDD:
 4074    00000008 ........              DC32    .+5
 4075                            SECTION .text : CODE (2)
 4076                                   POP2t
 4076.1                         #ifndef TOSCT
 4076.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4076.3                         #endif
 4076.4  00000002 3F1D                  ADDS    p, p, #4
 4076.5                                 ENDM
 4077                                   POP2n
 4077.1  00000004 3968                  LDR     n, [p]
 4077.2  00000006 3F1D                  ADDS    p, p, #4
 4077.3                                 ENDM
 4078    00000008 0840                  ANDS     t, t, n
 4079                                   TPUSH
 4079                                   PUSHt   // push t to p, pre decrement p
 4079.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4079.2  0000000C 3860                  STR     t, [p]
 4079.3                                 ENDM
 4079                                   NEXT
 4079.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4079                                   NEXT1
 4079.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4079.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4079.3                                 ENDM
 4079.4                                 ENDM
 4079.5                                 ENDM
 4080                           
 4081                           
 4082                           //      OR OR:  ( n1 n2 -- n3 )
 4083                           //      Leave the bit-wise logical or of n1 and n2 as n3.
 4084                           
 4085                            SECTION .text : CONST (2)
 4086                           OR_NFA:
 4087    00000000 82                    DC8     0x82
 4088    00000001 4F                    DC8     'O'
 4089    00000002 D2                    DC8     'R'+0x80
 4090    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4091    00000004 ........              DC32    ANDD_NFA
 4092                           OR:
 4093    00000008 ........              DC32    .+5
 4094                            SECTION .text : CODE (2)
 4095                                   POP2t
 4095.1                         #ifndef TOSCT
 4095.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4095.3                         #endif
 4095.4  00000002 3F1D                  ADDS    p, p, #4
 4095.5                                 ENDM
 4096                                   POP2n
 4096.1  00000004 3968                  LDR     n, [p]
 4096.2  00000006 3F1D                  ADDS    p, p, #4
 4096.3                                 ENDM
 4097    00000008 0843                  ORRS     t, t, n
 4098                                   TPUSH
 4098                                   PUSHt   // push t to p, pre decrement p
 4098.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4098.2  0000000C 3860                  STR     t, [p]
 4098.3                                 ENDM
 4098                                   NEXT
 4098.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4098                                   NEXT1
 4098.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4098.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4098.3                                 ENDM
 4098.4                                 ENDM
 4098.5                                 ENDM
 4099                           
 4100                           
 4101                           //      NOT NOT: ( nl -- n2 )
 4102                           //      Leave the bitwise logical not of n1 as n2
 4103                           
 4104                            SECTION .text : CONST (2)
 4105                           NOT_NFA:
 4106    00000000 83                    DC8     0x83
 4107    00000001 4E4F                  DC8     'NO'
 4108    00000003 D4                    DC8     'T'+0x80
 4109                            ALIGNROM 2,0xFFFFFFFF
 4110    00000004 ........              DC32    OR_NFA
 4111                           NOT:
 4112    00000008 ........              DC32    .+5
 4113                            SECTION .text : CODE (2)
 4114                                   POP2t
 4114.1                         #ifndef TOSCT
 4114.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4114.3                         #endif
 4114.4  00000002 3F1D                  ADDS    p, p, #4
 4114.5                                 ENDM
 4115    00000004 C043                  MVNS            t, t    // 1's compliment
 4116                                   TPUSH
 4116                                   PUSHt   // push t to p, pre decrement p
 4116.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4116.2  00000008 3860                  STR     t, [p]
 4116.3                                 ENDM
 4116                                   NEXT
 4116.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4116                                   NEXT1
 4116.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4116.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4116.3                                 ENDM
 4116.4                                 ENDM
 4116.5                                 ENDM
 4117                           
 4118                           
 4119                           //      XORR XOR:       ( nl n2 -- n3 )
 4120                           //      Leave the bitwise logical exclusive or n1 and n2 as n3
 4121                           
 4122                            SECTION .text : CONST (2)
 4123                           XORR_NFA:
 4124    00000000 83                    DC8     0x83
 4125    00000001 584F                  DC8     'XO'
 4126    00000003 D2                    DC8     'R'+0x80
 4127                            ALIGNROM 2,0xFFFFFFFF
 4128    00000004 ........              DC32    NOT_NFA
 4129                           XORR:
 4130    00000008 ........              DC32    .+5
 4131                            SECTION .text : CODE (2)
 4132                                   POP2t
 4132.1                         #ifndef TOSCT
 4132.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4132.3                         #endif
 4132.4  00000002 3F1D                  ADDS    p, p, #4
 4132.5                                 ENDM
 4133                                   POP2n
 4133.1  00000004 3968                  LDR     n, [p]
 4133.2  00000006 3F1D                  ADDS    p, p, #4
 4133.3                                 ENDM
 4134    00000008 4840                  EORS     t, t, n
 4135                                   TPUSH
 4135                                   PUSHt   // push t to p, pre decrement p
 4135.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4135.2  0000000C 3860                  STR     t, [p]
 4135.3                                 ENDM
 4135                                   NEXT
 4135.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4135                                   NEXT1
 4135.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4135.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4135.3                                 ENDM
 4135.4                                 ENDM
 4135.5                                 ENDM
 4136                           
 4137                           
 4138                           //      SXTH SXTH:      ( nl -- n3 )
 4139                           //      Sign extend HALFWORD on the stack
 4140                           
 4141                            SECTION .text : CONST (2)
 4142                           SXTH_NFA:
 4143    00000000 84                    DC8     0x84
 4144    00000001 535854                DC8     'SXT'
 4145    00000004 C8                    DC8     'H'+0x80
 4146    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4147    00000008 ........              DC32    XORR_NFA
 4148                           SXTH:
 4149    0000000C ........              DC32    .+5
 4150                            SECTION .text : CODE (2)
 4151                                   POP2t
 4151.1                         #ifndef TOSCT
 4151.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4151.3                         #endif
 4151.4  00000002 3F1D                  ADDS    p, p, #4
 4151.5                                 ENDM
 4152    00000004 00B2                  SXTH     t, t
 4153                                   TPUSH
 4153                                   PUSHt   // push t to p, pre decrement p
 4153.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4153.2  00000008 3860                  STR     t, [p]
 4153.3                                 ENDM
 4153                                   NEXT
 4153.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4153                                   NEXT1
 4153.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4153.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4153.3                                 ENDM
 4153.4                                 ENDM
 4153.5                                 ENDM
 4154                           
 4155                           
 4156                           //      SXTB SXTB:      ( nl -- n3 )
 4157                           //      Sign extend byte in the word on the stack
 4158                           
 4159                            SECTION .text : CONST (2)
 4160                           SXTB_NFA:
 4161    00000000 84                    DC8     0x84
 4162    00000001 535854                DC8     'SXT'
 4163    00000004 C2                    DC8     'B'+0x80
 4164    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4165    00000008 ........              DC32    SXTH_NFA
 4166                           SXTB:
 4167    0000000C ........              DC32    .+5
 4168                            SECTION .text : CODE (2)
 4169                                   POP2t
 4169.1                         #ifndef TOSCT
 4169.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4169.3                         #endif
 4169.4  00000002 3F1D                  ADDS    p, p, #4
 4169.5                                 ENDM
 4170    00000004 40B2                  SXTB     t, t
 4171                                   TPUSH
 4171                                   PUSHt   // push t to p, pre decrement p
 4171.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4171.2  00000008 3860                  STR     t, [p]
 4171.3                                 ENDM
 4171                                   NEXT
 4171.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4171                                   NEXT1
 4171.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4171.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4171.3                                 ENDM
 4171.4                                 ENDM
 4171.5                                 ENDM
 4172                           
 4173                           
 4174                           //      REVW REVW:      ( n -- n )
 4175                           //      Reverse bytes in n.
 4176                           
 4177                            SECTION .text : CONST (2)
 4178                           REVW_NFA:
 4179    00000000 84                    DC8     0x84
 4180    00000001 524556                DC8     'REV'
 4181    00000004 D7                    DC8     'W'+0x80
 4182    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4183    00000008 ........              DC32    SXTB_NFA
 4184                           REVW:
 4185    0000000C ........              DC32    .+5
 4186                            SECTION .text : CODE (2)
 4187                                   POP2t
 4187.1                         #ifndef TOSCT
 4187.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4187.3                         #endif
 4187.4  00000002 3F1D                  ADDS    p, p, #4
 4187.5                                 ENDM
 4188    00000004 00BA                  REV     t, t
 4189                                   TPUSH
 4189                                   PUSHt   // push t to p, pre decrement p
 4189.1  00000006 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4189.2  00000008 3860                  STR     t, [p]
 4189.3                                 ENDM
 4189                                   NEXT
 4189.1  0000000A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4189                                   NEXT1
 4189.1  0000000C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4189.2  0000000E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4189.3                                 ENDM
 4189.4                                 ENDM
 4189.5                                 ENDM
 4190                           
 4191                           
 4192                           //      ASR ASR:   ( sn count -- sn' )  
 4193                           //      Shift sn (sign-extended) right by count.
 4194                           //      Valid count values are 0 to 31.
 4195                           
 4196                            SECTION .text : CONST (2)
 4197                           ASR_NFA:
 4198    00000000 83                    DC8     0x83
 4199    00000001 4153                  DC8     'AS'
 4200    00000003 D2                    DC8     'R'+0x80
 4201                            ALIGNROM 2,0xFFFFFFFF
 4202    00000004 ........              DC32    REVW_NFA
 4203                           ASR:
 4204    00000008 ........              DC32    .+5
 4205                            SECTION .text : CODE (2)
 4206                                   POP2w           ; shift count
 4206.1  00000000 3A68                  LDR     w, [p]
 4206.2  00000002 3F1D                  ADDS    p, p, #4
 4206.3                                 ENDM
 4207                                   POP2t           ; original data
 4207.1                         #ifndef TOSCT
 4207.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4207.3                         #endif
 4207.4  00000006 3F1D                  ADDS    p, p, #4
 4207.5                                 ENDM
 4208    00000008 1041                  ASRS    t, t, w
 4209                                   TPUSH           ; shifted data
 4209                                   PUSHt   // push t to p, pre decrement p
 4209.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4209.2  0000000C 3860                  STR     t, [p]
 4209.3                                 ENDM
 4209                                   NEXT
 4209.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4209                                   NEXT1
 4209.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4209.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4209.3                                 ENDM
 4209.4                                 ENDM
 4209.5                                 ENDM
 4210                           
 4211                           
 4212                           //      LSR LSR:   ( n count -- n' )
 4213                           //      Logical (zero-extended) shift right by count.
 4214                           //      Valid count values are 0 to 31.
 4215                           
 4216                            SECTION .text : CONST (2)
 4217                           LSR_NFA:
 4218    00000000 83                    DC8     0x83
 4219    00000001 4C53                  DC8     'LS'
 4220    00000003 D2                    DC8     'R'+0x80
 4221                            ALIGNROM 2,0xFFFFFFFF
 4222    00000004 ........              DC32    ASR_NFA
 4223                           LSR:
 4224    00000008 ........              DC32    .+5
 4225                            SECTION .text : CODE (2)
 4226                                   POP2w           ; shift count
 4226.1  00000000 3A68                  LDR     w, [p]
 4226.2  00000002 3F1D                  ADDS    p, p, #4
 4226.3                                 ENDM
 4227                                   POP2t           ; original data
 4227.1                         #ifndef TOSCT
 4227.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4227.3                         #endif
 4227.4  00000006 3F1D                  ADDS    p, p, #4
 4227.5                                 ENDM
 4228    00000008 D040                  LSRS    t, t, w
 4229                                   TPUSH           ; shifted data
 4229                                   PUSHt   // push t to p, pre decrement p
 4229.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4229.2  0000000C 3860                  STR     t, [p]
 4229.3                                 ENDM
 4229                                   NEXT
 4229.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4229                                   NEXT1
 4229.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4229.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4229.3                                 ENDM
 4229.4                                 ENDM
 4229.5                                 ENDM
 4230                           
 4231                           
 4232                           //      LSL LSL:   ( n count -- n' )
 4233                           //      Logical (zero-extended) shift left by count.
 4234                           //      Valid count values are 0 to 31.
 4235                           
 4236                            SECTION .text : CONST (2)
 4237                           LSL_NFA:
 4238    00000000 83                    DC8     0x83
 4239    00000001 4C53                  DC8     'LS'
 4240    00000003 CC                    DC8     'L'+0x80
 4241                            ALIGNROM 2,0xFFFFFFFF
 4242    00000004 ........              DC32    LSR_NFA
 4243                           LSL:
 4244    00000008 ........              DC32    .+5
 4245                            SECTION .text : CODE (2)
 4246                                   POP2w           ; shift count
 4246.1  00000000 3A68                  LDR     w, [p]
 4246.2  00000002 3F1D                  ADDS    p, p, #4
 4246.3                                 ENDM
 4247                                   POP2t           ; original data
 4247.1                         #ifndef TOSCT
 4247.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4247.3                         #endif
 4247.4  00000006 3F1D                  ADDS    p, p, #4
 4247.5                                 ENDM
 4248    00000008 9040                  LSLS    t, t, w
 4249                                   TPUSH           ; shifted data---
 4249                                   PUSHt   // push t to p, pre decrement p
 4249.1  0000000A 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4249.2  0000000C 3860                  STR     t, [p]
 4249.3                                 ENDM
 4249                                   NEXT
 4249.1  0000000E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4249                                   NEXT1
 4249.1  00000010 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4249.2  00000012 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4249.3                                 ENDM
 4249.4                                 ENDM
 4249.5                                 ENDM
 4250                           
 4251                           
 4252                           //      .R DOTR:        ( sn1 n2 -- ) SIGNED:
 4253                           //      Print the signed number sn1 right aligned in a field whose width is n2.
 4254                           //      No following blank is printed.
 4255                           
 4256                            SECTION .text : CONST (2)
 4257                           DOTR_NFA:
 4258    00000000 82                    DC8     0x82
 4259    00000001 2E                    DC8     '.'
 4260    00000002 D2                    DC8     'R'+0x80
 4261    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4262    00000004 ........              DC32    LSL_NFA
 4263                           DOTR:
 4264    00000008 ........              DC32    DOCOL
 4265    0000000C ........              DC32    TOR
 4266    00000010 ........              DC32    STOD
 4267    00000014 ........              DC32    RFROM
 4268    00000018 ........              DC32    DDOTR
 4269    0000001C ........              DC32    SEMIS
 4270                           
 4271                           
 4272                           //      .RU DOTRU:      ( n1 n2 -- ) UNSIGNED:
 4273                           //      Print the unsigned number n1 right aligned in a field whose width is n2.
 4274                           //      No following blank is printed.
 4275                           
 4276                            SECTION .text : CONST (2)
 4277                           DOTRU_NFA:
 4278    00000000 83                    DC8     0x83
 4279    00000001 2E52                  DC8     '.R'
 4280    00000003 D5                    DC8     'U'+0x80
 4281                            ALIGNROM 2,0xFFFFFFFF
 4282    00000004 ........              DC32    DOTR_NFA
 4283                           DOTRU:
 4284    00000008 ........              DC32    DOCOL
 4285    0000000C ........              DC32    TOR
 4286    00000010 ........              DC32    ZERO
 4287    00000014 .............         DC32    BDIGS, DIGS, EDIGS
                  ...........  
 4288    00000020 .............         DC32    DUP, RFROM
                  ...          
 4289    00000028 .............         DC32    SWAP, SUBB, SPACES, TYPE
                  .............
                  ......       
 4290                           #ifdef IO2TP
 4293                           #endif
 4294    00000038 ........              DC32    SEMIS
 4295                           
 4296                           
 4297                           //      U. UDOT:        ( n -- ) USIGNED DOT
 4298                           
 4299                            SECTION .text : CONST (2)
 4300                           UDOT_NFA:
 4301    00000000 82                    DC8     0x82
 4302    00000001 55                    DC8     'U'
 4303    00000002 AE                    DC8     '.'+0x80
 4304    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4305    00000004 ........              DC32    DOTRU_NFA
 4306                           UDOT:
 4307    00000008 ........              DC32    DOCOL
 4308    0000000C ........              DC32    ZERO
 4309    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4310    00000014 ........              DC32    SEMIS
 4311                           
 4312                           
 4313                           //      ? QUES: ( addr -- )
 4314                           //      Print the value contained at the address in free format according to
 4315                           //      the current base using DOT.
 4316                           
 4317                            SECTION .text : CONST (2)
 4318                           QUES_NFA:
 4319    00000000 81                    DC8     0x81
 4320    00000001 BF                    DC8     '?'+0x80
 4321    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4322    00000004 ........              DC32    UDOT_NFA
 4323                           QUES:
 4324    00000008 ........              DC32    DOCOL
 4325    0000000C ........              DC32    AT
 4326    00000010 ........              DC32    DOT
 4327    00000014 ........              DC32    SEMIS
 4328                           
 4329                           
 4330                           //      . DOT:  ( n -- ) SIGNED 2'S COMPLEMENT:
 4331                           //      Print a number from a signed 32 bit two's complement value,
 4332                           //      converted according to the numeric base.
 4333                           //      A trailing blanks follows.
 4334                           
 4335                            SECTION .text : CONST (2)
 4336                           DOT_NFA:
 4337    00000000 81                    DC8     0x81
 4338    00000001 AE                    DC8     '.'+0x80
 4339    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 4340    00000004 ........              DC32    QUES_NFA
 4341                           DOT:
 4342    00000008 ........              DC32    DOCOL
 4343    0000000C ........              DC32    STOD
 4344    00000010 ........              DC32    DDOT    // SPACE DONE HERE
 4345    00000014 ........              DC32    SEMIS
 4346                           
 4347                           
 4348                           //------------------------------ DOTBASE SECTION -------------------------------
 4349                           
 4350                           #ifndef SRM
 4351                           //      .B DOTBIN:      ( n -- )
 4352                           //      Prints TOS in BINARY using DOT, not affecting Base in the system
 4353                           
 4354                            SECTION .text : CONST (2)
 4355                           DOTBIN_NFA:
 4356    00000000 82                    DC8     0x82
 4357    00000001 2E                    DC8     '.'
 4358    00000002 C2                    DC8     'B'+0x80
 4359    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4360    00000004 ........              DC32    DOT_NFA
 4361                           DOTBIN:
 4362    00000008 ........              DC32    DOCOL
 4363    0000000C .............         DC32    TWO, DOTBASE
                  ...          
 4364    00000014 ........              DC32    SEMIS
 4365                           #endif  // not SRM
 4366                           
 4367                           
 4368                           //      .H DOTHEX:      ( n -- )
 4369                           //      Prints TOS in Hex using DOT, not affecting Base in the system
 4370                            SECTION .text : CONST (2)
 4371                           DOTHEX_NFA:
 4372    00000000 82                    DC8     0x82
 4373    00000001 2E                    DC8     '.'
 4374    00000002 C8                    DC8     'H'+0x80
 4375    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4376                           #ifdef SRM
 4378                           #else
 4379    00000004 ........              DC32    DOTBIN_NFA
 4380                           #endif
 4381                           DOTHEX:
 4382    00000008 ........              DC32    DOCOL
 4383                           #ifdef SRM
 4385                           #else
 4386    0000000C ........10000         DC32    LIT, 16, DOTBASE        // this version appends BASE Suffix
                  000........  
 4387                           #endif
 4388    00000018 ........              DC32    SEMIS
 4389                           
 4390                           
 4391                           #ifndef SRM
 4392                           //      .D DOTDEC:      ( n -- )
 4393                           //      Prints TOS in DECIMAL using DOT, not affecting Base in the system
 4394                           
 4395                            SECTION .text : CONST (2)
 4396                           DOTDEC_NFA:
 4397    00000000 82                    DC8     0x82
 4398    00000001 2E                    DC8     '.'
 4399    00000002 C4                    DC8     'D'+0x80
 4400    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4401    00000004 ........              DC32    DOTHEX_NFA
 4402                           DOTDEC:
 4403    00000008 ........              DC32    DOCOL
 4404    0000000C ........0A000         DC32    LIT, 10, DOTBASE
                  000........  
 4405    00000018 ........              DC32    SEMIS
 4406                           #endif  // not SRM
 4407                           
 4408                           
 4409                           //=============================== WORDCAT ====================================//
 4410                           //NOEXEC HEADERFORWORDCATEGORIES
 4411                           //      WC_NUMBERS_NFA = NUMBER Stuff: CATEGORY
 4412                           
 4413                            SECTION .text : CONST (2)
 4414                           WC_NUMBERS_NFA:
 4415    00000000 91                    DC8     0x80+4+13
 4416    00000001 0D0A                  DC8     0x0D, 0x0A
 4417    00000003 4E554D4245522         DC8     'NUMBER Stuff:'
                  053747566663A
 4418    00000010 0D8A                  DC8     0x0D, 0x0A+0x80
 4419    00000012 FFFF           ALIGNROM 2,0xFFFFFFFF
 4420                           #ifdef SRM
 4422                           #else
 4423    00000014 ........              DC32    DOTDEC_NFA
 4424                           #endif
 4425                           //=============================== UART0_INIT =================================//
 4426                           
 4427                           // LFA ABOVE NEEDS TO BE WC_NUMBERS_NFA
 4428                           
 4429                           #if     NXP_M0_11xx | NXP_M0_1115
 4430                           $FISH_NXP_M0_11xx_UART0_INIT.s
    1                           //      FISH_NXP_M0_11xx_UART0_INIT.s
    2                           
    3                           //      UART0_INIT UART0_INIT: ( -- )
    4                           //      If setting BAUD MYBAUD MUST BE USED FIRST
    5                           //      THIS IS TO PRESERVE YOUR BAUD DURING HARD FAULT RESET
    6                           //      UseDEFAULT_BAUD UNLESS DBAUD IS ZERO, THEN USE UBAUD VALUE
    7                           //      WHEN DBAUD IS NOT ZERO USE DEFAULT_BAUD         // pwrup
    8                           //      WHEN DBAUD IS ZERO USE UBAUD                    // RESET
    9                           
   10                            SECTION .text : CONST (2)
   11                           UART0_INIT_NFA:
   12    00000000 8A                    DC8     0x8A
   13    00000001 55415254305F4         DC8     'UART0_INI'
                  94E49        
   14    0000000A D4                    DC8     'T'+0x80
   15    0000000B FF             ALIGNROM 2,0xFFFFFFFF
   16    0000000C ........              DC32    WC_NUMBERS_NFA
   17                           UART0_INIT:
   18    00000010 ........              DC32    DOCOL
   19                           
   20                           #ifndef DEFAULT_BAUD_TEST
   21    00000014 ........400D0   DC32  LIT, DBAUD, AT, ZEQU
                  010..........
                  ......       
   22    00000024 ........        DC32  ZBRAN
   23    00000028 1C000000        DC32    BAUDDEFAULT-.         // IF DBAUD not ZERO SET DEFAULT_BAUD
   24    0000002C ........440D0   DC32  LIT, UBAUD, AT          // IARBUG , TOR
                  010........  
   25    00000038 ........        DC32    TOR                   // ELSE USE UBAUD
   26    0000003C ........        DC32  BRAN
   27    00000040 10000000        DC32    BAUD1-.                       // SET UBAUD TO ZERO TO PRESERVE UBAUD
   28                           #endif
   29                           
   30                           BAUDDEFAULT:                            // ELSE
   31    00000044 ........80250         DC32    LIT, DEFAULT_BAUD       // IARBUG , TOR
                  000          
   32    0000004C ........              DC32    TOR                     // SET
   33                           BAUD1:
   34    00000050 ........A4400         DC32    LIT, IOCON_PIO1_6       // RX w/ hysteresus
                  440          
   35    00000058 ........39000         DC32    LIT, 39h, SETBITS
                  000........  
   36                           
   37    00000064 ........A8400         DC32    LIT, IOCON_PIO1_7       // TX
                  440          
   38    0000006C .............         DC32    ONE, SETBITS
                  ...          
   39                           
   40    00000074 ........01000         DC32    STRVA, 1, UARTCLKDIV    // UARTCLKDIV = 1
                  00098800440  
   41                           
   42    00000080 ........83000         DC32    STRVA, 0x83, U0LCR      // DLAB = 1 8n1
                  0000C800040  
   43                           
   44                           //      regVal = LPC_SYSCON->UARTCLKDIV//
   45                           //      Fdiv = (((SystemCoreClock*LPC_SYSCON->SYSAHBCLKDIV)/regVal)/16)/baudrate
   46                           //      LPC_UART->DLM = Fdiv / 256//
   47                           //      LPC_UART->DLL = Fdiv % 256//
   48                           //      LPC_UART->LCR = 0x03//          // DLAB = 0 8n1
   49                           
   50                                   // DIV BY UARTCLKDIV 1RST IF NOT 1 !
   51                                   // SYSCLK 16 / R>  /  256  /MOD
   52                           
   53    0000008C .............         DC32    SYSCLK, LIT, 16, SLASH
                  ...10000000..
                  ......       
   54    0000009C ........              DC32    RFROM                   // Baud
   55    000000A0 ........              DC32    SLASH
   56    000000A4 ........00010         DC32    LIT, 256, SLMOD
                  000........  
   57                           DLM:
   58                           //        DC32    NOOP
   59    000000B0 .............         DC32    UART0_RX, FOURP, STORE  // DLM = TOS = 1 FOR 9600 @ 48MHZ
                  ...........  
   60                           DLL:        
   61    000000BC .............         DC32    UART0_RX, STORE         // DLL = NOS - 38h FOR 9600 @ 48MHZ
                  ...          
   62                           
   63    000000C4 ........03000         DC32    STRVA, 3, U0LCR         // DLAB = 0 8n1
                  0000C800040  
   64                           
   65    000000D0 ........00000         DC32    STRVA, 0, U0FCR         // FIFO'S OFF
                  00008800040  
   66    000000DC ........07000         DC32    STRVA, 7, U0FCR         // FIFO'S ON
                  00008800040  
   67                           
   68    000000E8 .............         DC32    UART0_LSR, DROP         // Clear Line Status Register
                  ...          
   69                           //      DC32    CLRUART
   70                           #ifdef DEFAULT_BAUD_TEST
   72                           #endif
   73    000000F0 ........              DC32    SEMIS
 4431                           #endif  // NXP_M0_11xx
 4432                           
 4433                           #ifdef NXP_M0_812
 4435                           #endif  // NXP_M0_812
 4436                           
 4437                           // LFA BELOW NEEDS TO BE UART0_INIT_NFA
 4438                           
 4439                           //      MYBAUD MYBAUD: ( n -- ) BAUD MUST BE in DECIMAL or EQUIVALENT!!!
 4440                           //      MUST BE USED BEFORE USING UART0_INIT!!!
 4441                           //      Because FISH does a reset if you invoke a HARD FAULT RESET
 4442                           //      THIS MECHANISM IS ESSENTIAL TO STAYING AT USER SET BAUDRATE THRU A RESET!
 4443                           //      SET NON-INIT RAM VARIABLES DBAUD TO ZERO AND UBAUD n.
 4444                           //      See UART0_INIT
 4445                           
 4446                            SECTION .text : CONST (2)
 4447                           MYBAUD_NFA:
 4448    00000000 86                    DC8     0x86
 4449    00000001 4D59424155            DC8     'MYBAU'
 4450    00000006 C4                    DC8     'D'+0x80
 4451    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4452    00000008 ........              DC32    UART0_INIT_NFA
 4453                           MYBAUD:
 4454    0000000C ........              DC32    DOCOL
 4455    00000010 ........00000         DC32    STRVA, 0, DBAUD
                  000400D0010  
 4456    0000001C ........440D0         DC32    LIT, UBAUD, STORE       // SET UBAUD TO NEW BAUD FOR UART0_INIT
                  010........  
 4457    00000028 ........              DC32    SEMIS
 4458                           
 4459                           
 4460                           
 4461                           //=============================== UART0_INIT =================================//
 4462                           
 4463                           //      UART0_LSR UART0_LSR: ( -- value ) of NXP M0 UART 0 Line Status Register
 4464                           //      11xx:
 4465                           //      0x40008014 Reset value - 0x60 0b1100000
 4466                           //      After Init SEEING 0x96 FIRST
 4467                           //
 4468                           //      BIT 0 = Receiver Data Ready
 4469                           //      BIT 0 WHEN 0 = U0RBR is empty
 4470                           //      BIT 0 WHEN 1 = U0RBR contains valid data.
 4471                           //
 4472                           //      BIT 4 = Break Interrupt BI when 1
 4473                           //
 4474                           //      BIT 5 = Transmitter Holding Register Empty
 4475                           //      BIT 5 WHEN 0 = U0THR contains valid data
 4476                           //      BIT 5 WHEN 1 = U0THR is empty.
 4477                           //
 4478                           //      BIT 6 = Transmitter Empty
 4479                           //      BIT 6 WHEN 0 = U0THR and/or the U0TSR contains valid data.
 4480                           //      BIT 6 WHEN 1 = U0THR and the U0TSR are empty.
 4481                           
 4482                           //      81x:
 4483                           //      UART0_STAT // 40064008h UART0 STAT Line Status Register 
 4484                           
 4485                            SECTION .text : CONST (2)
 4486                           UART0_LSR_NFA:
 4487    00000000 89                    DC8     0x89
 4488    00000001 55415254305F4         DC8     'UART0_LS'
                  C53          
 4489    00000009 D2                    DC8     'R'+0x80
 4490    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 4491    0000000C ........              DC32    MYBAUD_NFA
 4492                           UART0_LSR:
 4493    00000010 ........              DC32    .+5
 4494                            SECTION .text : CODE (2)
 4495                           #if     NXP_M0_11xx | NXP_M0_1115
 4496    00000000 0349                  LDR     n, = U0LSR
 4497                           #endif
 4498                           #ifdef NXP_M0_812
 4500                           #endif
 4501    00000002 0878                  LDRB    t, [n]
 4502                                   TPUSH
 4502                                   PUSHt   // push t to p, pre decrement p
 4502.1  00000004 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4502.2  00000006 3860                  STR     t, [p]
 4502.3                                 ENDM
 4502                                   NEXT
 4502.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4502                                   NEXT1
 4502.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4502.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4502.3                                 ENDM
 4502.4                                 ENDM
 4502.5                                 ENDM
 4503    0000000E 0000           LTORG
 4503.1                                  TABLE
 4503.2  00000010 14800040              Reference on line 4496
 4504                           
 4505                           
 4506                           //      UART0_RX UART0_RX: ( -- addr ) of UART 0 RX Buffer
 4507                           //      This is the serial terminal.
 4508                           
 4509                            SECTION .text : CONST (2)
 4510                           UART0_RX_NFA:
 4511    00000000 88                    DC8     0x88
 4512    00000001 55415254305F5         DC8     'UART0_R'
                  2            
 4513    00000008 D8                    DC8     'X'+0x80
 4514    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4515    0000000C ........              DC32    UART0_LSR_NFA
 4516                           UART0_RX:
 4517                           #if     NXP_M0_11xx | NXP_M0_1115
 4518    00000010 ........00800         DC32    DOCON, U0RBRTHR
                  040          
 4519                           #endif
 4520                           #ifdef NXP_M0_812
 4522                           #endif
 4523                           
 4524                           //      UART0_TX UART0_TX: ( -- addr ) of UART 0 TX Buffer
 4525                           //      This is the serial terminal.
 4526                           
 4527                            SECTION .text : CONST (2)
 4528                           UART0_TX_NFA:
 4529    00000000 88                    DC8     0x88
 4530    00000001 55415254305F5         DC8     'UART0_T'
                  4            
 4531    00000008 D8                    DC8     'X'+0x80
 4532    00000009 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4533    0000000C ........              DC32    UART0_RX_NFA
 4534                           UART0_TX:
 4535                           #if     NXP_M0_11xx | NXP_M0_1115
 4536    00000010 ........00800         DC32    DOCON, U0RBRTHR
                  040          
 4537                           #endif
 4538                           #ifdef NXP_M0_812
 4540                           #endif
 4541                           
 4542                           
 4543                           #ifdef XON_XOFF
 4544                           //      XOFF XOFF: ( -- ) Send XOFF
 4545                           
 4546                            SECTION .text : CONST (2)
 4547                           XOFF_NFA:
 4548    00000000 84                    DC8     0x84
 4549    00000001 584F46                DC8     'XOF'
 4550    00000004 C6                    DC8     'F'+0x80
 4551    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4552    00000008 ........              DC32    UART0_TX_NFA
 4553                           XOFF:
 4554    0000000C ........              DC32    .+5
 4555                            SECTION .text : CODE (2)       // Does not incr OUT and wait for line status
 4556                           #ifdef IO2TP
 4558                           #else
 4559    00000000 ........              BL      TXRDY_SUBR
 4560    00000004 ........              BL      XOFF_SUBR
 4561                                   NEXT
 4561.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4561                                   NEXT1
 4561.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4561.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4561.3                                 ENDM
 4561.4                                 ENDM
 4562                           #endif // #else IO2TP
 4563                           //#endif // XON_XOFF after XON:
 4564                           
 4565                           
 4566                           //      XON XON: ( -- ) Send XON
 4567                           
 4568                            SECTION .text : CONST (2)
 4569                           XON_NFA:
 4570    00000000 83                    DC8     0x83
 4571    00000001 584F                  DC8     'XO'
 4572    00000003 CE                    DC8     'N'+0x80
 4573                            ALIGNROM 2,0xFFFFFFFF
 4574    00000004 ........              DC32    XOFF_NFA
 4575                           XON:
 4576    00000008 ........              DC32    .+5
 4577                            SECTION .text : CODE (2)       // Does not incr OUT or wait for line status.
 4578                           #ifdef IO2TP
 4580                           #else
 4581                           // Required, no 'quick send'
 4582    00000000 ........              BL      TXRDY_SUBR
 4583    00000004 ........              BL      XON_SUBR
 4584                                   NEXT
 4584.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4584                                   NEXT1
 4584.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4584.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4584.3                                 ENDM
 4584.4                                 ENDM
 4585                           #endif // #else IO2TP
 4586                           #endif // XON_XOFF
 4587                           
 4588                           //---------------- EMIT KEY ?KEY CR SECTION ------------------------------
 4589                           
 4590                           //      SPACES SPACES:  ( n -- )
 4591                           //      Transmit n ascii blanks (0x20) to the output device.
 4592                           
 4593                            SECTION .text : CONST (2)
 4594                           SPACES_NFA:
 4595    00000000 86                    DC8     0x86
 4596    00000001 5350414345            DC8     'SPACE'
 4597    00000006 D3                    DC8     'S'+0x80
 4598    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 4599                           #ifdef XON_XOFF
 4600    00000008 ........              DC32    XON_NFA
 4601                           #else
 4603                           #endif
 4604                           SPACES:
 4605    0000000C ........              DC32    DOCOL
 4606    00000010 ........              DC32    ZERO
 4607    00000014 ........              DC32    MAX
 4608    00000018 ........              DC32    ZNDUP
 4609    0000001C ........              DC32    ZBRAN
 4610    00000020 18000000              DC32     SPACES_DONE-.
 4611                           
 4612    00000024 ........              DC32    ZERO
 4613    00000028 ........              DC32    XDO     //DO
 4614                           
 4615                           SPACES_DO:
 4616    0000002C ........              DC32    SPACE
 4617    00000030 ........              DC32    XLOOP   //LOOP
 4618    00000034 F8FFFFFF              DC32     SPACES_DO-.
 4619                           
 4620                           SPACES_DONE:
 4621    00000038 ........              DC32    SEMIS
 4622                           
 4623                           
 4624                           //      SPACE SPACE: ( -- )
 4625                           //      Emit a space character, 0x20.
 4626                           
 4627                            SECTION .text : CONST (2)
 4628                           SPACE_NFA:
 4629    00000000 85                    DC8     0x85
 4630    00000001 53504143              DC8     'SPAC'
 4631    00000005 C5                    DC8     'E'+0x80
 4632    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 4633    00000008 ........              DC32    SPACES_NFA
 4634                           SPACE:
 4635    0000000C ........              DC32    DOCOL
 4636    00000010 ........              DC32    BLANK
 4637    00000014 ........              DC32    EMIT
 4638    00000018 ........              DC32    SEMIS
 4639                           
 4640                           
 4641                           //      ID. IDDOT:      ( NFA-addr -- ) ?RENAME .NFA
 4642                           //      Print a definition's name from its name field address.
 4643                           
 4644                            SECTION .text : CONST (2)
 4645                           IDDOT_NFA:
 4646    00000000 83                    DC8     0x83
 4647    00000001 4944                  DC8     'ID'
 4648    00000003 AE                    DC8     '.'+0x80
 4649                            ALIGNROM 2,0xFFFFFFFF
 4650    00000004 ........              DC32    SPACE_NFA
 4651                           IDDOT:
 4652    00000008 ........              DC32    DOCOL
 4653                           //      NOW COUNT is on NFA, fig code copied it out to pad
 4654    0000000C ........              DC32    COUNT   // Count could be SMUDGE'd.
 4655    00000010 ........1F000         DC32    LIT, MAXWORDLEN // Strip SMUDGEing from count
                  000          
 4656    00000018 ........              DC32    ANDD            // only time 
 4657    0000001C ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4658    00000020 ........              DC32    SPACE
 4659    00000024 ........              DC32    SEMIS
 4660                           
 4661                           
 4662                           //      ." DOTQ:        ( -- ) IMMEDIATE
 4663                           //      Type quoted string out or compile inline string to be typed at runtime
 4664                           //      CHANGED COMPILE TIME ACTION TO WORK WITH 4 byte alighment REQUIREMENT.
 4665                           //      Used in the form:
 4666                           //              .' CCcc"
 4667                           //      Compiles an in-line string CCcc (delimited by the trailing ") with
 4668                           //      an execution proceedure to transmit the text to the output device.
 4669                           //      If executed outside a definition, ." will immediately print the text
 4670                           //      until the final ',. The maximum number of characters may be an
 4671                           //      installation dependent value. See (.").
 4672                           
 4673                            SECTION .text : CONST (2)
 4674                           DOTQ_NFA:
 4675    00000000 C2                    DC8     0x0C2
 4676    00000001 2E                    DC8     '.'
 4677    00000002 A2                    DC8     '"'+0x80
 4678    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4679    00000004 ........              DC32    IDDOT_NFA
 4680                           DOTQ:
 4681    00000008 ........              DC32    DOCOL
 4682    0000000C ........22000         DC32    LIT, '"'        // 0x22 ending qoute delimiter for WORD
                  000          
 4683    00000014 ........              DC32    STATE_SV
 4684    00000018 ........              DC32    AT
 4685    0000001C ........              DC32    ZBRAN   // IF Not COMPILING
 4686    00000020 2C000000              DC32     DOTQ1-.
 4687                           
 4688    00000024 ........              DC32    COMP    // COMPILING
 4689    00000028 ........              DC32    PDOTQ   // compile LIT, cnt-str-addr, count, type
 4690    0000002C ........              DC32    WORD   // ( cH-DELIM  --- )  CHCNT-STR OF TOKEN TO HERE
 4691    00000030 ........              DC32    HERE
 4692    00000034 ........              DC32    CAT
 4693    00000038 ........              DC32    ONEP
 4694    0000003C ........              DC32    ALIGNED
 4695    00000040 ........              DC32    ALLOT_PRIM
 4696    00000044 ........              DC32    BRAN    // ELSE
 4697    00000048 14000000              DC32     DOTQ2-.
 4698                           DOTQ1:
 4699    0000004C ........              DC32    WORD   // ( cH-DELIM  --- )  CHCNT-STR OF TOKEN TO HERE
 4700    00000050 ........              DC32    HERE
 4701    00000054 ........              DC32    COUNT
 4702    00000058 ........              DC32    TYPE    // TYPE needs actual count un SMUDGE'd
 4703                                                   // endif
 4704                           #ifdef IO2TP
 4707                           #endif
 4708                           DOTQ2:
 4709    0000005C ........              DC32    SEMIS
 4710                           
 4711                           
 4712                           //      TYPE TYPE:      ( addr count -- )
 4713                           //      ADDR must be ALIGNED!
 4714                           //      OUT MUST BE INITIALIZED!!
 4715                           //      EMIT COUNT OF 8-bits in a string, preferably ascii characters,
 4716                           //      (last nfa char (+80h)ok!) from addr thru count,
 4717                           
 4718                            SECTION .text : CONST (2)
 4719                           TYPE_NFA:
 4720    00000000 84                    DC8     0x84
 4721    00000001 545950                DC8     'TYP'
 4722    00000004 C5                    DC8     'E'+0x80
 4723    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4724    00000008 ........              DC32    DOTQ_NFA
 4725                           TYPE:
 4726    0000000C ........              DC32    DOCOL
 4727    00000010 ........              DC32    ZNDUP
 4728    00000014 ........              DC32    ZBRAN   // IF NOTHING TO TYPE
 4729    00000018 34000000              DC32     TYPE1-.
 4730                           
 4731                           #ifdef XON_XOFF
 4732    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 4733                           #endif
 4734    00000020 ........              DC32    OVER
 4735    00000024 ........              DC32    PLUS
 4736    00000028 ........              DC32    SWAP
 4737    0000002C ........              DC32    XDO     // DO
 4738                           TYPE2:
 4739    00000030 ........              DC32    I
 4740    00000034 ........              DC32    CATLT7F // Limit output to ASCII characters under 80h
 4741    00000038 ........              DC32    EMIT
 4742                           tt1:
 4743    0000003C ........              DC32    XLOOP   // LOOP
 4744                           tt2:
 4745    00000040 F0FFFFFF              DC32     TYPE2-.
 4746                           
 4747    00000044 ........              DC32    BRAN    // ELSE
 4748    00000048 08000000              DC32     TYPE3-.
 4749                           TYPE1:
 4750    0000004C ........              DC32    DROP    // endif
 4751                           TYPE3:
 4752    00000050 ........              DC32    SEMIS
 4753                           
 4754                           
 4755                           //      EMIT EMIT:      ( c -- )
 4756                           //      Transmit ascii character c to the selected output device. OUT is
 4757                           //      incremented for each character output.
 4758                           
 4759                            SECTION .text : CONST (2)
 4760                           EMIT_NFA:
 4761    00000000 84                    DC8     0x84
 4762    00000001 454D49                DC8     'EMI'
 4763    00000004 D4                    DC8     'T'+0x80
 4764    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4765    00000008 ........              DC32    TYPE_NFA
 4766                           EMIT:
 4767                           //------------------------------------------------------------------------------
 4768                           #ifndef IO2TP
 4769                           // NOT IO2TP SECTION:
 4770    0000000C ........              DC32    .+5
 4771                            SECTION .text : CODE (2)
 4772                                   POP2t                   // GET CHAR
 4772.1                         #ifndef TOSCT
 4772.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
 4772.3                         #endif
 4772.4  00000002 3F1D                  ADDS    p, p, #4
 4772.5                                 ENDM
 4773    00000004 ........              BL      TXRDY_SUBR
 4774                           #if     NXP_M0_11xx | NXP_M0_1115
 4775    00000008 0449                  LDR     n, = U0THR      // TXD
 4776                           #endif
 4777                           #ifdef NXP_M0_812
 4779                           #endif
 4780                           // BSOUT handles negative OUT issue
 4781    0000000A 0870                  STRB    t, [n]          // EMIT (Send) Char
 4782    0000000C 0449                  LDR     n, = OUT        // Increment Out
 4783    0000000E 0868                  LDR     t, [n]
 4784    00000010 401C                  ADDS    t, t, #1
 4785    00000012 0860                  STR     t, [n]
 4786                                   NEXT
 4786.1  00000014 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4786                                   NEXT1
 4786.1  00000016 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4786.2  00000018 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4786.3                                 ENDM
 4786.4                                 ENDM
 4787                           #else // if IO2TP Transmit char to PAD, increment OUT
 4803                           #endif  // else IO2TP
 4804    0000001A 0000           LTORG
 4804.1                                  TABLE
 4804.2  0000001C 00800040              Reference on line 4775
 4804.3  00000020 ........              Reference on line 4782
 4805                           
 4806                           
 4807                           //      KEY KEY:        (  -- ch )
 4808                           
 4809                            SECTION .text : CONST (2)
 4810                           KEY_NFA:
 4811    00000000 83                    DC8     0x83
 4812    00000001 4B45                  DC8     'KE'
 4813    00000003 D9                    DC8     'Y'+0x80
 4814                            ALIGNROM 2,0xFFFFFFFF
 4815    00000004 ........              DC32    EMIT_NFA
 4816                           KEY_INTERPRETED_ENTRY:
 4817                           #ifndef IO2TP
 4818    00000008 ........              DC32    DOCOL
 4819                           #ifdef XON_XOFF
 4820                           // EXEC SETS XOFF SO UNDO IT
 4821    0000000C ........              DC32    XON     // USER called or compiled only!
 4822                           // TEST XON_XOFF TEMINAL COMPLIANCE WITH KEY .S <CR> Send Break to bypass!
 4823                           //        DC32    XOFF
 4824                           #endif
 4825    00000010 ........              DC32    KEY
 4826    00000014 ........              DC32    SEMIS
 4827                           #else
 4829                           #endif
 4830                           
 4831                           //:NONAME KEY KEY:      ( -- CH ) 
 4832                           // This is the FISH System KEY compiled in the FISH RM
 4833                           // KEY_INTERPRETED_ENTRY is the user interpreted/compiled hi-level version
 4834                           // That issues XON  before calling this KEY
 4835                           KEY:
 4836                           #ifndef IO2TP
 4837    00000018 ........              DC32    .+5
 4838                            SECTION .text : CODE (2)
 4839                           #if     NXP_M0_11xx | NXP_M0_1115
 4840    00000000 054A                  LDR     w, = U0RBR      // RXD
 4841    00000002 064B                  LDR     x, = U0LSR      // Line Status Register
 4842                           #endif
 4843                           #ifdef NXP_M0_812
 4846                           #endif
 4847                           // UART0_STAT / UART0_LSR : BIT 0 = RXRDY FLAG
 4848                           // A BREAK CONDITION (FROM SINGLE STEPPING) WILL SHOW AS 30h in THE LSR
 4849                           // WHEN A TERMINAL SENDS A BREAK THE CARRY IS MAGICALLY SET!
 4850                           // AND THE KEY RECIEVED IS NULL SO NULL IS EXECUTED WITHOUT A CR!
 4851                           rxRDY?:
 4852    00000004 1968                  LDR     n, [x]          // Get Line Status
 4853    00000006 4908                  LSRS    n, n, #1        // Char available
 4854    00000008 FCD3                  BCC     rxRDY?          // sets carry flag
 4855                           
 4856    0000000A 1068                  LDR     t, [w]
 4857                                   TPUSH
 4857                                   PUSHt   // push t to p, pre decrement p
 4857.1  0000000C 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4857.2  0000000E 3860                  STR     t, [p]
 4857.3                                 ENDM
 4857                                   NEXT
 4857.1  00000010 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4857                                   NEXT1
 4857.1  00000012 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4857.2  00000014 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4857.3                                 ENDM
 4857.4                                 ENDM
 4857.5                                 ENDM
 4858                           #else
 4861                           #endif  // else IO2TP
 4862    00000016 0000           LTORG
 4862.1                                  TABLE
 4862.2  00000018 00800040              Reference on line 4840
 4862.3  0000001C 14800040              Reference on line 4841
 4863                           
 4864                           
 4865                           //      ?KEY QKEY: ( -- f )
 4866                           //      Return zero unless key in fifo - key is not consumed.
 4867                           //      : TB BEGIN ?BREAK UNTIL ; Will execute until any key is entered.
 4868                           
 4869                            SECTION .text : CONST (2)
 4870                           QKEY_NFA:
 4871    00000000 84                    DC8     0x84
 4872    00000001 3F4B45                DC8     '?KE'
 4873    00000004 D9                    DC8     'Y'+0x80
 4874    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4875    00000008 ........              DC32    KEY_NFA // -1
 4876                           QKEY:
 4877    0000000C ........              DC32    .+5
 4878                            SECTION .text : CODE (2)
 4879                           #ifndef IO2TP
 4880                           #ifdef XON_XOFF // XON in QKEY
 4881    00000000 ........              BL      TXRDY_SUBR
 4882    00000004 ........              BL      XON_SUBR
 4883                           #endif
 4884                           #if     NXP_M0_11xx | NXP_M0_1115
 4885    00000008 084B                  LDR     x, = U0LSR      // Line Status Register
 4886                           #endif
 4887                           #ifdef NXP_M0_812
 4889                           #endif
 4890    0000000A 1968                  LDR     n, [x]          // Get Line Status
 4891                           // UART0_STAT / UART0_LSR : BIT 0 = RXRDY FLAG
 4892    0000000C 4908                  LSRS    n, n, #1        // Char available
 4893    0000000E 06D3                  BCC     NO_KEY          // No char, not Ready
 4894                           
 4895                           // HAVE A KEY - DON'T CONSUME IT
 4896                           #ifdef TRUE_EQU_NEG_ONE
 4897    00000010 4040                  EORS    t, t    // zero t
 4898    00000012 0138                  SUBS    t, #1   // -1
 4899                           #else
 4901                           #endif
 4902                                   TPUSH
 4902                                   PUSHt   // push t to p, pre decrement p
 4902.1  00000014 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4902.2  00000016 3860                  STR     t, [p]
 4902.3                                 ENDM
 4902                                   NEXT
 4902.1  00000018 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4902                                   NEXT1
 4902.1  0000001A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4902.2  0000001C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4902.3                                 ENDM
 4902.4                                 ENDM
 4902.5                                 ENDM
 4903                           
 4904                           #endif  // DEFAULT TO NO KEY IF IO2TP
 4905                           NO_KEY:
 4906    0000001E 4040                  EORS    t, t    // zero t
 4907                                   TPUSH
 4907                                   PUSHt   // push t to p, pre decrement p
 4907.1  00000020 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 4907.2  00000022 3860                  STR     t, [p]
 4907.3                                 ENDM
 4907                                   NEXT
 4907.1  00000024 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4907                                   NEXT1
 4907.1  00000026 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4907.2  00000028 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4907.3                                 ENDM
 4907.4                                 ENDM
 4907.5                                 ENDM
 4908    0000002A 0000           LTORG
 4908.1                                  TABLE
 4908.2  0000002C 14800040              Reference on line 4885
 4909                           
 4910                           
 4911                           //      CRS CRS:        ( n -- )
 4912                           //      Emit n cr'S (0x0d) and lf (0x0A)
 4913                           
 4914                            SECTION .text : CONST (2)
 4915                           CRS_NFA:
 4916    00000000 83                    DC8     0x83
 4917    00000001 4352                  DC8     'CR'
 4918    00000003 D3                    DC8     'S'+0x80
 4919                            ALIGNROM 2,0xFFFFFFFF
 4920    00000004 ........              DC32    QKEY_NFA
 4921                           CRS:
 4922    00000008 ........              DC32    DOCOL
 4923    0000000C ........              DC32    ZERO
 4924    00000010 ........              DC32    XDO
 4925                           CRS_BEGIN:
 4926    00000014 ........              DC32    CR
 4927    00000018 ........              DC32    XLOOP
 4928    0000001C F8FFFFFF              DC32     CRS_BEGIN-.
 4929    00000020 ........              DC32    SEMIS
 4930                           
 4931                           
 4932                           //      CR CR:  ( -- )
 4933                           //      Emit cr (0x0d) and lf (0x0A)
 4934                           
 4935                            SECTION .text : CONST (2)
 4936                           CR_NFA:
 4937    00000000 82                    DC8     0x82
 4938    00000001 43                    DC8     'C'
 4939    00000002 D2                    DC8     'R'+0x80
 4940    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 4941    00000004 ........              DC32    CRS_NFA
 4942                           CR:
 4943                           #ifdef IO2TP
 4946                           #else
 4947    00000008 ........              DC32    DOCOL
 4948    0000000C ........00000         DC32    STRVA, 0, OUT
                  000........  
 4949    00000018 ........              DC32    PDOTQ
 4950    0000001C 02                    DC8     2
 4951    0000001D 0D0A                  DC8     0x0D, 0x0A
 4952    0000001F FF             ALIGNROM 2,0xFFFFFFFF
 4953    00000020 ........              DC32    SEMIS
 4954                           #endif
 4955                           
 4956                           
 4957                           //=============================== WORDCAT ====================================//
 4958                           //NOEXEC HEADERFORWORDCATEGORIES
 4959                           //!!!!!fixx in nxp
 4960                           //      WC_FISH_IO_NFA = FISH IO: CATEGORY
 4961                           
 4962                            SECTION .text : CONST (2)
 4963                           WC_UARTx_NFA:
 4964    00000000 8D                    DC8     0x80+4+9
 4965    00000001 0D0A                  DC8     0x0D, 0x0A
 4966    00000003 4649534820494         DC8     'FISH IO:'
                  F3A          
 4967    0000000B 0D8A                  DC8     0x0D, 0x0A+0x80
 4968    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4969    00000010 ........              DC32    CR_NFA
 4970                           
 4971                           
 4972                           //      CMSIS_ENABLE_IRQS IRQS_RESUME:  ( -- )
 4973                            SECTION .text : CONST (2)
 4974                           IRQS_RESUME_NFA:
 4975    00000000 8B                    DC8     0x8B
 4976    00000001 495251535F524         DC8     'IRQS_RESUM'
                  553554D      
 4977    0000000B C5                    DC8     'E'+0x80
 4978                            ALIGNROM 2,0xFFFFFFFF
 4979    0000000C ........              DC32    WC_UARTx_NFA
 4980                           CMSIS_ENABLE_IRQS:
 4981    00000010 ........              DC32 .+5
 4982                            SECTION .text : CODE (2)
 4983                            ALIGNROM 2,0xFFFFFFFF
 4984                            IMPORT C_CMSIS_ENABLE_IRQS
 4985    00000000 ........              BL      C_CMSIS_ENABLE_IRQS
 4986                                   NEXT
 4986.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 4986                                   NEXT1
 4986.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 4986.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 4986.3                                 ENDM
 4986.4                                 ENDM
 4987                           
 4988                           //      CMSIS_DISABLE_IRQS IRQS_SUSPEND:        ( -- )
 4989                            SECTION .text : CONST (2)
 4990                           IRQS_SUSPEND_NFA:
 4991    00000000 8C                    DC8     0x8C
 4992    00000001 495251535F535         DC8     'IRQS_SUSPEN'
                  55350454E    
 4993    0000000C C4                    DC8     'D'+0x80
 4994    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
 4995    00000010 ........              DC32    IRQS_RESUME_NFA
 4996                           CMSIS_DISABLE_IRQS:
 4997    00000014 ........              DC32 .+5
 4998                            SECTION .text : CODE (2)
 4999                            ALIGNROM 2,0xFFFFFFFF
 5000                            IMPORT C_CMSIS_DISABLE_IRQS
 5001    00000000 ........              BL      C_CMSIS_DISABLE_IRQS
 5002                                   NEXT
 5002.1  00000004 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 5002                                   NEXT1
 5002.1  00000006 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5002.2  00000008 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5002.3                                 ENDM
 5002.4                                 ENDM
 5003                           
 5004                           
 5005                           //      SYSTICK_IRQ_OFF SYSTICK_IRQ_OFF:        ( -- )
 5006                           //      Turn SYSTICK interrupt off.
 5007                           //      STCTR only incremented when SYSTICK interrupt is on.
 5008                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5009                            SECTION .text : CONST (2)
 5010                           SYSTICK_IRQ_OFF_NFA:
 5011    00000000 8F                    DC8     0x8F
 5012    00000001 5359535449434         DC8     'SYSTICK_IRQ_OF'
                  B5F4952515F4F
                  46           
 5013    0000000F C6                    DC8     'F'+0x80
 5014                            ALIGNROM 2,0xFFFFFFFF
 5015    00000010 ........              DC32    IRQS_SUSPEND_NFA
 5016                           //        DC32    WC_UARTx_NFA
 5017                           SYSTICK_IRQ_OFF:
 5018    00000014 ........              DC32    .+5
 5019                            SECTION .text : CODE (2)
 5020    00000000 0249                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 5021    00000002 0520                  MOVS    t, #5
 5022    00000004 0860                  STR     t, [n]
 5023                                   NEXT
 5023.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 5023                                   NEXT1
 5023.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5023.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5023.3                                 ENDM
 5023.4                                 ENDM
 5024                           // LTORG         //Always outside of code, else data in words
 5025                           
 5026                           
 5027                           //      SYSTICK_IRQ_ON SYSTICK_IRQ_ON:  ( -- )
 5028                           //      Turn SYSTICK interrupt on.
 5029                           //      STCTR only incremented when SYSTICK interrupt is on.
 5030                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5030.1                                  TABLE
 5030.2  0000000C 10E000E0              Reference on line 5020
 5031                            SECTION .text : CONST (2)
 5032                           SYSTICK_IRQ_ON_NFA:
 5033    00000000 8E                    DC8     0x8E
 5034    00000001 5359535449434         DC8     'SYSTICK_IRQ_O'
                  B5F4952515F4F
 5035    0000000E CE                    DC8     'N'+0x80
 5036    0000000F FF             ALIGNROM 2,0xFFFFFFFF
 5037    00000010 ........              DC32    SYSTICK_IRQ_OFF_NFA
 5038                           SYSTICK_IRQ_ON:
 5039    00000014 ........              DC32    .+5
 5040                            SECTION .text : CODE (2)
 5041    00000000 0249                  LDR     n, = SYST_CSR   // SYSTICK Control and Status Register
 5042    00000002 0720                  MOVS    t, #7
 5043    00000004 0860                  STR     t, [n]
 5044                                   NEXT
 5044.1  00000006 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 5044                                   NEXT1
 5044.1  00000008 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5044.2  0000000A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5044.3                                 ENDM
 5044.4                                 ENDM
 5045                            LTORG   //Always outside of code, else data in words
 5045.1                                  TABLE
 5045.2  0000000C 10E000E0              Reference on line 5041
 5046                           
 5047                           //=============================== WORDCAT ====================================//
 5048                           //NOEXEC HEADERFORWORDCATEGORIES
 5049                           //      WC_IRQ_NFA = INTERRUPTS: CATEGORY
 5050                           
 5051                            SECTION .text : CONST (2)
 5052                           WC_IRQ_NFA:
 5053    00000000 8F                    DC8     0x80+4+11
 5054    00000001 0D0A                  DC8     0x0D, 0x0A
 5055    00000003 494E544552525         DC8     'INTERRUPTS:'
                  55054533A    
 5056    0000000E 0D8A                  DC8     0x0D, 0x0A+0x80
 5057                            ALIGNROM 2,0xFFFFFFFF
 5058    00000010 ........              DC32    SYSTICK_IRQ_ON_NFA
 5059                           //------------------------------------------------------------------------------
 5060                           $FISH_NXP_M0_FLASH.s       // FLASH_SAVE and FLASH_FORGET Words
    1                           // FISH_NXP_FLASH.s
    2                           // FLASH_SAVE, FLASH_FORGET, FLASH_SCAN and support :NONAME's 
    3                           
    4                           //      FLASH_SAVE FLASH_SAVE:  ( -- ) Save RAM to Flash
    5                           
    6                            SECTION .text : CONST (2)
    7                           FLASH_SAVE_NFA:
    8    00000000 8A                    DC8     0x80+10
    9    00000001 464C4153485F5         DC8     'FLASH_SAV'
                  34156        
   10    0000000A C5                    DC8     'E'+0x80
   11    0000000B FF             ALIGNROM 2,0xFFFFFFFF
   12                           //#ifdef SRM
   13                           //      DC32    WC_UARTx_NFA
   14                           //#else
   15    0000000C ........              DC32    WC_IRQ_NFA
   16                           //#endif
   17                           FLASH_SAVE:
   18    00000010 ........              DC32    DOCOL   // LAST FPA WILL BE LESS THAN FPC
   19                           // SOMETHING TO SAVE TEST - IF LATEST IS NOT IN ROM
   20    00000014 .............         DC32    LATEST, DBASE, LESSTHAN
                  ...........  
   21    00000020 ........              DC32    ZBRAN
   22    00000024 20000000              DC32     FLPT-.
   23                           
   24    00000028 ........              DC32    CR
   25    0000002C ........              DC32    PDOTQ
   26    00000030 0F                    DC8     15D
   27    00000031 4E4F5448494E4         DC8     'NOTHING TO SAVE'
                  720544F205341
                  5645         
   28                            ALIGNROM 2,0xFFFFFFFF
   29    00000040 ........              DC32    SEMIS
   30                           
   31                           // SAVE PAGE IF 
   32                           FLPT:
   33                           // LAST PAGE USED TEST - PPAGE = PAST PAGE
   34    00000044 .............         DC32    FPADDR, AT
                  ...          
   35    0000004C ........00800         DC32    LIT, FLASH_PPAGE
                  000          
   36    00000054 ........              DC32    EQUAL
   37                           // DC32 NOOP
   38    00000058 ........              DC32    ZBRAN           // then save it
   39    0000005C 28000000              DC32     FSAVE-.
   40                                   
   41                           FSLASTPAGE:
   42    00000060 ........              DC32    CR
   43    00000064 ........              DC32    PDOTQ
   44    00000068 14                    DC8     20D
   45    00000069 4C41535420464         DC8     'LAST FLASH PAGE USED'
                  C415348205041
                  4745205553454
                  4            
   46    0000007D FFFFFF         ALIGNROM 2,0xFFFFFFFF
   47    00000080 ........              DC32    SEMIS
   48                           
   49                           // Setup for saving - Assumes no error in relocation
   50                           // Based on relocating UP and Latest to FPVAR and FPCURR
   51                           FSAVE:
   52                           // Stop Downloads
   53    00000084 ........              DC32    XON
   54                           // FPA SHOULD BE SET BY FLASH_SCAN IN WARM OR BY FISH OR FISH_ONLY
   55                           // FPCURR AND FPVAR SAVE
   56    00000088 .............         DC32    UP_SV, AT, FPVAR, STORE
                  .............
                  ......       
   57    00000098 .............         DC32    LATEST, TOFA, FPCURR, STORE
                  .............
                  ......       
   58                           
   59                           // KEEP RELOCATING ONE WORD AT A TIME UNTIL RECHING FIRST WORD (DBASE)
   60                           FS_BEGIN:
   61    000000A8 .............         DC32    LATEST, DBASE, EQUAL
                  ...........  
   62    000000B4 ........              DC32    ZBRAN
   63    000000B8 5C000000              DC32     FS_RWORD-.
   64                           
   65                           // AFTER LAST WORD RELOCATED
   66                           FS_WRITE:
   67    000000BC ........              DC32    FLASHWRITE                      // Write page
   68    000000C0 .............         DC32    DBASE, DP_SV, STORE             // Reset DP
                  ...........  
   69    000000CC .............         DC32    FPVAR, AT, UP_SV, STORE         // and UP
                  .............
                  ......       
   70    000000DC .............         DC32    FPCURR, AT, CURRENT_SV, STORE   // and CURRENT to nothing in RAM
                  .............
                  ......       
   71                           
   72                           // UPDATE FPADDR - WILL BE FLASH_PPAGE WHEN ALL PAGES USED
   73    000000EC ........00100         DC32    LIT, FLASH_WR_SIZE, FPADDR, PSTORE
                  000..........
                  ......       
   74                           
   75                           // FLASH_SAVE Finish
   76                           FS_EXIT:
   77    000000FC ........              DC32    FLASH_SCAN      // Show Save done via Flash Page status
   78                           #ifndef SRM
   79    00000100 .............         DC32    CR, DOTVARSPACE, DOTDICTSPACE
                  ...........  
   80                           #endif
   81    0000010C ........              DC32    XON
   82    00000110 ........              DC32    SEMIS
   83                           
   84                           FS_RWORD:
   85    00000114 .............         DC32    LATEST, RWORD   // Relocate this word, unlink it
                  ...          
   86    0000011C ........              DC32    BRAN            // Repeat until LATEST = DBASE
   87    00000120 88FFFFFF              DC32     FS_BEGIN-.
   88                           
   89                           
   90                           //:NONAME       FPADDR: ( -- addr ) Flash Page Addreess to operate on.
   91                            SECTION .text : CONST (2)
   92                           FPADDR:
   93    00000000 .............         DC32    DOCON, FPA
                  ...          
   94                           
   95                           
   96                           //:NONAME       FPCURR: ( -- addr ) Flash Page CURRENT is NFA of last word saved in Flash.
   97                            SECTION .text : CONST (2)
   98                           FPCURR:
   99    00000000 .............         DC32    DOCON, FPC
                  ...          
  100                           
  101                           
  102                           //:NONAME       FPVAR:  ( -- addr ) Flash Page VAR is UP value when Flash page saved.
  103                            SECTION .text : CONST (2)
  104                           FPVAR:
  105    00000000 .............         DC32    DOCON, FPSV
                  ...          
  106                           
  107                           //:NONAME >FA >FA:      ( addr -- raddr ) Relocate address relative to FPADDR.
  108                           //      Convert address to raddr using FPADDR, which must be initialized.
  109                            SECTION .text : CONST (2)
  110                           TOFA:
  111    00000000 ........              DC32    .+5
  112                            SECTION .text : CODE (2)
  113                                   POP2t
  113.1                         #ifndef TOSCT
  113.2  00000000 3868                  LDR     t, [p]          // pop tos to t, post increment p
  113.3                         #endif
  113.4  00000002 3F1D                  ADDS    p, p, #4
  113.5                                 ENDM
  114    00000004 044A                  LDR     w, = 0x0FFF
  115    00000006 1040                  ANDS    t, t, w
  116    00000008 044A                  LDR     w, = FPA
  117    0000000A 1268                  LDR     w, [w]
  118    0000000C 8018                  ADDS    t, t, w 
  119                                   TPUSH
  119                                   PUSHt   // push t to p, pre decrement p
  119.1  0000000E 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
  119.2  00000010 3860                  STR     t, [p]
  119.3                                 ENDM
  119                                   NEXT
  119.1  00000012 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  119                                   NEXT1
  119.1  00000014 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  119.2  00000016 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  119.3                                 ENDM
  119.4                                 ENDM
  119.5                                 ENDM
  120                            LTORG   //Always outside of code, else data in words
  120.1                                  TABLE
  120.2  00000018 FF0F0000              Reference on line 114
  120.3  0000001C ........              Reference on line 116
  121                           
  122                           
  123                           //:NONAME RWORD:        ( nfa -- ) Relocate this word relative to FPADDR
  124                           //      Relocate word specified by it's NFA to FPADDR relative addresses
  125                           //      Handle case of CON/VAR, CREATE_DOES_GOTO, PDOTQ and LIT by not relocating them.
  126                           //      RLIT's WILL BE RELOCATED - LIT's WILL NOT.
  127                            SECTION .text : CONST (2)
  128                           RWORD:
  129    00000000 ........              DC32    DOCOL
  130    00000004 .............         DC32    PFA, DUP, TOR   // SAVE FOR RELOCATING LFA
                  ...........  
  131    00000010 ........              DC32    CFA             // REAL CFA OF THSI WORD
  132                           
  133                           CFA_CREATE_DOES_GOTO:
  134    00000014 .............         DC32    DUP, AT
                  ...          
  135    0000001C .............         DC32    LIT, CREATE_DOES_GOTO
                  ...          
  136    00000024 ........              DC32    EQUAL
  137    00000028 ........              DC32    ZBRAN           // IF NOT CREATE_DOES_GOTO
  138    0000002C 28000000              DC32     RW_DOCONVAR-.  // PROCESS WORD UNTIL SEMIS
  139                           
  140    00000030 .............         DC32    FOURP, DUP, DUP // INCR TO ADDR
                  ...........  
  141    0000003C .............         DC32    AT, TOFA        // TO RELOCATE
                  ...          
  142    00000044 .............         DC32    SWAP, STORE     // AND 
                  ...          
  143    0000004C ........              DC32    BRAN            // THEN
  144    00000050 00010000              DC32     RW_UNTIL-.     // DONE SO GO FIX LFA
  145                           
  146                           RW_DOCONVAR:
  147                           // CHECK FOR DOCON AND DOVAR
  148    00000054 .............         DC32    DUP, AT
                  ...          
  149    0000005C .............         DC32    LIT, DOCON
                  ...          
  150    00000064 ........              DC32    EQUAL
  151                           
  152    00000068 .............         DC32    OVER, AT        // COPY CFA AGAIN
                  ...          
  153    00000070 .............         DC32    LIT, DOVAR
                  ...          
  154    00000078 ........              DC32    EQUAL
  155                                   
  156    0000007C ........              DC32    OR              // DOCON OR DOVAR
  157    00000080 ........              DC32    ZBRAN           // IF NOT DOCON OR DOVAR
  158    00000084 10000000              DC32     RW_BEGIN-.     // PROCESS WORD UNTIL SEMIS
  159                           // IS DOCON OR DOVAR
  160    00000088 ........              DC32    DROP            // CFA
  161    0000008C ........              DC32    BRAN
  162    00000090 C4000000              DC32     RW_LFA-.       // THIS WORD DONE - FIX LFA
  163                           
  164                           // CFA -- BECOMES EACH WORD IN BODY OF THIS DEFINITION
  165                           RW_BEGIN:
  166    00000094 .............         DC32    FOURP, DUP, AT  // Next WORD in body to evaluate
                  ...........  
  167                           // RLIT's WILL BE RELOCATED - LIT's WILL NOT
  168                           CFA_LIT:
  169    000000A0 .............         DC32    LIT, LIT, EQUAL
                  ...........  
  170    000000AC ........              DC32    ZBRAN           // IF NOT LITERAL
  171    000000B0 10000000              DC32     CFA_PDOTQ-.    // CHECK FOR PDOTQ
  172                           // IS LITERAL SO SKIP TO NEXT WORD IN THIS DEFINITION
  173    000000B4 ........              DC32    FOURP           
  174    000000B8 ........              DC32    BRAN
  175    000000BC D8FFFFFF              DC32     RW_BEGIN-.
  176                           
  177                           CFA_PDOTQ:
  178    000000C0 .............         DC32    DUP, AT
                  ...          
  179    000000C8 .............         DC32    LIT, PDOTQ, EQUAL
                  ...........  
  180    000000D4 ........              DC32    ZBRAN           // IF NOT PDOTQ
  181    000000D8 20000000              DC32     CFA_SEMIS-.    // LOOK FOR SEMIS
  182                           // PDOTQ SO BYPASS TEXT AND LOOK FOR NEXT WORD IN THIS DEFINITION
  183    000000DC .............         DC32    DUP, FOURP, CAT
                  ...........  
  184    000000E8 ........              DC32    PLUS
  185    000000EC ........              DC32    ALIGNED
  186    000000F0 ........              DC32    BRAN
  187    000000F4 A0FFFFFF              DC32     RW_BEGIN-.
  188                           
  189                           CFA_SEMIS:
  190    000000F8 .............         DC32    DUP, AT         // USE THIS AS UNTIL FLAG TO FINISH
                  ...          
  191    00000100 .............         DC32    LIT, SEMIS, EQUAL
                  ...........  
  192    0000010C .............         DC32    ZEQU, ZBRAN     // IF AT SEMIS
                  ...          
  193    00000114 3C000000              DC32     RW_UNTIL-.     // DONE SO GO FIX LFA
  194                           
  195                           RELOC_THIS_WORD:
  196                           // NOT AT SEMIS - IS THIS A ADDRESS TO RELOCATE?
  197    00000118 .............         DC32    DUP, AT         // IF THIS IS NOT IN RAM
                  ...          
  198    00000120 .............         DC32    DBASE, GREATERTHAN
                  ...          
  199    00000128 ........              DC32    ZBRAN           // THEN CHECK NEXT WORD IN THIS DEFINITION
  200    0000012C 68FFFFFF              DC32     RW_BEGIN-.
  201                           // THIS IS A RAM ADDRESS THAT NEEDS TO BE RELOCATED TO A FLASH ADDRESS
  202    00000130 .............         DC32    DUP, DUP, AT    // PICKUP RAM ADDRESS
                  ...........  
  203    0000013C ........              DC32    TOFA            // RELOCATE THIS ADDRESS TO A FLASH ADDRESS
  204    00000140 .............         DC32    SWAP, STORE     // PUT IT BACK
                  ...          
  205    00000148 ........              DC32    BRAN
  206    0000014C 48FFFFFF              DC32     RW_BEGIN-.     // THEN CHECK NEXT WORD IN THIS DEFINITION
  207                           
  208                           RW_UNTIL:
  209                           // ADDRESS OF SEMI OR LAST WORD IN THIS DEFINITION
  210    00000150 ........              DC32    DROP            // COME FROM SEMIS MATCH
  211                           RW_LFA: // RELOCATE LFA AND SET CURRENT/LATEST TO Next WORD
  212    00000154 ........              DC32    RFROM           // PFA OF THIS DEFINITION
  213    00000158 .............         DC32    LFA, DUP, AT    // GET IT'S LFA
                  ...........  
  214    00000164 ........              DC32    DUP             // AND STORE TO CURRENT AND THIS DEF'S LFA
  215    00000168 .............         DC32    CURRENT_SV, STORE
                  ...          
  216    00000170 .............         DC32    TOFA, SWAP, STORE
                  ...........  
  217    0000017C ........              DC32    SEMIS
  218                           
  219                           
  220                           //:NONAME FLASHPREP:    ( -- ) Prepare FPADDR Flash page for writing
  221                           //      PREPARE SECTORS FOR WRITE OPERATION USING FPADDR
  222                            SECTION .text : CONST (2)
  223                           FLASHPREP:
  224    00000000 ........              DC32 .+5
  225                            SECTION .text : CODE (2)
  226                           #ifdef TOSCT
  228                           #endif
  229    00000000 0648                  LDR     t, = FLASHCMD           // t and n DO NOT SURVIVE FLASHCALL
  230    00000002 0749                  LDR     n, = FLASHRET
  231    00000004 3222                  LDR     w, = 50                 // Prepare sector to write
  232    00000006 0260                  STR     w, [t]
  233    00000008 064B                  LDR     x, = FPA                // DERIVE SECTOR
  234    0000000A 1A68                  LDR     w, [x]                  // FROM PAGE ADDR
  235                           #if NXP_M0_032kFlash_4KWrite | NXP_M0_064kFlash_4KWrite
  236    0000000C 120B                  LSRS    w, w, #12       // BY SHIFTING RIGHT BY 12
  237                           #endif
  238                           #ifdef NXP_M0_016kFlash_1KWrite
  240                           #endif
  241    0000000E 4260                  STR     w, [t,#4]
  242    00000010 8260                  STR     w, [t,#8]
  243    00000012 054B                  LDR     x, = IAPCALL
  244    00000014 9847                  BLX     x
  245                           #ifdef TOSCT
  247                           #endif
  248                                   NEXT    // FLASHPREP
  248.1  00000016 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  248                                   NEXT1
  248.1  00000018 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  248.2  0000001A 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  248.3                                 ENDM
  248.4                                 ENDM
  249                            LTORG   //Always outside of code, else data in words
  249.1                                  TABLE
  249.2  0000001C ........              Reference on line 229
  249.3  00000020 ........              Reference on line 230
  249.4  00000024 ........              Reference on line 233
  249.5  00000028 F11FFF1F              Reference on line 243
  250                           
  251                           
  252                           //:NONAME FLASHESEC:    ( -- ) Erase Flash sectors using FPADDR - flashprep 1rst!
  253                           //      MUST USE FLASHPREP FIRST.
  254                            SECTION .text : CONST (2)
  255                           FLASHESEC:
  256    00000000 ........              DC32 .+5
  257                            SECTION .text : CODE (2)
  258                           #ifdef TOSCT
  260                           #endif
  261    00000000 0748                  LDR     t, = FLASHCMD   // t and n DO NOT SURVIVE FLASHCALL
  262    00000002 0849                  LDR     n, = FLASHRET
  263    00000004 3422                  LDR     w, = 52         // Prepare sector to write
  264    00000006 0260                  STR     w, [t]
  265    00000008 074B                  LDR     x, = FPA        // DERIVE SECTOR
  266    0000000A 1A68                  LDR     w, [x]          // FROM PAGE ADDR
  267                           #if NXP_M0_032kFlash_4KWrite | NXP_M0_064kFlash_4KWrite
  268    0000000C 120B                  LSRS    w, w, #12       // BY SHIFTING RIGHT BY 12
  269                           #endif
  270                           #ifdef NXP_M0_016kFlash_1KWrite
  272                           #endif
  273    0000000E 4260                  STR     w, [t,#4]
  274    00000010 8260                  STR     w, [t,#8]
  275    00000012 064A                  LDR     w, = (SYSTEMCLOCK / 1000)       // in Khz
  276    00000014 C260                  STR     w, [t,#12]
  277    00000016 064B                  LDR     x, = IAPCALL
  278    00000018 9847                  BLX     x
  279                           #ifdef TOSCT
  281                           #endif
  282                                   NEXT    // FLASHESEC
  282.1  0000001A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  282                                   NEXT1
  282.1  0000001C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  282.2  0000001E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  282.3                                 ENDM
  282.4                                 ENDM
  283                            LTORG   //Always outside of code, else data in words
  283.1                                  TABLE
  283.2  00000020 ........              Reference on line 261
  283.3  00000024 ........              Reference on line 262
  283.4  00000028 ........              Reference on line 265
  283.5  0000002C 80BB0000              Reference on line 275
  283.6  00000030 F11FFF1F              Reference on line 277
  284                           
  285                           
  286                           //:NONAME FLASHCRTF:    ( -- ) Copy Ram to Flash using FPADDR
  287                           //      FLASH COPY RAM TO FLASH COMMAND USING FPADDR and FLASH_WR_SIZE
  288                            SECTION .text : CONST (2)
  289                           FLASHCRTF:
  290    00000000 ........              DC32 .+5
  291                            SECTION .text : CODE (2)
  292                           #ifdef TOSCT
  294                           #endif
  295    00000000 0848                  LDR     t, = FLASHCMD
  296    00000002 0949                  LDR     n, = FLASHRET
  297    00000004 3322                  LDR     w, = 51         // Copy Ram to Flash
  298    00000006 0260                  STR     w, [t]
  299    00000008 084A                  LDR     w, = FPA
  300    0000000A 1268                  LDR     w, [w]
  301    0000000C 4260                  STR     w, [t,#4]
  302    0000000E 084A                  LDR     w, = RAM_START  // START OF RAM NOT ORIG (START OF DICTIONARY)
  303    00000010 8260                  STR     w, [t,#8]
  304    00000012 084A                  LDR     w, = FLASH_WR_SIZE      // Smallest writeable page size
  305    00000014 C260                  STR     w, [t,#0x0C]
  306    00000016 084A                  LDR     w, = (SYSTEMCLOCK / 1000)       // in Khz
  307    00000018 0261                  STR     w, [t,#0x10]
  308    0000001A 084B                  LDR     x, = IAPCALL
  309    0000001C 9847                  BLX     x
  310                           #ifdef TOSCT
  312                           #endif
  313                                   NEXT    // FLASHCRTF    // NO RETURN VALUE
  313.1  0000001E 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
  313                                   NEXT1
  313.1  00000020 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
  313.2  00000022 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
  313.3                                 ENDM
  313.4                                 ENDM
  314                           //      LDR     t, [n]          // RETURN STATUS CODE
  315                           //      APUSH
  316                            LTORG   //Always outside of code, else data in words
  316.1                                  TABLE
  316.2  00000024 ........              Reference on line 295
  316.3  00000028 ........              Reference on line 296
  316.4  0000002C ........              Reference on line 299
  316.5  00000030 00000010              Reference on line 302
  316.6  00000034 00100000              Reference on line 304
  316.7  00000038 80BB0000              Reference on line 306
  316.8  0000003C F11FFF1F              Reference on line 308
  317                           
  318                           //------------------------------------------------------------------------------
  319                           //      FLASH_FORGET FLASH_FORGET:      ( --  ) Erase Flash Pages
  320                           
  321                            SECTION .text : CONST (2)
  322                           FLASH_FORGET_NFA:
  323    00000000 8C                    DC8     0x80+12
  324    00000001 464C4153485F4         DC8     'FLASH_FORGE'
                  64F524745    
  325    0000000C D4                    DC8     'T'+0x80
  326    0000000D FFFFFF         ALIGNROM 2,0xFFFFFFFF
  327    00000010 ........              DC32    FLASH_SAVE_NFA
  328                           FLASH_FORGET:
  329    00000014 ........              DC32    DOCOL
  330    00000018 ........              DC32    XOFF
  331                           // FF Setup starting page
  332    0000001C ........00400         DC32    STRVA, FLASH_SPAGE, FPA 
                  000........  
  333                                   
  334                           FF_LOOP:
  335                           // IF at last page Branch to FF_FINISH
  336    00000028 .............         DC32    FPADDR, AT              // When FPADDR
                  ...          
  337    00000030 ........00800         DC32    LIT, FLASH_PPAGE        // and Last Flash Page
                  000          
  338    00000038 .............         DC32    EQUAL, ZEQU             // are Equal
                  ...          
  339    00000040 ........              DC32    ZBRAN                   // Branch to Finish
  340    00000044 2C000000              DC32      FF_FINISH-.             // Else fall thru and 
  341                           
  342                           // Erase a page at a time using current FPA value
  343    00000048 ........              DC32    CMSIS_DISABLE_IRQS
  344    0000004C .............         DC32    FLASHPREP, FLASHESEC
                  ...          
  345    00000054 ........              DC32    CMSIS_ENABLE_IRQS
  346                           //        DC32    FPADDR, AT, DOTHEX
  347    00000058 ........00100         DC32    LIT, FLASH_WR_SIZE
                  000          
  348    00000060 .............         DC32    FPADDR, PSTORE
                  ...          
  349    00000068 ........              DC32    BRAN
  350    0000006C BCFFFFFF              DC32      FF_LOOP-.
  351                           
  352                           //      RESET DICTIONARY POINTERS APPROPRIATELY 
  353                           FF_FINISH:
  354                           // IF NO WORDS IN RAM TEST
  355    00000070 .............         DC32    RBASE, LATEST   // If Latest is GT RBASE ( Latest is in ram )
                  ...          
  356    00000078 ........              DC32    GREATERTHAN     // This will be zero
  357    0000007C ........              DC32    ZBRAN           // Meaning there are
  358    00000080 10000000              DC32     RAMWORDS-.     // words in Ram
  359                           // RESET ALL POINTERS
  360    00000084 ........              DC32    FISH_ONLY       // No words so clean up
  361                           // RESET FPA
  362    00000088 ........              DC32    BRAN
  363    0000008C 1C000000              DC32      FFDONE-.
  364                           
  365                           // WORDS IN RAM NEED TO BE RELINKED TO FLASH
  366                           RAMWORDS:
  367                           //        DC32    LIT, TASK_NFA         // Fish WITH TASKER IN RAM starts here
  368                           #ifdef FISH_PubRel_WORDSET
  369    00000090 .............         DC32    LIT, WC_FISH_PubRel_NFA // FISH in flash starts here
                  ...          
  370                           #endif
  371                           #ifdef FISH_NXP_M0_PRO_WORDCAT
  373                           #endif
  374    00000098 .............         DC32    DBASE, PFA, LFA         // RELINK THIS lfa, i.e.
                  ...........  
  375    000000A4 ........              DC32    STORE                   // repatch to Fish in flash
  376                           
  377                           // FLASH_FORGET Finish
  378                           FFDONE:
  379    000000A8 ........00400         DC32    STRVA, FLASH_SPAGE, FPA
                  000........  
  380    000000B4 ........11111         DC32    LIT, 11111111h, DUP, FPCURR, STORE, FPVAR, STORE
                  111..........
                  .............
                  .............
                  ....         
  381                           // Show results
  382    000000D0 ........              DC32    FLASH_SCAN      // Show Erase done via Flash Page status
  383                           #ifndef SRM
  384    000000D4 .............         DC32    CR, DOTVARSPACE, DOTDICTSPACE
                  ...........  
  385                           #endif
  386    000000E0 ........              DC32    XON
  387    000000E4 ........              DC32    SEMIS
  388                           
  389                           
  390                           //:NONAME FLASHWRITE:   ( --  ) Commands to save Ram to Flash using FPADDR.
  391                           //      FLASH SEQ OF CMDS TO COPY 4K RAM USING FPADDR
  392                            SECTION .text : CONST (2)
  393                           FLASHWRITE:
  394    00000000 ........              DC32    DOCOL
  395    00000004 ........              DC32    HERE                    // FILL
  396    00000008 .............         DC32    LIT, DICTSPACE_END-1    // REST OF DICTIONAIRY
                  ...          
  397    00000010 .............         DC32    HERE, SUBB
                  ...          
  398    00000018 ........FF000         DC32    LIT, 0xFF               // WITH FF SO
                  000          
  399    00000020 ........              DC32    FILL                    // End OF DICT VISIBLE IN FLASH
  400    00000024 ........              DC32    CMSIS_DISABLE_IRQS
  401    00000028 .............         DC32    FLASHPREP, FLASHESEC    // PREP AND ERSASE SECTOR
                  ...          
  402    00000030 .............         DC32    FLASHPREP, FLASHCRTF    // PREP AND COPY RAM TO SECTOR
                  ...          
  403    00000038 ........              DC32    CMSIS_ENABLE_IRQS
  404    0000003C ........              DC32    SEMIS
  405                           
  406                           //------------------------------------------------------------------------------
  407                           //:NONAME FLASH_SCAN:       ( -- ) SCAN FLASH PAGES FOR SAVED CODE
  408                           //      Patch in FLASH_SAVE'd Code.
  409                            SECTION .text : CONST (2)
  410                           FLASH_SCAN:
  411    00000000 ........              DC32    DOCOL
  412                           
  413                           // First page available must be at least equal to last page
  414                           // FLASH_PPAGE can be reserved and Hard_fault if accessed!
  415    00000004 ........00400         DC32    LIT, FLASH_SPAGE        // Start at first page available
                  000          
  416    0000000C .............         DC32    DUP, FPADDR, STORE
                  ...........  
  417                           
  418                           FLSCLP:
  419    00000018 .............         DC32    DUP, TOR                // EACH PAGE
                  ...          
  420    00000020 ........              DC32    AT                      // Verify SYSCLK signature
  421    00000024 ........              DC32    SYSCLK
  422    00000028 ........              DC32    EQUAL                   // Or this with other checks
  423                           /*
  424                                   DC32    R, LIT, 8, PLUS         // Verify FPC is .lt. FPADDR??? END PAGE
  425                                   DC32    AT, FPADDR, AT  // LIT, FLASH_PPAGE    // PAST WRITE-ABLE PAGES
  426                                   DC32    GREATERTHAN
  427                                   DC32    OR                      // Signature not valid
  428                           */
  429    0000002C ........              DC32    ZBRAN                   // make sure
  430    00000030 7C000000              DC32     CHECKPAGE-.            // page is erased
  431                           
  432                           //      PAGE PASSES VERIFICATION, LINK IT
  433    00000034 .............         DC32    R, LIT, 8, PLUS         // fpa
                  ...08000000..
                  ......       
  434    00000044 .............         DC32    DUP, AT
                  ...          
  435    0000004C ........              DC32    CURRENT_SV              // TO DP
  436    00000050 ........              DC32    STORE
  437    00000054 .............         DC32    FOURP, AT               // fpu
                  ...          
  438    0000005C .............         DC32    UP_SV, STORE            // TO UP
                  ...          
  439    00000064 ........              DC32    CR
  440    00000068 ........              DC32    PDOTQ
  441    0000006C 17                    DC8     23D
  442    0000006D 4144444544205         DC8     'ADDED WORDS FROM PAGE '
                  74F5244532046
                  524F4D2050414
                  74520        
  443    00000083 FF             ALIGNROM 2,0xFFFFFFFF
  444    00000084 ........              DC32    R
  445    00000088 ........              DC32    DOTHEX
  446                           
  447    0000008C .............         DC32    R, LIT, FLASH_WR_SIZE   // PAGE SIZE WERE WRITING
                  ...00100000  
  448    00000098 .............         DC32    PLUS, FPADDR, STORE     // Set as next free page
                  ...........  
  449                           
  450    000000A4 ........              DC32    BRAN
  451    000000A8 0C000000              DC32     FSNEXT-.
  452                           
  453                           CHECKPAGE:
  454    000000AC .............         DC32    R, ASSUREPAGE   // VERIFY PAGE IS FULLY ERASE
                  ...          
  455                           
  456                           FSNEXT:
  457    000000B4 .............         DC32    R, LIT, FLASH_WR_SIZE   // PAGE SIZE WERE WRITING
                  ...00100000  
  458    000000C0 ........              DC32    PLUS
  459    000000C4 ........              DC32    DUP
  460    000000C8 ........00800         DC32    LIT, FLASH_PPAGE        // PAST WRITE-ABLE PAGES
                  000          
  461    000000D0 ........              DC32    SUBB
  462    000000D4 ........              DC32    ZBRAN
  463    000000D8 20000000              DC32     FSDONE-.
  464                           
  465    000000DC ........              DC32    DROP
  466    000000E0 .............         DC32    RFROM, LIT, FLASH_WR_SIZE   // PAGE SIZE WERE WRITING
                  ...00100000  
  467    000000EC ........              DC32    PLUS
  468    000000F0 ........              DC32    BRAN
  469    000000F4 24FFFFFF              DC32     FLSCLP-.
  470                           
  471                           FSDONE:
  472    000000F8 ........              DC32    DROP
  473    000000FC .............         DC32    RFROM, DROP
                  ...          
  474    00000104 ........              DC32    SEMIS
  475                           
  476                           
  477                           //:NONAME ASSUREPAGE: ( fpa -- next-fpa) Verify this Flash page has code or is empty.
  478                           //      Make sure PAGE IN fpa page is erased and let user know what you do.
  479                           //      Works in 812 SRM!!!
  480                           
  481                           // 2 STACK ITEMS LEFT ON EXIT, BOTH ARE fpa+1000H LIKE WHATS PUT ON r<<<<<<<<<<<
  482                           
  483                            SECTION .text : CONST (2)
  484                           ASSUREPAGE:
  485    00000000 ........              DC32    DOCOL                   // verified ONLY fpa ON STACK Here
  486    00000004 ........              DC32    DUP                     // fpa fpa
  487    00000008 ........00100         DC32    LIT, FLASH_WR_SIZE      // PAGE SIZE WERE WRITING
                  000          
  488    00000010 ........              DC32    PLUS                    // fpa fpa+frs
  489    00000014 ........              DC32    TOR                     // End of this page
  490    00000018 ........              DC32    DUP                     // Begin -- fpa fpa
  491                           
  492                           APNEXT:
  493    0000001C ........              DC32    AT                      // Should be fpa -1
  494    00000020 ........              DC32    ONEP                    // if so make zero
  495    00000024 ........              DC32    ZBRAN                   // zero is good
  496    00000028 48000000              DC32     APCONT-.               // keep going
  497                           
  498                           //      ERASE THIS PAGE                 // fpa
  499                           //        DC32    FPADDR, AT, DOTHEX
  500                                   
  501    0000002C ........              DC32    CMSIS_DISABLE_IRQS
  502    00000030 ........              DC32    FLASHPREP
  503    00000034 ........              DC32    FLASHESEC
  504    00000038 ........              DC32    CMSIS_ENABLE_IRQS
  505    0000003C ........              DC32    CR
  506    00000040 ........              DC32    PDOTQ
  507    00000044 17                    DC8     23D
  508    00000045 4552415345442         DC8     'ERASED BAD FLASH PAGE  '
                  042414420464C
                  4153482050414
                  7452020      
  509                            ALIGNROM 2,0xFFFFFFFF
  510    0000005C ........              DC32    DOTHEX                  // consumed fpa
  511                           
  512                           //        DC32    CR, DOTS // DEBUG
  513    00000060 ........              DC32    DROP                    // so why this drop here?
  514                           
  515    00000064 .............         DC32    RFROM, DROP
                  ...          
  516    0000006C ........              DC32    SEMIS
  517                           
  518                           //      SO FAR SO GOOD
  519                           APCONT:                                 // addr
  520    00000070 .............         DC32    FOURP, DUP              // addr addr
                  ...          
  521    00000078 .............         DC32    DUP, R, SWAP            // addr addr r addr
                  ...........  
  522    00000084 ........              DC32    SUBB                    // addr addr f - End of this Page?
  523    00000088 ........              DC32    ZBRAN                   // looped thru whole page?
  524    0000008C 0C000000              DC32     APGOOD-.
  525                           
  526    00000090 ........              DC32    BRAN
  527    00000094 88FFFFFF              DC32     APNEXT-.               // check every word for all f's
  528                           
  529                           APGOOD:                                 // addr addr
  530    00000098 ........              DC32    CR
  531    0000009C ........              DC32    PDOTQ
  532    000000A0 0E                    DC8     14D
  533    000000A1 464C415348205         DC8     'FLASH PAGE OK '
                  0414745204F4B
                  20           
  534    000000AF FF             ALIGNROM 2,0xFFFFFFFF
  535    000000B0 .............         DC32    DROP, LIT, FLASH_WR_SIZE      // PAGE SIZE WERE WRITING
                  ...00100000  
  536    000000BC ........              DC32    SUBB
  537    000000C0 ........              DC32    DOTHEX
  538                           
  539                           APDONE:
  540    000000C4 .............         DC32    RFROM, DROP
                  ...          
  541    000000CC ........              DC32    SEMIS
  542                           
 5061                           // LFA BELOW NEEDS TO BE FLASH_FORGET_NFA
 5062                           //------------------------------------------------------------------------------
 5063                           
 5064                           //-------------------------- PROMPT VECTOR SECTION -----------------------------
 5065                           
 5066                           //      POFF ( -- )   Set NULL$ address in PROMPT to zero so quit does CR only.
 5067                           
 5068                            SECTION .text : CONST (2)
 5069                           POFF_NFA:
 5070    00000000 84                    DC8     0x84
 5071    00000001 504F46                DC8     'POF'
 5072    00000004 C6                    DC8     'F'+0x80
 5073    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5074    00000008 ........              DC32    FLASH_FORGET_NFA
 5075                           POFF:
 5076    0000000C ........              DC32    DOCOL
 5077    00000010 ........00000         DC32    STRVA, 0, PROMPT
                  000........  
 5078    0000001C ........              DC32    SEMIS
 5079                           
 5080                           //      PON ( -- )   Set NULL$ address in PROMPT to msg_MY_OK
 5081                           
 5082                            SECTION .text : CONST (2)
 5083                           PON_NFA:
 5084    00000000 83                    DC8     0x83
 5085    00000001 504F                  DC8     'PO'
 5086    00000003 CE                    DC8     'N'+0x80
 5087                            ALIGNROM 2,0xFFFFFFFF
 5088    00000004 ........              DC32    POFF_NFA
 5089                           PON:
 5090    00000008 ........              DC32    DOCOL
 5091    0000000C .............         DC32    STRVA, msg_MY_OK, PROMPT
                  ...........  
 5092    00000018 ........              DC32    SEMIS
 5093                           
 5094                           //      P ( -- addr )   Address of PROMPT, contains 0 or NULL$ address.
 5095                           
 5096                            SECTION .text : CONST (2)
 5097                           P_NFA:
 5098    00000000 81                    DC8     0x81
 5099    00000001 D0                    DC8     'P'+0x80
 5100    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5101    00000004 ........              DC32    PON_NFA
 5102                           P:
 5103    00000008 .............         DC32    DOCON, PROMPT
                  ...          
 5104                           
 5105                           //-------------------------- ERROR_HALT SECTION -----------------------------
 5106                           
 5107                           //      EHOFF ( -- )   Set ERROR_HALT to 0
 5108                           
 5109                            SECTION .text : CONST (2)
 5110                           EHOFF_NFA:
 5111    00000000 85                    DC8     0x85
 5112    00000001 45484F46              DC8     'EHOF'
 5113    00000005 C6                    DC8     'F'+0x80
 5114    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5115    00000008 ........              DC32    P_NFA
 5116                           EHOFF:
 5117    0000000C .............         DC32    DOCOL, ZERO, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 5118                           
 5119                           //      EHON ( -- )   Set ERROR_HALT to 1
 5120                           
 5121                            SECTION .text : CONST (2)
 5122                           EHON_NFA:
 5123    00000000 84                    DC8     0x84
 5124    00000001 45484F                DC8     'EHO'
 5125    00000004 CE                    DC8     'N'+0x80
 5126    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5127    00000008 ........              DC32    EHOFF_NFA
 5128                           EHON:
 5129    0000000C .............         DC32    DOCOL, ONE, LIT, ERROR_HALT, STORE, SEMIS
                  .............
                  .............
                  .........    
 5130                           
 5131                           //-------------------------- DOTDICTSPACE SECTION ------------------------------
 5132                           
 5133                           //      .DS DOTDICTSPACE:       ( n -- )
 5134                           //      Prints number of bytes availble in dictionary in DECIMAL using DOT,
 5135                           //      not affecting Base in the system
 5136                           
 5137                            SECTION .text : CONST (2)
 5138                           DOTDICTSPACE_NFA:
 5139    00000000 83                    DC8     0x83
 5140    00000001 2E44                  DC8     '.D'
 5141    00000003 D3                    DC8     'S'+0x80
 5142                            ALIGNROM 2,0xFFFFFFFF
 5143                           //      DC32    FLASH_FORGET_NFA
 5144                           //        DC32    P_NFA
 5145    00000004 ........              DC32    EHON_NFA
 5146                           DOTDICTSPACE:
 5147    00000008 ........              DC32    DOCOL
 5148    0000000C ........              DC32    DICTSPACE
 5149                           #ifdef SRM
 5153                           #else
 5154    00000010 ........              DC32    DOTDEC          // SAVES BASE
 5155                           #endif  // SRM
 5156    00000014 .............         DC32    LIT, msg_dictspace
                  ...          
 5157    0000001C .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5158                           #ifdef IO2TP
 5161                           #endif
 5162    00000024 ........              DC32    SEMIS
 5163                           
 5164                           
 5165                           //-------------------------- DOTVARSPACE SECTION -------------------------------
 5166                           
 5167                           //      .VS DOTVARSPACE:        ( n -- )
 5168                           //      Prints number of bytes availble in RAM VAR SPACE in DECIMAL using DOT,
 5169                           //      not affecting Base in the system.
 5170                           
 5171                            SECTION .text : CONST (2)
 5172                           DOTVARSPACE_NFA:
 5173    00000000 83                    DC8     0x83
 5174    00000001 2E56                  DC8     '.V'
 5175    00000003 D3                    DC8     'S'+0x80
 5176                            ALIGNROM 2,0xFFFFFFFF
 5177    00000004 ........              DC32    DOTDICTSPACE_NFA
 5178                           DOTVARSPACE:
 5179    00000008 ........              DC32    DOCOL
 5180    0000000C ........              DC32    VARSPACE
 5181    00000010 .............         DC32    FOUR, SLASH
                  ...          
 5182                           #ifdef SRM
 5186                           #else
 5187    00000018 ........              DC32    DOTDEC          // SAVES BASE
 5188                           #endif  // SRM
 5189    0000001C .............         DC32    LIT, msg_uvspace
                  ...          
 5190    00000024 .............         DC32    NULLSTRLEN, TYPE
                  ...          
 5191                           #ifdef IO2TP
 5194                           #endif
 5195    0000002C ........              DC32    SEMIS
 5196                           
 5197                           
 5198                           //      DUMP DUMP:      ( addr n -- )
 5199                           //      Print adrr and n lines of 4 columns of memory values in hexadecimal.
 5200                           //      Address must be even and a multiple of 4 else error message issued.
 5201                           //      QKEY used to abort dump.
 5202                           
 5203                            SECTION .text : CONST (2)
 5204                           DUMP_NFA:
 5205    00000000 84                    DC8     0x84
 5206    00000001 44554D                DC8     'DUM'
 5207    00000004 D0                    DC8     'P'+0x80
 5208    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5209    00000008 ........              DC32    DOTVARSPACE_NFA
 5210                           DUMP:
 5211    0000000C ........              DC32    DOCOL
 5212                           
 5213    00000010 .............         DC32    OVER, QALIGNED  // ( -- addr n )
                  ...          
 5214                           // DON'T SAVE BASE UNTIL AFTER ALIGNED TEST
 5215    00000018 ........              DC32    BASE_TO_R12     // Save current BASE
 5216    0000001C ........              DC32    HEX
 5217    00000020 .............         DC32    ZERO, XDO
                  ...          
 5218                           DUMP_ADDR_LINE:
 5219    00000028 ........              DC32    CR
 5220    0000002C .............         DC32    DUP, LIT, 10, DOTRU     // Print addr in Field
                  ...0A000000..
                  ......       
 5221    0000003C .............         DC32    FOUR, ZERO, XDO         // Four colum loop
                  ...........  
 5222                           DUMP_EACH_LOC:
 5223    00000048 .............         DC32    DUP, AT
                  ...          
 5224                           // Little Endian means addresses will print correctly
 5225                           // but to see character strings REVW is needed
 5226                           // but the addresses are scrambled!
 5227                           //        DC32    REVW                    // Reverse bytes in word
 5228    00000050 ........0E000         DC32    LIT, 14, DOTRU          // Diplay in Field
                  000........  
 5229    0000005C ........              DC32    FOURP
 5230    00000060 ........              DC32    XLOOP
 5231    00000064 E4FFFFFF              DC32    DUMP_EACH_LOC-.
 5232                           
 5233                           #ifdef IO2TP
 5236                           #endif
 5237    00000068 ........              DC32    QKEY
 5238    0000006C ........              DC32    ZBRAN
 5239    00000070 08000000              DC32     DUMP_CONT-.
 5240    00000074 ........              DC32    LEAVE
 5241                           DUMP_CONT:
 5242    00000078 ........              DC32    XLOOP
 5243    0000007C ACFFFFFF              DC32    DUMP_ADDR_LINE-.
 5244                           
 5245    00000080 .............         DC32    DROP, CR
                  ...          
 5246    00000088 ........              DC32    BASE_FROM_R12   // Restore BASE
 5247    0000008C ........              DC32    SEMIS
 5248                           
 5249                           
 5250                           //      VBASE VBASE:    ( -- addr )
 5251                           //       Return base addr of VAR's .
 5252                           
 5253                            SECTION .text : CONST (2)
 5254                           VBASE_NFA:
 5255    00000000 85                    DC8     0x85
 5256    00000001 56424153              DC8     'VBAS'
 5257    00000005 C5                    DC8     'E'+0x80
 5258    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5259    00000008 ........              DC32    DUMP_NFA
 5260                           VBASE:
 5261    0000000C .............         DC32    DOCON,  RAMVARSPACE_START
                  ...          
 5262                           
 5263                           
 5264                           //      DBASE DBASE:    ( -- addr )
 5265                           //      Return base addr of the dictionary.
 5266                           
 5267                            SECTION .text : CONST (2)
 5268                           DBASE_NFA:
 5269    00000000 85                    DC8     0x85
 5270    00000001 44424153              DC8     'DBAS'
 5271    00000005 C5                    DC8     'E'+0x80
 5272    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5273    00000008 ........              DC32    VBASE_NFA
 5274                           DBASE:
 5275    0000000C .............         DC32    DOCON,  ORIG
                  ...          
 5276                           
 5277                           
 5278                           //      RBASE RBASE:    ( -- addr )
 5279                           //      Return base addr of RAM.
 5280                           
 5281                            SECTION .text : CONST (2)
 5282                           RBASE_NFA:
 5283    00000000 85                    DC8     0x85
 5284    00000001 52424153              DC8     'RBAS'
 5285    00000005 C5                    DC8     'E'+0x80
 5286    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5287    00000008 ........              DC32    DBASE_NFA
 5288                           RBASE:
 5289    0000000C ........00000         DC32    DOCON,  RAM_START
                  010          
 5290                           
 5291                           
 5292                           //      CLS CLS:        ( -- )
 5293                           //      Clear serial terminal screen using a formfeed character
 5294                           
 5295                            SECTION .text : CONST (2)
 5296                           CLS_NFA:
 5297    00000000 83                    DC8     0x83
 5298    00000001 434C                  DC8     'CL'
 5299    00000003 D3                    DC8     'S'+0x80
 5300                            ALIGNROM 2,0xFFFFFFFF
 5301    00000004 ........              DC32    RBASE_NFA
 5302                           CLS:
 5303    00000008 ........              DC32    DOCOL
 5304    0000000C ........              DC32    PDOTQ
 5305    00000010 04                    DC8     4
 5306    00000011 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT100 ESC SETUP
 5307    00000013 324A                  DC8     '2J'            // Clearscreen
 5308    00000015 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5309    00000018 ........              DC32    PDOTQ
 5310    0000001C 04                    DC8     4
 5311    0000001D 1B5B                  DC8     0x1B, '['       // ESC[ = ANSI VT00 ESC SETUP
 5312    0000001F 3B48                  DC8     ';H'            // CURSORHOME ( upper left corner )
 5313    00000021 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5314    00000024 ........              DC32    CR              // Reset OUT
 5315    00000028 ........              DC32    SEMIS
 5316                           
 5317                           
 5318                           //      ( PAREN:        ( -- ) IMMEDIATE
 5319                           //      Used in the form:
 5320                           //              ( CCcc )
 5321                           //      Ignore comments within parenthesis. A right parenthesis ends comment.
 5322                           //      The comments may be multi-line but a space or tab is required
 5323                           //      for any line that is otherwise empty for formatting purposes,
 5324                           //      else a comment error will be printed. May occur during execution or in a
 5325                           //      colon-definition. A blank after the leading parenthesis is required.
 5326                           
 5327                            SECTION .text : CONST (2)
 5328                           PAREN_NFA:
 5329    00000000 C1                    DC8     0x0C1
 5330    00000001 A8                    DC8     '('+0x80
 5331    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5332    00000004 ........              DC32    CLS_NFA
 5333                           PAREN:
 5334                           // Slow Single line comment
 5335                           //      DC32    DOCOL, LIT, ')', WORD, SEMIS
 5336    00000008 ........              DC32    DOCOL
 5337                           PML_LOOP:
 5338    0000000C ........29000         DC32    LIT, ')'
                  000          
 5339    00000014 ........              DC32    TIB_CHAR_SCAN   // ( c -- f )
 5340                           //
 5341    00000018 ........              DC32    ZEQU            // If null
 5342    0000001C ........              DC32    ZBRAN           // found fall thru
 5343    00000020 34000000              DC32      PE_DONE-.     // else were done
 5344                           
 5345                           // Acting like the outer interpreter here, signal DLE
 5346    00000024 .............         DC32    CR, LIT, 0x10, EMIT
                  ...10000000..
                  ......       
 5347    00000034 ........              DC32    QUERY
 5348                           //  AND IF ONLY CR (null) ERR
 5349                           //        DC32    TIB_SV, CAT
 5350    00000038 .............         DC32    LIT, TIB+1, CAT // PAST COUNT BYTE
                  ...........  
 5351    00000044 ........              DC32    ZBRAN
 5352    00000048 10000000              DC32      PAREN_ERR-.
 5353                           
 5354                           //  If closing paren not in this line LOOP
 5355    0000004C ........              DC32    BRAN
 5356    00000050 BCFFFFFF              DC32      PML_LOOP-.
 5357                           
 5358                           PE_DONE:
 5359    00000054 ........              DC32    SEMIS
 5360                           
 5361                           PAREN_ERR:
 5362    00000058 .............         DC32    LIT, msg_paren_err
                  ...          
 5363    00000060 .............         DC32    NULLSTRLEN, TYPE        // Passed in null string
                  ...          
 5364    00000068 ........              DC32    SEMIS
 5365                           
 5366                           
 5367                           //      BACKSLASH BACKSLASH:    ( --  )
 5368                           //      After a trailing space treat the rest of the line as a comment.
 5369                           //      By setting a null terminator in TIB
 5370                           
 5371                            SECTION .text : CONST (2)
 5372                           BACKSLASH_NFA:
 5373    00000000 C1                    DC8     0x0C1
 5374    00000001 DC                    DC8     '\\'+0x80
 5375    00000002 FFFF           ALIGNROM 2,0xFFFFFFFF
 5376    00000004 ........              DC32    PAREN_NFA
 5377                           BACKSLASH:
 5378    00000008 ........              DC32    DOCOL
 5379    0000000C .............         DC32    ZERO, TIB_SV, IN_SV, AT, PLUS, CSTORE
                  .............
                  .............
                  .........    
 5380    00000024 ........              DC32    SEMIS
 5381                           
 5382                           
 5383                           //      SYSCLK SYSCLK:  ( -- value )
 5384                           //      Returns system clock value in Hz, i.e. 48000000 = 48Mhz.
 5385                           
 5386                            SECTION .text : CONST (2)
 5387                           SYSCLK_NFA:
 5388    00000000 86                    DC8     0x86
 5389    00000001 535953434C            DC8     'SYSCL'
 5390    00000006 CB                    DC8     'K'+0x80
 5391    00000007 FF             ALIGNROM 2,0xFFFFFFFF
 5392    00000008 ........              DC32    BACKSLASH_NFA
 5393                           SYSCLK:
 5394    0000000C ........              DC32    .+5
 5395                            SECTION .text : CODE (2)
 5396    00000000 0349                  LDR     n, = SYSCLOCK   // SystemCoreClock
 5397    00000002 0868                  LDR     t, [n]
 5398                                   TPUSH   // Push -- t
 5398                                   PUSHt   // push t to p, pre decrement p
 5398.1  00000004 3F1F                  SUBS    p, p, #4        // push t to p, pre decrement p
 5398.2  00000006 3860                  STR     t, [p]
 5398.3                                 ENDM
 5398                                   NEXT
 5398.1  00000008 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 5398                                   NEXT1
 5398.1  0000000A 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5398.2  0000000C 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5398.3                                 ENDM
 5398.4                                 ENDM
 5398.5                                 ENDM
 5399    0000000E 0000           LTORG   //Always outside of code, else data in words
 5399.1                                  TABLE
 5399.2  00000010 ........              Reference on line 5396
 5400                           
 5401                           
 5402                           //      STCTR   ( -- addr ) SYSTICK Interrupt increments this with 32but wrap.
 5403                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5404                            SECTION .text : CONST (2)
 5405                           STCTR_NFA:
 5406    00000000 85                    DC8     0x85
 5407    00000001 53544354              DC8     'STCT'
 5408    00000005 D2                    DC8     'R'+0x80
 5409    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5410    00000008 ........              DC32    SYSCLK_NFA
 5411                           STCTR:
 5412    0000000C .............         DC32    DOCON, STICKER
                  ...          
 5413                           
 5414                           
 5415                           //      DELAY ( n value -- ) 7 E000E010h !   5 E000E010h !
 5416                            SECTION .text : CONST (2)
 5417                           DELAY_NFA:
 5418    00000000 85                    DC8     0x85
 5419    00000001 44454C41              DC8     'DELA'
 5420    00000005 D9                    DC8     'Y'+0x80
 5421    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5422    00000008 ........              DC32    STCTR_NFA
 5423                           DELAY:
 5424    0000000C ........              DC32    .+5
 5425                            SECTION .text : CODE (2)
 5426                                   POP2n   // Reload value in n
 5426.1  00000000 3968                  LDR     n, [p]
 5426.2  00000002 3F1D                  ADDS    p, p, #4
 5426.3                                 ENDM
 5427                                   POP2t   // loop count in t
 5427.1                         #ifndef TOSCT
 5427.2  00000004 3868                  LDR     t, [p]          // pop tos to t, post increment p
 5427.3                         #endif
 5427.4  00000006 3F1D                  ADDS    p, p, #4
 5427.5                                 ENDM
 5428                           // SET STCTR TO NEGATIVE LOOP COUNT TO END AT ZERO
 5429    00000008 0A4C                  LDR     y, = STICKER
 5430    0000000A C043                  MVNS    t, t            // 1's compliment
 5431    0000000C 401C                  ADDS    t, t, #1       // 2's compliment
 5432    0000000E 2060                  STR     t, [y]
 5433                           // Load SYST_RVR with countdown value
 5434    00000010 094A                  LDR     w, = SYST_RVR
 5435    00000012 1160                  STR     n, [w]
 5436                           // and reset SYST_CVR to start countdown.
 5437    00000014 094A                  LDR     w, = SYST_CVR
 5438                           // Writing it clears the System Tick counter and the COUNTFLAG bit in STCTRL.
 5439    00000016 1160                  STR     n, [w]
 5440                           // If n=0 ( in t ) user is just setting reload value
 5441    00000018 0028                  CMP     t, #0           // LOOP OF ZERO
 5442    0000001A 06D0                  BEQ     DELAY_DONE
 5443                           // INTERRUPT VERSION: negate n to STCTR and leave when STCTR = 0
 5444                           // STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5445                           // Save and restore user interrupt setting
 5446                           // y = STICKER
 5447    0000001C 084A                  LDR     w, = SYST_CSR
 5448    0000001E 1068                  LDR     t, [w]          // Save user SYSTICK interrupt setting
 5449    00000020 0721                  MOVS    n, #7
 5450    00000022 1160                  STR     n, [w]          // Turn SYSTICK interrupt on in case it's off
 5451                           DELAY_LOOP:
 5452    00000024 2168                  LDR     n, [y]
 5453    00000026 0029                  CMP     n, #0
 5454    00000028 FCD1                  BNE     DELAY_LOOP
 5455                           DELAY_DONE:
 5456    0000002A 1060                  STR     t, [w]  // Restore user SYSTICK interrupt setting
 5457                                   NEXT
 5457.1  0000002C 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 5457                                   NEXT1
 5457.1  0000002E 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5457.2  00000030 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5457.3                                 ENDM
 5457.4                                 ENDM
 5458    00000032 0000           LTORG
 5458.1                                  TABLE
 5458.2  00000034 ........              Reference on line 5429
 5458.3  00000038 14E000E0              Reference on line 5434
 5458.4  0000003C 18E000E0              Reference on line 5437
 5458.5  00000040 10E000E0              Reference on line 5447
 5459                           
 5460                           
 5461                           //      MS MS: ( n -- ) n * 1 millisecond execution time
 5462                           //      STI_ON: 7 E000E010h !  STI_OFF: 5 E000E010h ! E000E010h @ .H
 5463                           
 5464                            SECTION .text : CONST (2)
 5465                           MS_NFA:
 5466    00000000 82                    DC8     0x82
 5467    00000001 4D                    DC8     'M'
 5468    00000002 D3                    DC8     'S'+0x80
 5469    00000003 FF             ALIGNROM 2,0xFFFFFFFF
 5470    00000004 ........              DC32    DELAY_NFA
 5471                           MS:
 5472    00000008 ........              DC32    DOCOL
 5473                           #ifdef NXP_M0_11xx_IRC12_48MHZ
 5474    0000000C ........7FBB0         DC32    LIT, 47999d     // BB7F 1ms @ 48mhz RELOAD COUNTER VALUE
                  000          
 5475                           #endif
 5476                           #ifdef NXP_M0_812_IRC12_24MHZ
 5478                           #endif
 5479    00000014 ........              DC32    DELAY
 5480    00000018 ........              DC32    SEMIS
 5481                           
 5482                           
 5483                           //      WORDCAT WORDCAT: ( -- )
 5484                           //      Creates a Word Category NFA and LFA that cannot be searched for,
 5485                           //      but is displayed by WORDS and MYWORDS to label a group of Words.
 5486                           //      Define a group of Words and then add a category name with WORDCAT.
 5487                           //      EX: WORDCAT MY APP WORDS:
 5488                           //      It must be on a line of it's own.
 5489                           //      The colon at the end is FISH convention.
 5490                            SECTION .text : CONST (2)
 5491                           WORDCAT_NFA:
 5492    00000000 87                    DC8     0x87
 5493    00000001 574F52444341          DC8     'WORDCA'
 5494    00000007 D4                    DC8     'T'+0x80
 5495                            ALIGNROM 2,0xFFFFFFFF
 5496    00000008 ........              DC32    MS_NFA
 5497                           WORDCAT:
 5498    0000000C ........              DC32    DOCOL
 5499    00000010 .............         DC32    HERE, TOR
                  ...          
 5500    00000018 .............         DC32    ZERO, CCOMMA    // Count byte place holder
                  ...          
 5501    00000020 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5502    0000002C ........              DC32    HERE
 5503    00000030 ........0D000         DC32    LIT, 0Dh, WORD
                  000........  
 5504    0000003C .............         DC32    DUP, CAT
                  ...          
 5505    00000044 ........0A000         DC32    LIT, 0Ah, ROT, CSTORE
                  000..........
                  ......       
 5506    00000054 .............         DC32    DUP, ONEP, ALLOT
                  ...........  
 5507    00000060 ........84000         DC32    LIT, 084h        // Count before system text
                  000          
 5508    00000068 .............         DC32    PLUS, R, CSTORE
                  ...........  
 5509    00000074 ........0D000         DC32    LIT, 0Dh, CCOMMA
                  000........  
 5510    00000080 ........8A000         DC32    LIT, 08Ah, CCOMMA
                  000........  
 5511    0000008C ........              DC32    ALIGN32_FF_PAD
 5512    00000090 .............         DC32    LATEST, COMMA
                  ...          
 5513    00000098 ........              DC32    RFROM
 5514    0000009C .............         DC32    LIT, CURRENT
                  ...          
 5515    000000A4 ........              DC32    STORE
 5516    000000A8 ........              DC32    SEMIS
 5517                           
 5518                           
 5519                           //      WORDS WORDS:    ( -- ) RENAMED: VLIST to WORDS
 5520                           //      Output list of Words in the dictionary in search order.
 5521                           //      Uses WC_ nfa's to format Word Categories.
 5522                           //      Uses FENCE for where to stop.
 5523                           //      See MYWORDS.
 5524                           
 5525                            SECTION .text : CONST (2)
 5526                           WORDS_NFA:
 5527    00000000 85                    DC8     0x85
 5528    00000001 574F5244              DC8     'WORD'
 5529    00000005 D3                    DC8     'S'+0x80
 5530    00000006 FFFF           ALIGNROM 2,0xFFFFFFFF
 5531    00000008 ........              DC32    WORDCAT_NFA
 5532                           WORDS:
 5533    0000000C ........              DC32    DOCOL
 5534    00000010 .............         DC32    THREE, SPACES
                  ...          
 5535    00000018 ........              DC32    LATEST
 5536                           #ifdef XON_XOFF
 5537    0000001C ........              DC32    XOFF    // TEMP TEST THRE
 5538                           #endif
 5539                           VLIS1:  // ADD nfa length to current out_uv & verify it doesn't violate csll.
 5540                           
 5541    00000020 .............         DC32    ZERO, OVER      // -- nfa zero nfa
                  ...          
 5542    00000028 .............         DC32    ONEP, CAT       // If wc_ header skip
                  ...          
 5543    00000030 ........0D000         DC32    LIT, 0x0D       // -- nfa zero (c@) 0x0D
                  000          
 5544    00000038 .............         DC32    EQUAL, ZEQU     // -- nfa zerro flag
                  ...          
 5545    00000040 ........              DC32    ZBRAN           // -- nfa zero
 5546    00000044 1C000000              DC32     WORDS2-.       // wc_ goto
 5547                                   
 5548    00000048 ........              DC32    DROP            // -- nfa
 5549    0000004C .............         DC32    DUP, PFA, LFA   // -- nfa lfa
                  ...........  
 5550    00000058 .............         DC32    OVER, SUBB      // -- nfa (lfa - nfa)
                  ...          
 5551                           
 5552                           WORDS2: // -- nfa n
 5553                           
 5554    00000060 .............         DC32    OUT_SV, AT
                  ...          
 5555    00000068 ........              DC32    PLUS
 5556    0000006C ........4A000         DC32    LIT, 74         // was :NONAME CSLL - WORDS line length constant.
                  000          
 5557    00000074 ........              DC32    GREATERTHAN
 5558    00000078 ........              DC32    ZBRAN           // If not at end of line
 5559    0000007C 10000000              DC32     WORD21-.        // skip cr and out reset
 5560                           
 5561    00000080 ........              DC32    CR              // Start another line
 5562    00000084 .............         DC32    THREE, SPACES
                  ...          
 5563                           
 5564                           WORD21:
 5565                           #ifdef  IO2TP
 5568                           #endif
 5569                           // For MYWORDS test FENCE and stop if less
 5570    0000008C ........              DC32    DUP             // nfa
 5571    00000090 .............         DC32    FENCE_SV, AT
                  ...          
 5572    00000098 ........              DC32    LESSTHAN
 5573    0000009C ........              DC32    ZBRAN
 5574    000000A0 0C000000              DC32     WORDSCONT-.
 5575                           
 5576    000000A4 ........              DC32    BRAN
 5577    000000A8 5C000000              DC32     WORDSDONE-.
 5578                           
 5579                           WORDSCONT:
 5580    000000AC ........              DC32    DUP             // nfa
 5581    000000B0 ........              DC32    IDDOT
 5582    000000B4 .............         DC32    TWO, SPACES
                  ...          
 5583                           
 5584    000000BC .............         DC32    DUP, ONEP, CAT  // Take nfa and look for WORDCAT signature
                  ...........  
 5585    000000C8 ........0D000         DC32    LIT, 0x0D       // which is cr
                  000          
 5586    000000D0 ........              DC32    EQUAL
 5587    000000D4 ........              DC32    ZBRAN           // If not wordcat
 5588    000000D8 10000000              DC32     NOT_WC-.       // skip
 5589                           
 5590    000000DC ........00000         DC32    STRVA, 0, OUT
                  000........  
 5591                           
 5592                           NOT_WC:
 5593    000000E8 ........              DC32    PFA             // ( nfa -- pfa )
 5594    000000EC ........              DC32    LFA             // ( pfa -- lfa )
 5595    000000F0 ........              DC32    AT              // Is next lfa
 5596    000000F4 ........              DC32    DUP
 5597    000000F8 ........              DC32    ZEQU            // Zero = end of dictionary
 5598                           
 5599                           // REMOVED SO WORDS AND MYWORDS CAN BE USED in DOWNLOAD FILES
 5600                           //      DC32    QKEY           // Zero or break key ( ^C = 0x03 )
 5601                           //      DC32    OR
 5602                           
 5603    000000FC ........              DC32    ZBRAN           // Until break key or end of dictionary
 5604    00000100 20FFFFFF              DC32     VLIS1-.
 5605                           
 5606                           #ifdef  IO2TP
 5609                           #endif
 5610                           WORDSDONE:
 5611    00000104 .............         DC32    DROP, CR
                  ...          
 5612    0000010C ........              DC32    SEMIS
 5613                           
 5614                           
 5615                           //      MYWORDS MYWORDS: ( -- )
 5616                           //      Print only system defined words by manipulating FENCE.
 5617                           
 5618                            SECTION .text : CONST (2)
 5619                           MYWORDS_NFA:
 5620    00000000 87                    DC8     0x87
 5621    00000001 4D59574F5244          DC8     'MYWORD'
 5622    00000007 D3                    DC8     'S'+0x80
 5623                            ALIGNROM 2,0xFFFFFFFF
 5624    00000008 ........              DC32    WORDS_NFA
 5625                           MYWORDS:
 5626    0000000C ........              DC32    DOCOL
 5627    00000010 ........00400         DC32    STRVA , FLASH_SPAGE, FENCE
                  000........  
 5628    0000001C ........              DC32    WORDS                   // now print words in ram
 5629    00000020 ........00000         DC32    STRVA, 0 , FENCE
                  000........  
 5630    0000002C ........              DC32    SEMIS
 5631                           
 5632                           
 5633                           //      FISH_ONLY FISH_ONLY     ( -- ) MODIFIED:
 5634                           //      RESET DP, UP AND CURRENT TO ORIGINAL FLASH IMAGE
 5635                           
 5636                            SECTION .text : CONST (2)
 5637                           FISH_ONLY_NFA:
 5638    00000000 89                    DC8     0x80+9
 5639    00000001 464953485F4F4         DC8     'FISH_ONL'
                  E4C          
 5640    00000009 D9                    DC8     'Y'+0x80
 5641    0000000A FFFF           ALIGNROM 2,0xFFFFFFFF
 5642    0000000C ........              DC32    MYWORDS_NFA
 5643                           FISH_ONLY:
 5644    00000010 ........              DC32    .+5
 5645                            SECTION .text : CODE (2)
 5646                           //      LDR     n, = TASK_NFA           // preserve TOS
 5647                           #ifdef FISH_PubRel_WORDSET
 5648    00000000 0749                  LDR     n, = WC_FISH_PubRel_NFA
 5649                           #endif
 5650                           #ifdef FISH_NXP_M0_PRO_WORDCAT
 5652                           #endif
 5653    00000002 084C                  LDR     y, = CURRENT            // CURRENT SETTING
 5654    00000004 2160                  STR     n, [y]
 5655    00000006 084C                  LDR     y, = FPC                // FLASH CURRENT
 5656    00000008 2160                  STR     n, [y]
 5657    0000000A 0849                  LDR     n, = RAMVARSPACE_START
 5658    0000000C 084C                  LDR     y, = UP                 // UP SETTING
 5659    0000000E 2160                  STR     n, [y]
 5660    00000010 084C                  LDR     y, = FPSV                // FLASH USER VARS
 5661    00000012 2160                  STR     n, [y]
 5662    00000014 0849                  LDR     n, = ORIG
 5663    00000016 094C                  LDR     y, = DP                 // DP SETTING
 5664    00000018 2160                  STR     n, [y]
 5665                                   NEXT
 5665.1  0000001A 04CD                  LDM     i!, {w} // get cfa addr to w, incr i after
 5665                                   NEXT1
 5665.1  0000001C 08CA                  LDM     w!, {x}         // contents of cfa, (pfa), -> x, bump w to cfa+4
 5665.2  0000001E 9847                  BLX     x               // w preserves cfa+4 (pfa) for DOCOL's benefit
 5665.3                                 ENDM
 5665.4                                 ENDM
 5666                            LTORG
 5666.1                                  TABLE
 5666.2  00000020 ........              Reference on line 5648
 5666.3  00000024 ........              Reference on line 5653
 5666.4  00000028 ........              Reference on line 5655
 5666.5  0000002C ........              Reference on line 5657
 5666.6  00000030 ........              Reference on line 5658
 5666.7  00000034 ........              Reference on line 5660
 5666.8  00000038 ........              Reference on line 5662
 5666.9  0000003C ........              Reference on line 5663
 5667                           
 5668                           
 5669                           //      FISH FISH:      ( -- )
 5670                           //      Print Flash Status and FISH Signon Message.
 5671                           
 5672                            SECTION .text : CONST (2)
 5673                           FISH_NFA:
 5674    00000000 84                    DC8     0x84
 5675    00000001 464953                DC8     'FIS'
 5676    00000004 C8                    DC8     'H'+0x80
 5677    00000005 FFFFFF         ALIGNROM 2,0xFFFFFFFF
 5678    00000008 ........              DC32    FISH_ONLY_NFA
 5679                           FISH:
 5680    0000000C ........              DC32    DOCOL
 5681    00000010 ........              DC32    FLASH_SCAN
 5682    00000014 ........              DC32    SIGNON
 5683    00000018 ........              DC32    ABORT
 5684                           
 5685                           //=============================== WORDCAT ====================================//
 5686                           //NOEXEC HEADERFORWORDCATEGORIES
 5687                           //      WC_FISH_PubRel: = FISH Reference Model: CATEGORY
 5688                            SECTION .text : CONST (2)
 5689                           WC_FISH_PubRel_NFA:
 5690    00000000 99                    DC8     0x80+4+21
 5691    00000001 0D0A                  DC8     0x0D, 0x0A
 5692    00000003 4649534820526         DC8     'FISH Reference Model:'
                  5666572656E63
                  65204D6F64656
                  C3A          
 5693    00000018 0D8A                  DC8     0x0D, 0x0A+0x80
 5694    0000001A FFFF           ALIGNROM 2,0xFFFFFFFF
 5695    0000001C ........              DC32    FISH_NFA
 5696                           ;**** FIRST WORD LISTED****
 5697                           
 5698                           //=============================== WORDCAT ====================================//
 5699                           
 5700                           #ifdef FISH_NXP_M0_PRO_WORDCAT
 5702                           #endif
 5703                           // FIRST WORDCAT
 5704                           
 5705                           //------------------------------------------------------------------------------
 5706                           // FOR MULTI TASKING MUST BE PLACED in RAM AND OFFSET USED in SYSTEM VARS!!!!!!
 5707                           //            T A S K 
 5708                           //
 5709                           ;.data          // Place TASK at beginning of RAM, or not.
 5710                           /*
 5711                            SECTION .text : CONST (2)
 5712                           TASK_NFA:
 5713                                   DC8     0x84
 5714                                   DC8     'TAS'
 5715                                   DC8     'K'+0x80
 5716                            ALIGNROM 2,0xFFFFFFFF
 5717                           //      TASK Is top of dictionary until new definitionsa added
 5718                           //      PATCH CONTEXT or LATEST else LFA in TASK FROM SYM TABLE
 5719                           //      To debug dictionary searches - see - PFIND & DFIND
 5720                           //      DC32    ZEQU_NFA        // 4 (no match) bombing at +
 5721                           //      DC32    NOOP_NFA        // Patch here to shorten test of PFIND
 5722                           //      DC32    CAT_NFA         // C@ before @
 5723                           //      DC32    LESS_NFA        // < before =
 5724                           //       DC32   SoCinit_NFA     //XON_NFA               // FULL DICT SEARCH
 5725                                   DC32    MS_NFA
 5726                           TASK:
 5727                                   DC32    DOCOL
 5728                                   DC32    SEMIS
 5729                           */
 5730                           
 5731                           //------------------------------------------------------------------------------
 5732                           //:NONAME SECTION:
 5733                           // THESE STAY HERE (INSTEAD OF SLLIB) BECAUSE THEY ARE CONDITIONALLY INCLUDED
 5734                           // HI-LEVEL THEM ASM SECTIONS
 5735                           #ifdef IO2TP
 5744                           #endif
 5745                           
 5746                           #ifdef IO2TP
 5755                           #endif
 5756                           
 5757                           #ifdef USE_CMAIN
 5767                           #endif
 5768                           
 5769                           #ifdef TESTRAM
 5875                           #endif  // TESTRAM
 5876                           //------------------------------------------------------------------------------
 5877                           // Placing blocks that can change at end of link map
 5878                           // Place :NONAME for static Library first in FISH_NXP_M0_SLIB.s
 5879                           
 5880                           // $PROJ_DIR$\..\FISH_RM_COMMON
 5881                           // $PROJ_DIR$\..\FISH_RM_CORTEX_M_COMMON_CODE
 5882                           // In Assembler preprocessor set additional include directories 
 5883                           $FISH_RM_MSGS.h
    1                           //------------------------------------------------------------------------------
    2                           
    3                            SECTION .text : CONST (2)
    4                           
    5                           // DC8 "?" IS A NULL TERMINATED STRING
    6                           // DC8 '?' IS NOT
    7                           // #define EOL_DLE // DLE 0x10/16d in QUIT>CR after last word interpreted.
    8                           // #define EOL_NAK // NAK 0x15/21d in error messages for STDLED editor highlight
    9                           // The EOL_NAK makes SPACE NAK end of string in FISH_RM_MSGS.h
   10                           
   11                            ALIGNROM 2,0xFFFFFFFF
   12                           // ALIGN THIS ONE FOR PFIND          
   13                           msg_RUN:
   14    00000000 03                    DC8     3
   15    00000001 52554E2000            DC8     "RUN "
   16                           msg_questionmark:
   17    00000006 203F2000              DC8     " ? "
   18                           
   19                           msg_cr:
   20    0000000A 203C43523E200         DC8     " <CR> "
                  0            
   21                           
   22                           msg_uvspace:
   23    00000011 5641522043454         DC8     "VAR CELLS "
                  C4C532000    
   24                           
   25                           msg_dictspace:
   26    0000001C 44494354494F4         DC8     "DICTIONARY BYTES "
                  E415259204259
                  5445532000   
   27                           
   28                           msg_paren_err:
   29                           #ifdef EOL_NAK
   30    0000002E 20434F4D4D454         DC8     ' COMMENT LINE CANNOT BE EMPTY '
                  E54204C494E45
                  2043414E4E4F5
                  420424520454D
                  50545920     
   31    0000004C 1500                  DC8     0x15, 0
   32                           #else
   34                           #endif
   35                                     
   36                           msg_forget_fish:
   37                           #ifdef EOL_NAK
   38    0000004E 2043414E54204         DC8     ' CANT FORGET FISH IN FLASH '
                  64F5247455420
                  4649534820494
                  E20464C415348
                  20           
   39    00000069 1500                  DC8     0x15, 0
   40                           #else
   42                           #endif
   43                           
   44                           msg_forget_saved:
   45                           #ifdef EOL_NAK
   46    0000006B 20494E20464C4         DC8     ' IN FLASH - SEE FLASH_FORGET '
                  15348202D2053
                  454520464C415
                  3485F464F5247
                  455420       
   47    00000088 1500                  DC8     0x15, 0
   48                           #else
   50                           #endif
   51                           
   52                           msg_dictfull:
   53                           #ifdef EOL_NAK
   54    0000008A 2044494354494         DC8     ' DICTIONARY FULL - SEE .DS '
                  F4E4152592046
                  554C4C202D205
                  34545202E4453
                  20           
   55    000000A5 1500                  DC8     0x15, 0
   56                           #else
   58                           #endif
   59                           
   60                           msg_uvfull:
   61                           #ifdef EOL_NAK
   62    000000A7 2052414D20564         DC8     ' RAM VAR SPACE FULL - SEE .VS '
                  1522053504143
                  452046554C4C2
                  02D2053454520
                  2E565320     
   63    000000C5 1500                  DC8     0x15, 0
   64                           #else
   66                           #endif
   67                           
   68                           msg_wordexists:
   69                           #ifdef EOL_NAK
   70    000000C7 20495320414C5         DC8     ' IS ALREADY DEFINED '
                  2454144592044
                  4546494E45442
                  0            
   71    000000DB 1500                  DC8     0x15, 0
   72                           #else
   74                           #endif
   75                           
   76                           msg_word_error:
   77                           #ifdef EOL_NAK
   78    000000DD 203F204E4F542         DC8     ' ? NOT WORD '
                  0574F524420  
   79    000000E9 1500                  DC8     0x15, 0
   80                           #else
   82                           #endif
   83                           
   84                           msg_number_error:
   85                           #ifdef EOL_NAK
   86    000000EB 203F204E4F542         DC8     ' ? NOT WORD OR NUMBER '
                  0574F5244204F
                  52204E554D424
                  55220        
   87    00000101 1500                  DC8     0x15, 0
   88                           #else
   90                           #endif
   91                           
   92                           msg_qstack:
   93                           #ifdef EOL_NAK
   94    00000103 2043415553454         DC8     ' CAUSED A STACK ERROR '
                  4204120535441
                  434B204552524
                  F5220        
   95    00000119 1500                  DC8     0x15, 0
   96                           #else
   98                           #endif
   99                           
  100                           msg_qpair:
  101                           #ifdef EOL_NAK
  102    0000011B 20535441434B2         DC8     ' STACK ERROR WHILE EXECUTING OR COMPILING '
                  04552524F5220
                  5748494C45204
                  5584543555449
                  4E47204F52204
                  34F4D50494C49
                  4E4720       
  103    00000145 1500                  DC8     0x15, 0
  104                           #else
  106                           #endif
  107                           
  108                           msg_qcomp:
  109                           #ifdef EOL_NAK
  110    00000147 204552524F522         DC8     ' ERROR - NOT COMPILING '
                  02D204E4F5420
                  434F4D50494C4
                  94E4720      
  111    0000015E 1500                  DC8     0x15, 0
  112                           #else
  114                           #endif
  115                           
  116                           msg_qexec:
  117                           #ifdef EOL_NAK
  118    00000160 204552524F522         DC8     ' ERROR - EXECUTED WHILE COMPILING '
                  02D2045584543
                  5554454420574
                  8494C4520434F
                  4D50494C494E4
                  720          
  119    00000182 1500                  DC8     0x15, 0
  120                           #else
  122                           #endif
  123                           
 5884                           // equals below
 5885                           //#include ".\..\FISH_COMMON_CODE\FISH_RM_MSGS.h"
 5886                           
 5887                           // SYSTEMCLOCK #define set in FISH_M0_EQUATES.s for SYSCLOCK value.
 5888                           // THIS IS A :NONAME WORDSET
 5889                           
 5890                           #if     NXP_M0_11xx | NXP_M0_1115
 5891                           $FISH_NXP_M0_11xx_SOC_INIT.s
    1                           //      FISH_NXP_M0_11xx_SOC_INIT.s
    2                           
    3                           //HEADERLESS SoCinit:        ( -- ) Initialize main SoC subsystems here.
    4                           //      Use of IRC, external xtal's and PLL done here.
    5                           //      Derive maximum SYSCLOCK frequiency possible.
    6                           //      Initialize FISH SYSCLK to system clock frequency in Hz. Used By UARTx_INIT.
    7                           //      Initialize SYSTICK, and others under #define control
    8                           
    9                            SECTION .text : CONST (2)
   10                           SoCinit:
   11    00000000 ........        DC32  DOCOL
   12                           // SYSTICK SECTION: (SysTick uses the processor clock.)
   13                           // UM10398 - Chapter 24: LPC111x/LPC11Cxx System tick timer (SysTick)
   14                           // SYST_RVR (Reload value) is set to not set until user does with MS or DELAY.
   15                           
   16                           // While testing Hilevel ISR
   17                           #if 1
   18                           // Clear the SYST_CVR register by writing to it. 
   19                           // This ensures that the timer will count from the SYST_RVR value
   20                           // rather than an arbitrary value when the timer is enabled.
   21    00000004 ........00000  DC32   STRVA, 0, SYST_RVR
                  00014E000E0  
   22    00000010 ........00000  DC32   STRVA, 0, SYST_CVR
                  00018E000E0  
   23                           #else
   25                           #endif
   26                           
   27                           // SYSTICK TIMER ENABLE: Bit 0 = 1
   28                           // SYSTICK CLKSOURCE: Bit 2 = 0 (SYSTEM CLOCK/2)
   29                           // SYSTICK CLKSOURCE: Bit 2 = 1 (SYSTEM CLOCK)
   30                           //  DC32    STRVA, 1, SYSTICKCSR    // SYSCLK/2
   31                           //  DC32    STRVA, 5, SYST_CSR    // SYSCLK
   32    0000001C ........07000   DC32    STRVA, 7, SYST_CSR    // SYSCLK + SYSTICK interrupt for FISH STCTR
                  00010E000E0  
   33                             
   34                           #ifdef SLOW_POWERUP
   37                           #endif
   38                           
   39                           // SYSAHBCLKCTRL, address 0x40048080h can disable uartclks.
   40                           // 1185fh = IOCON, UART, (?SPIO0) GPIO & SYS ROM RAM FLASH
   41    00000028 ........5F180   DC32  STRVA, 1185Fh, SYSAHBCLKCTRL    // enable pwr
                  10080800440  
   42                           
   43                           // UART FLOW CONTROL SECTION:
   44                           // Default when XON_XOFF and CTS_RTS not defined
   45                           //  DC32    STRVA, 0x00000004, PINASSIGN0     // Order = RTS/CTS RX/TX CTS/RTS OFF
   46                           #ifdef XON_XOFF
   47                           // Asign CTS signal pin vs GPIO usage
   48                           //  DC32    STRVA, 0x00090004, PINASSIGN0 // Order = RTS/CTS RX/TX CTS = INPUT
   49                           // Set RTS (bit 14 = 0x2000) to OUTPUT and CTS (bit 9 = 0x200) to INPUT
   50                           // GPIO usage of RTS pin, which if assined as RTS signal which enables it.
   51                           //  DC32    STRVA, 0x2000, DIR0     // RTS_PIN_14 0= IN 0x2000 = OUT
   52                           // Set RTS Low
   53                           //  DC32    STRVA,  0x00, PIN0      // RTS HI/LOW IF OUTPUT
   54                           #endif
   55                           
   56                           #ifdef CTS_RTS
   59                           #endif
   60                           
   61                           #ifdef NXP_M0_11xx_IRC12_48MHZ
   62                           // Voltages should be stable now - proceed to init.
   63    00000034 ........70ED0   DC32  STRVA, 0ED70h, PDRUNCFG         // power-up PLL
                  00038820440  
   64                           
   65                           // CHOOSE CLOCK TO FEED PLL
   66                           // 0=irc, 1=sysclk, 2=wdt, 3=mainclock
   67    00000040 ........00000   DC32  STRVA, 0, SYSPLLCLKSEL  // 12MHz IRC
                  00040800440  
   68                           // Tickle Update Register
   69    0000004C ........00000   DC32  STRVA, 0, SYSPLLCLKUEN
                  00044800440  
   70    00000058 ........01000   DC32  STRVA, 1, SYSPLLCLKUEN
                  00044800440  
   71                           
   72                           // SET PLL MULTIPLY AND DIVIDE IF NEEDED AND SET SYSCLOCK
   73    00000064 ........03000   DC32  STRVA, 3h, SYSPLLCTRL   // pll 12MHz*4 = 48MHz
                  00008800440  
   74                           Hz_48000000:
   75                           _wPLLlock
   76    00000070 ........0C800   DC32  LIT,SYSPLLSTAT,AT,ONE,ANDD,ZBRAN
                  440..........
                  .............
                  .........    
   77    00000088 E8FFFFFF        DC32  (_wPLLlock - .)
   78                           
   79                           // 0=irc, 1=sysclk, 2=wdt, 3=mainclock
   80    0000008C ........03000   DC32  STRVA, 3, MAINCLKSEL    // select PLL driven clock
                  00070800440  
   81                           // Tickle Update Register
   82    00000098 ........00000   DC32  STRVA, 0, MAINCLKUEN
                  00074800440  
   83    000000A4 ........01000   DC32  STRVA, 1, MAINCLKUEN
                  00074800440  
   84                           #endif  // NXP_M0_11xx_IRC12_48MHZ
   85                           
   86                           // Set SYSCLOCK = SYSTEMCLOCK defined in FISH_M0_EQUATES.s
   87                           // And set in Project Configuration ex: NXP_M0_81x_IRC12_24MHZ
   88                           // in Assembler -> Preprocessor -> Defined Symbols
   89    000000B0 ........006CD   DC32  STRVA, SYSTEMCLOCK, SYSCLOCK    // 
                  C02........  
   90                           
   91                           #ifdef CLKOUT
  100                           #endif
  101                           
  102                           // Debug SERIAL POWER UP ISSUE:
  103                           // Change TXD and RXD to a known state instead of power up tri-state.
  104                           //  DC32  STRVA, 8, IOCON_PIO1_6        // P1.6 RX I/O PULL DOWN
  105                           //  DC32  STRVA, 8, IOCON_PIO1_7  // P1.7 TX I/O PULL DOWN
  106    000000BC ........        DC32  SEMIS
 5892                           #endif  // NXP_M0_11xx
 5893                           
 5894                           #ifdef NXP_M0_812
 5896                           #endif  // NXP_M0_812
 5897                           
 5898                            END


\n                   DELIMITER 
                     DELIMITER 
!                    OPERATOR 
!=                   OPERATOR 
%                    OPERATOR 
&                    OPERATOR 
&&                   OPERATOR 
(                    OPERATOR 
(                    DELIMITER 
)                    OPERATOR 
)                    DELIMITER 
*                    OPERATOR 
+                    OPERATOR 
,                    DELIMITER 
-                    OPERATOR 
.                    Target symbol: 24 
/                    OPERATOR 
/                    DELIMITER 
:                    Target symbol: 22 
:                    DELIMITER 
;                    Target symbol: 23 
<                    OPERATOR 
<<                   OPERATOR 
<=                   OPERATOR 
<>                   OPERATOR 
=                    OPERATOR 
=                    DIRECTIVE 
==                   OPERATOR 
>                    OPERATOR 
>=                   OPERATOR 
>>                   OPERATOR 
@                    DELIMITER 
AAPCS                DIRECTIVE 
ABORT_STOP_TILL_CO   #define, value: , line:       7:7  
ALIAS                DIRECTIVE 
ALIGN                DIRECTIVE 
ALIGNRAM             DIRECTIVE 
ALIGNROM             DIRECTIVE 
ANOTE                DIRECTIVE 
ARGFRAME             DIRECTIVE 
ARM                  DIRECTIVE 
ASEGN                DIRECTIVE 
ASR                  MNEMONIC 
BIT                  SEGMENT TYPE 
BYTE1                OPERATOR 
BYTE2                OPERATOR 
BYTE3                OPERATOR 
BYTE4                OPERATOR 
C0                   REGISTER 
C1                   REGISTER 
C10                  REGISTER 
C11                  REGISTER 
C12                  REGISTER 
C13                  REGISTER 
C14                  REGISTER 
C15                  REGISTER 
C2                   REGISTER 
C3                   REGISTER 
C4                   REGISTER 
C5                   REGISTER 
C6                   REGISTER 
C7                   REGISTER 
C8                   REGISTER 
C9                   REGISTER 
CALL_GRAPH_ROOT      DIRECTIVE 
CASEOFF              DIRECTIVE 
CASEON               DIRECTIVE 
CBREL                OPERATOR 
CBREL_NEAR           OPERATOR 
CFI                  DIRECTIVE 
CODE                 SEGMENT TYPE 
CODE                 DIRECTIVE 
CODE16               DIRECTIVE 
CODE32               DIRECTIVE 
COL                  DIRECTIVE 
CONST                SEGMENT TYPE 
DATA                 SEGMENT TYPE 
DATA                 DIRECTIVE 
DATE                 OPERATOR 
DBAUD                #define, value: ALL_UNINITRAM_START, line:     129:8      146:8    24:10    21:13     4455
DC16                 DIRECTIVE 
DC24                 DIRECTIVE 
DC32                 DIRECTIVE 
DC8                  DIRECTIVE 
DCB                  DIRECTIVE 
DCD                  DIRECTIVE 
DCREL32              DIRECTIVE 
DCW                  DIRECTIVE 
DEFINE               DIRECTIVE 
DF32                 DIRECTIVE 
DF64                 DIRECTIVE 
DPUSH                MACRO 
DS16                 DIRECTIVE 
DS24                 DIRECTIVE 
DS32                 DIRECTIVE 
DS8                  DIRECTIVE 
ELSE                 DIRECTIVE 
ELSEIF               DIRECTIVE 
END                  DIRECTIVE 
ENDIF                DIRECTIVE 
ENDM                 DIRECTIVE 
ENDMOD               DIRECTIVE 
ENDR                 DIRECTIVE 
EOL_DLE              #define, value: , line:       8:7      482:9
EOL_NAK              #define, value: , line:       9:7  
EQU                  DIRECTIVE 
EVEN                 DIRECTIVE 
EXCEPTION_CODE       DIRECTIVE 
EXITM                DIRECTIVE 
EXPORT               DIRECTIVE 
EXTERN               DIRECTIVE 
EXTWEAK              DIRECTIVE 
FAR                  SEGMENT TYPE 
FARCODE              SEGMENT TYPE 
FARCONST             SEGMENT TYPE 
FARDATA              SEGMENT TYPE 
FISH_Debug_WORDSET   Target symbol: 0 
FISH_PubRel_WORDSET  #define, value: 1, line:         0         85
FISH_STM32F4_Peripheral_Register_ADDRS
                     #define, value: , line:       4:7  
FUNCALL              DIRECTIVE 
FUNCTION             DIRECTIVE 
HIGH                 OPERATOR 
HUGE                 SEGMENT TYPE 
HUGECODE             SEGMENT TYPE 
HUGECONST            SEGMENT TYPE 
HUGEDATA             SEGMENT TYPE 
HWRD                 OPERATOR 
IDATA                SEGMENT TYPE 
IF                   DIRECTIVE 
IMPORT               DIRECTIVE 
INCLUDE              DIRECTIVE 
LIBRARY              DIRECTIVE 
LIT2t                MACRO 
LOCAL                DIRECTIVE 
LOCFRAME             DIRECTIVE 
LOW                  OPERATOR 
LR                   REGISTER 
LSL                  MNEMONIC 
LSR                  MNEMONIC 
LSTCND               DIRECTIVE 
LSTCOD               DIRECTIVE 
LSTEXP               DIRECTIVE 
LSTMAC               DIRECTIVE 
LSTOUT               DIRECTIVE 
LSTPAG               DIRECTIVE 
LSTREP               DIRECTIVE 
LSTXRF               DIRECTIVE 
LTORG                DIRECTIVE 
LWRD                 OPERATOR 
MACRO                DIRECTIVE 
MODULE               DIRECTIVE 
NAME                 DIRECTIVE 
NDPOP2t              MACRO 
NDPOP2w              MACRO 
NDPOP2x              MACRO 
NEAR                 SEGMENT TYPE 
NEARCODE             SEGMENT TYPE 
NEARCONST            SEGMENT TYPE 
NEARDATA             SEGMENT TYPE 
NEXT                 MACRO 
NEXT1                MACRO 
NOALLOC              SEGMENT TYPE 
NOCALL               DIRECTIVE 
NOROOT               SEGMENT TYPE 
NPAGE                SEGMENT TYPE 
NXP_M0_004kRam       #define, value: 1, line:         0         73
NXP_M0_008kRam       Target symbol: 0 
NXP_M0_032kFlash_4KWrite #define, value: 1, line:         0     235:14   267:14
NXP_M0_064kFlash_4KWrite Target symbol: 0 
NXP_M0_1115          Target symbol: 0 
NXP_M0_11xx          #define, value: 1, line:         0         73       76      184      195
                                                                      211      229     4429     4495
                                                                     4517     4535     4774     4839
                                                                     4884     5890
NXP_M0_11xx_IRC12_48MHZ #define, value: 1, line:         0  
ODD                  DIRECTIVE 
P0                   REGISTER 
P1                   REGISTER 
P10                  REGISTER 
P11                  REGISTER 
P12                  REGISTER 
P13                  REGISTER 
P14                  REGISTER 
P15                  REGISTER 
P2                   REGISTER 
P3                   REGISTER 
P4                   REGISTER 
P5                   REGISTER 
P6                   REGISTER 
P7                   REGISTER 
P8                   REGISTER 
P9                   REGISTER 
PAGE                 DIRECTIVE 
PAGSIZ               DIRECTIVE 
PC                   REGISTER 
POP2i                MACRO 
POP2n                MACRO 
POP2t                MACRO 
POP2w                MACRO 
POP2x                MACRO 
POPp2w               MACRO 
POPr2i               MACRO 
POPr2t               MACRO 
PRESERVE8            DIRECTIVE 
PROGRAM              DIRECTIVE 
PUBLIC               DIRECTIVE 
PUBWEAK              DIRECTIVE 
PUSHi                MACRO 
PUSHi2r              MACRO 
PUSHn                MACRO 
PUSHn2r              MACRO 
PUSHt                MACRO 
PUSHt2r              MACRO 
PUSHw                MACRO 
PUSHw2r              MACRO 
PUSHx                MACRO 
R0                   REGISTER 
R1                   REGISTER 
R10                  REGISTER 
R11                  REGISTER 
R12                  REGISTER 
R13                  REGISTER 
R14                  REGISTER 
R15                  REGISTER 
R2                   REGISTER 
R3                   REGISTER 
R4                   REGISTER 
R5                   REGISTER 
R6                   REGISTER 
R7                   REGISTER 
R8                   REGISTER 
R9                   REGISTER 
RADIX                DIRECTIVE 
REGISTER             SEGMENT TYPE 
RELOC_ARM_PREL31     OPERATOR 
RELOC_ARM_TARGET1    OPERATOR 
RELOC_ARM_TARGET2    OPERATOR 
RELOC_LOCAL          OPERATOR 
REORDER              SEGMENT TYPE 
REPT                 DIRECTIVE 
REPTC                DIRECTIVE 
REPTI                DIRECTIVE 
REQUIRE              DIRECTIVE 
REQUIRE8             DIRECTIVE 
ROOT                 SEGMENT TYPE 
ROR                  MNEMONIC 
RRX                  MNEMONIC 
RSEG                 DIRECTIVE 
RTMODEL              DIRECTIVE 
SBREL                OPERATOR 
SBREL_NEAR           OPERATOR 
SECTION              DIRECTIVE 
SECTION_GROUP        DIRECTIVE 
SECTION_LINK         DIRECTIVE 
SECTION_TYPE         DIRECTIVE 
SET                  DIRECTIVE 
SETA                 DIRECTIVE 
SFB                  OPERATOR 
SFE                  OPERATOR 
SFS                  OPERATOR 
SIZEOF               OPERATOR 
SORT                 SEGMENT TYPE 
SP                   REGISTER 
THUMB                DIRECTIVE 
THUMBX               DIRECTIVE 
TLS                  SEGMENT TYPE 
TLS                  OPERATOR 
TPUSH                MACRO 
TRUE_EQU_NEG_ONE     #define, value: , line:       5:7  
UBAUD                #define, value: ALL_UNINITRAM_START+4, line:     130:8      147:8    24:13     4456
UGT                  OPERATOR 
ULT                  OPERATOR 
UNTYPED              SEGMENT TYPE 
VAR                  DIRECTIVE 
XDATA                SEGMENT TYPE 
XON_XOFF             #define, value: , line:       6:7  
XOR                  OPERATOR 
ZPAGE                SEGMENT TYPE 
[                    DELIMITER 
]                    DELIMITER 
^                    OPERATOR 
^                    DELIMITER 
__ARM4TM__           #define, value: 4, line:         0  
__ARM5TM__           #define, value: 5, line:         0  
__ARM5T__            #define, value: 5, line:         0  
__ARM5__             #define, value: 5, line:         0  
__ARM6M__            #define, value: 11, line:         0  
__ARM6SM__           #define, value: 12, line:         0  
__ARM6__             #define, value: 6, line:         0  
__ARM_ARCH           #define, value: 6, line:         0  
__ARM_ARCH_ISA_THUMB #define, value: 1, line:         0  
__ARM_ARCH_PROFILE   #define, value: 'M', line:         0  
__ARM_BIG_ENDIAN     #define, value: 0, line:         0  
__ARM_FEATURE_DSP    #define, value: 0, line:         0  
__ARM_FEATURE_IDIV   #define, value: 0, line:         0  
__ARM_PROFILE_M__    #define, value: 1, line:         0  
__BUILD_NUMBER__     #define,            line:         0  
__CORE__             #define, value: __ARM6M__, line:         0  
__DATE__             #define,            line:         0        106
__FILE__             #define,            line:         0  
__IAR_SYSTEMS_ASM    #define,            line:         0  
__IAR_SYSTEMS_ASM__  #define,            line:         0  
__IASMARM__          #define, value: 1, line:         0  
__LINE__             #define,            line:         0  
__LITTLE_ENDIAN__    #define, value: 1, line:         0  
__SUBVERSION__       #define,            line:         0  
__TID__              #define,            line:         0  
__TIME__             #define,            line:         0        109
__VER__              #define,            line:         0  
comma_test           #define, value: , line:       987  
define               PREPROCESSOR DIRECTIVE 
defined              Target symbol: 0 
elif                 PREPROCESSOR DIRECTIVE 
else                 PREPROCESSOR DIRECTIVE 
endif                PREPROCESSOR DIRECTIVE 
error                PREPROCESSOR DIRECTIVE 
i                    #define, value: r5, line:      20:5      654:9    661:9    662:9    663:9
                                                                    674:9    675:9    684:9    691:9
                                                                    704:9    706:9    715:9    717:9
                                                                    730:9    731:9    747:9    749:9
                                                                    753:9    765:9    778:9    849:9
                                                                    884:9    898:9    899:9    899:9
                                                                    900:9    919:9    919:9    920:9
                                                                    946:9    946:9    947:9    979:9
                                                                    991:9   1023:9   1039:9   1075:9
                                                                   1119:9   1125:9   1141:9   1163:9
                                                                   1189:9   1195:9   1205:9   1216:9
                                                                   1228:9   1240:9   1250:9   1251:9
                                                                   1253:9    50:10    51:10    52:10
                                                                   160:10      144      145      260
                                                                      262      502      667      686
                                                                      832      837      889      906
                                                                      923      924     1376     1698
                                                                     1745     1763     1783     1803
                                                                     1825     1843     1859     1881
                                                                     1906     1931     1955     1977
                                                                     2010     2032     2054     2097
                                                                     2128     2187     2211     2230
                                                                     2248     2267     3262     3349
                                                                     3373     3390     3407     3424
                                                                     3441     3458     3475     3492
                                                                     3737     3757     3779     3787
                                                                     3822     3897     3931     3999
                                                                     4079     4098     4116     4135
                                                                     4153     4171     4189     4209
                                                                     4229     4249     4502     4561
                                                                     4584     4786     4857     4902
                                                                     4907     4986     5002     5023
                                                                     5044   119:14   248:14   282:14
                                                                   313:14     5398     5457     5665
if                   PREPROCESSOR DIRECTIVE 
ifdef                PREPROCESSOR DIRECTIVE 
ifndef               PREPROCESSOR DIRECTIVE 
include              PREPROCESSOR DIRECTIVE 
k                    #define, value: r12, line:      29:5      812:9    848:9   1227:9   1238:9
line                 PREPROCESSOR DIRECTIVE 
message              PREPROCESSOR DIRECTIVE 
n                    #define, value: r1, line:      16:5      645:9    649:9    651:9    762:9
                                                                    763:9    763:9    764:9    775:9
                                                                    776:9    776:9    777:9    813:9
                                                                    814:9    825:9    826:9    831:9
                                                                    989:9    990:9   1004:9   1013:9
                                                                   1034:9   1037:9   1054:9   1055:9
                                                                   1065:9   1066:9   1093:9   1094:9
                                                                   1097:9   1101:9   1101:9   1102:9
                                                                   1138:9   1152:9   1162:9   1226:9
                                                                   1227:9   1238:9   1239:9   1250:9
                                                                   1252:9    22:10    26:10    36:10
                                                                      193      196      196      212
                                                                      219      230      238      500
                                                                      501      865      868      868
                                                                      873      873      875      893
                                                                      893      895     1369     1370
                                                                     1370     1739     1744     1876
                                                                     1877     2006     2007     2009
                                                                     2028     2029     2031     2050
                                                                     2051     2053     2073     2076
                                                                     2086     2086     2087     2114
                                                                     2116     2118     2179     2184
                                                                     2186     2209     2210     2228
                                                                     2229     2246     2247     2265
                                                                     2266     3344     3347     3735
                                                                     3736     3755     3756     3775
                                                                     3777     3777     3815     3817
                                                                     3886     3887     3918     3926
                                                                     3926     3926     4077     4078
                                                                     4096     4097     4133     4134
                                                                     4496     4501     4775     4781
                                                                     4782     4783     4785     4852
                                                                     4853     4853     4890     4892
                                                                     4892     5020     5022     5041
                                                                     5043   230:14   262:14   296:14
                                                                     5396     5397     5426     5435
                                                                     5439     5449     5450     5452
                                                                     5453     5648     5654     5656
                                                                     5657     5659     5661     5662
                                                                     5664
p                    #define, value: r7, line:      22:5      684:9    684:9    684:9    691:9
                                                                    691:9    691:9    706:9    706:9
                                                                    706:9    717:9    717:9    717:9
                                                                    730:9    730:9    730:9    752:9
                                                                    752:9    752:9    765:9    765:9
                                                                    765:9    778:9    778:9    778:9
                                                                    798:9    798:9    798:9    799:9
                                                                    799:9    799:9    846:9    846:9
                                                                    846:9    849:9    849:9    849:9
                                                                    849:9    849:9    849:9    884:9
                                                                    884:9    884:9    912:9    912:9
                                                                    912:9    957:9    957:9    957:9
                                                                    972:9    972:9    972:9    973:9
                                                                    973:9    973:9    987:9    987:9
                                                                    987:9    991:9    991:9    991:9
                                                                   1004:9   1004:9   1004:9   1023:9
                                                                   1023:9   1023:9   1034:9   1034:9
                                                                   1034:9   1035:9   1035:9   1035:9
                                                                   1059:9   1059:9   1059:9   1061:9
                                                                   1061:9   1061:9   1092:9   1151:9
                                                                   1151:9   1151:9   1152:9   1152:9
                                                                   1152:9   1163:9   1163:9   1163:9
                                                                   1163:9   1163:9   1163:9   1177:9
                                                                   1177:9   1177:9   1178:9   1178:9
                                                                   1178:9   1179:9   1179:9   1179:9
                                                                   1189:9   1189:9   1189:9   1189:9
                                                                   1189:9   1189:9   1195:9   1195:9
                                                                   1195:9   1195:9   1195:9   1195:9
                                                                   1204:9    48:10      175      262
                                                                      262      262      498      498
                                                                      498      502      502      502
                                                                      665      665      665      667
                                                                      667      667      684      684
                                                                      684      686      686      686
                                                                      813      813      813      814
                                                                      814      814      832      832
                                                                      832      832      832      832
                                                                      837      837      837      864
                                                                      864      864      865      878
                                                                      878      878      889      889
                                                                      889      889      889      889
                                                                      906      906      906      906
                                                                      906      906     1365     1376
                                                                     1376     1376     1696     1697
                                                                     1698     1698     1698     1698
                                                                     1698     1698     1738     1738
                                                                     1738     1739     1739     1739
                                                                     1743     1743     1743     1744
                                                                     1744     1744     1745     1745
                                                                     1745     1745     1745     1745
                                                                     1763     1763     1763     1782
                                                                     1783     1783     1783     1803
                                                                     1803     1803     1843     1843
                                                                     1843     1859     1859     1859
                                                                     1876     1876     1876     1897
                                                                     1897     1897     1903     1903
                                                                     1903     1905     1905     1905
                                                                     1906     1906     1906     1906
                                                                     1906     1906     1928     1928
                                                                     1952     1952     1952     1953
                                                                     1953     1953     1955     1955
                                                                     1955     1955     1955     1955
                                                                     1975     1977     1977     1977
                                                                     2005     2006     2006     2006
                                                                     2027     2028     2028     2028
                                                                     2049     2050     2050     2050
                                                                     2073     2073     2073     2074
                                                                     2074     2074     2075     2075
                                                                     2075     2113     2113     2113
                                                                     2114     2114     2114     2115
                                                                     2115     2115     2179     2179
                                                                     2179     2183     2183     2183
                                                                     2209     2209     2209     2211
                                                                     2211     2211     2228     2228
                                                                     2228     2230     2230     2230
                                                                     2245     2245     2245     2246
                                                                     2246     2246     2264     2264
                                                                     2264     2265     2265     2265
                                                                     3257     3257     3257     3258
                                                                     3258     3258     3262     3262
                                                                     3262     3262     3262     3262
                                                                     3343     3343     3343     3344
                                                                     3344     3344     3345     3345
                                                                     3345     3346     3346     3346
                                                                     3349     3349     3349     3349
                                                                     3349     3349     3366     3366
                                                                     3366     3373     3373     3373
                                                                     3373     3373     3373     3388
                                                                     3388     3388     3390     3390
                                                                     3390     3405     3405     3405
                                                                     3407     3407     3407     3422
                                                                     3422     3422     3424     3424
                                                                     3424     3439     3439     3439
                                                                     3441     3441     3441     3456
                                                                     3456     3456     3458     3458
                                                                     3458     3473     3473     3473
                                                                     3475     3475     3475     3490
                                                                     3490     3490     3492     3492
                                                                     3492     3734     3734     3734
                                                                     3735     3735     3735     3737
                                                                     3737     3737     3754     3754
                                                                     3754     3755     3755     3755
                                                                     3757     3757     3757     3775
                                                                     3775     3775     3776     3776
                                                                     3776     3779     3779     3779
                                                                     3787     3787     3787     3815
                                                                     3815     3815     3816     3816
                                                                     3816     3822     3822     3822
                                                                     3886     3886     3886     3897
                                                                     3897     3897     3918     3918
                                                                     3918     3931     3931     3931
                                                                     3996     3996     3996     3999
                                                                     3999     3999     4076     4076
                                                                     4076     4077     4077     4077
                                                                     4079     4079     4079     4095
                                                                     4095     4095     4096     4096
                                                                     4096     4098     4098     4098
                                                                     4114     4114     4114     4116
                                                                     4116     4116     4132     4132
                                                                     4132     4133     4133     4133
                                                                     4135     4135     4135     4151
                                                                     4151     4151     4153     4153
                                                                     4153     4169     4169     4169
                                                                     4171     4171     4171     4187
                                                                     4187     4187     4189     4189
                                                                     4189     4206     4206     4206
                                                                     4207     4207     4207     4209
                                                                     4209     4209     4226     4226
                                                                     4226     4227     4227     4227
                                                                     4229     4229     4229     4246
                                                                     4246     4246     4247     4247
                                                                     4247     4249     4249     4249
                                                                     4502     4502     4502     4772
                                                                     4772     4772     4857     4857
                                                                     4857     4902     4902     4902
                                                                     4907     4907     4907   113:14
                                                                   113:14   113:14   119:14   119:14
                                                                   119:14     5398     5398     5398
                                                                     5426     5426     5426     5427
                                                                     5427     5427
pFunc_t              Target symbol: 0 
pfRAMVectors         #define, value: ((pFunc_t *)0x10000000), line:      89:3  
pragma               PREPROCESSOR DIRECTIVE 
r                    #define, value: r6, line:      21:5      661:9    661:9    661:9    674:9
                                                                    674:9    674:9    747:9    747:9
                                                                    747:9    934:9    935:9    940:9
                                                                    945:9    945:9    974:9    974:9
                                                                    974:9    975:9    975:9    975:9
                                                                   1215:9    49:10    51:10    51:10
                                                                    51:10   160:10   160:10   160:10
                                                                      923      923      923     1762
                                                                     1802     1823     1824     1842
                                                                     1842     1842     1858     1877
                                                                     1877     1877
r0                   Target symbol: 0 
r1                   Target symbol: 0 
r10                  Target symbol: 0 
r11                  Target symbol: 0 
r12                  Target symbol: 0 
r2                   Target symbol: 0 
r3                   Target symbol: 0 
r4                   Target symbol: 0 
r5                   Target symbol: 0 
r6                   Target symbol: 0 
r7                   Target symbol: 0 
ra                   #define, value: r10, line:      27:5     1006:9   1020:9
rb                   #define, value: r11, line:      28:5      800:9    806:9
t                    #define, value: r0, line:      15:5      644:9    648:9    650:9    683:9
                                                                    684:9    690:9    691:9    704:9
                                                                    706:9    715:9    717:9    749:9
                                                                    751:9    751:9    752:9    761:9
                                                                    764:9    764:9    765:9    774:9
                                                                    777:9    777:9    778:9    807:9
                                                                    812:9    814:9    814:9    816:9
                                                                    824:9    826:9    830:9    830:9
                                                                    831:9    839:9    840:9    847:9
                                                                    849:9    861:9    863:9    872:9
                                                                    873:9    883:9    884:9    912:9
                                                                    913:9    972:9    975:9    987:9
                                                                    988:9    988:9    990:9    990:9
                                                                    991:9   1011:9   1013:9   1016:9
                                                                   1023:9   1036:9   1037:9   1037:9
                                                                   1038:9   1055:9   1059:9   1060:9
                                                                   1061:9   1066:9   1092:9   1093:9
                                                                   1101:9   1122:9   1151:9   1161:9
                                                                   1162:9   1163:9   1177:9   1180:9
                                                                   1189:9   1192:9   1192:9   1193:9
                                                                   1193:9   1194:9   1195:9    23:10
                                                                    26:10    27:10    27:10    28:10
                                                                    33:10    36:10    37:10    37:10
                                                                    38:10      261      262      498
                                                                      499      499      501      501
                                                                      502      665      666      666
                                                                      667      684      685      685
                                                                      686      814      815      815
                                                                      818      822      822      823
                                                                      827      830      831      832
                                                                      836      837      864      876
                                                                      887      889      896      904
                                                                      905      905      906     1366
                                                                     1366     1369     1372     1372
                                                                     1376     1696     1698     1743
                                                                     1745     1762     1763     1782
                                                                     1783     1802     1803     1842
                                                                     1843     1858     1859     1903
                                                                     1905     1906     1953     1955
                                                                     1975     1977     2007     2008
                                                                     2008     2009     2029     2030
                                                                     2030     2031     2051     2052
                                                                     2052     2053     2084     2085
                                                                     2113     2120     2183     2185
                                                                     2185     2186     2210     2211
                                                                     2229     2230     2245     2247
                                                                     2264     2266     3257     3259
                                                                     3259     3262     3343     3348
                                                                     3348     3349     3367     3367
                                                                     3371     3371     3373     3388
                                                                     3389     3389     3390     3405
                                                                     3406     3406     3407     3422
                                                                     3423     3423     3424     3439
                                                                     3440     3440     3441     3456
                                                                     3457     3457     3458     3473
                                                                     3474     3474     3475     3490
                                                                     3491     3491     3492     3734
                                                                     3736     3736     3737     3754
                                                                     3756     3756     3757     3773
                                                                     3773     3779     3783     3787
                                                                     3810     3810     3811     3820
                                                                     3820     3822     3885     3885
                                                                     3891     3891     3897     3921
                                                                     3921     3922     3929     3929
                                                                     3931     3996     3997     3997
                                                                     3998     3998     3999     4076
                                                                     4078     4078     4079     4095
                                                                     4097     4097     4098     4114
                                                                     4115     4115     4116     4132
                                                                     4134     4134     4135     4151
                                                                     4152     4152     4153     4169
                                                                     4170     4170     4171     4187
                                                                     4188     4188     4189     4207
                                                                     4208     4208     4209     4227
                                                                     4228     4228     4229     4247
                                                                     4248     4248     4249     4501
                                                                     4502     4772     4781     4783
                                                                     4784     4784     4785     4856
                                                                     4857     4897     4897     4898
                                                                     4902     4906     4906     4907
                                                                     5021     5022     5042     5043
                                                                   113:14   115:14   115:14   118:14
                                                                   118:14   119:14   229:14   232:14
                                                                   241:14   242:14   261:14   264:14
                                                                   273:14   274:14   276:14   295:14
                                                                   298:14   301:14   303:14   305:14
                                                                   307:14     5397     5398     5427
                                                                     5430     5430     5431     5431
                                                                     5432     5441     5448     5456
undef                PREPROCESSOR DIRECTIVE 
w                    #define, value: r2, line:      17:5      646:9    652:9    654:9    654:9
                                                                    662:9    663:9    663:9    675:9
                                                                    675:9    683:9    684:9    684:9
                                                                    690:9    691:9    691:9    706:9
                                                                    706:9    717:9    717:9    731:9
                                                                    731:9    753:9    753:9    765:9
                                                                    765:9    778:9    778:9    799:9
                                                                    800:9    806:9    813:9    822:9
                                                                    822:9    825:9    848:9    849:9
                                                                    849:9    849:9    884:9    884:9
                                                                    900:9    900:9    920:9    920:9
                                                                    935:9    936:9    939:9    939:9
                                                                    940:9    941:9    947:9    947:9
                                                                    973:9    974:9    979:9    979:9
                                                                    991:9    991:9   1005:9   1006:9
                                                                   1009:9   1009:9   1011:9   1012:9
                                                                   1021:9   1021:9   1022:9   1023:9
                                                                   1023:9   1035:9   1036:9   1038:9
                                                                   1039:9   1039:9   1075:9   1075:9
                                                                   1102:9   1103:9   1105:9   1108:9
                                                                   1110:9   1113:9   1115:9   1119:9
                                                                   1119:9   1122:9   1123:9   1125:9
                                                                   1125:9   1137:9   1138:9   1139:9
                                                                   1140:9   1141:9   1141:9   1161:9
                                                                   1163:9   1163:9   1163:9   1179:9
                                                                   1189:9   1189:9   1189:9   1194:9
                                                                   1195:9   1195:9   1195:9   1203:9
                                                                   1204:9   1205:9   1205:9   1214:9
                                                                   1215:9   1216:9   1216:9   1225:9
                                                                   1226:9   1228:9   1228:9   1237:9
                                                                   1239:9   1240:9   1240:9   1251:9
                                                                   1252:9   1253:9   1253:9    52:10
                                                                    52:10    82:10   149:10   150:10
                                                                      145      145      175      176
                                                                      182      203      209      220
                                                                      227      239      262      262
                                                                      502      502      667      667
                                                                      686      686      813      827
                                                                      830      832      832      832
                                                                      837      837      866      867
                                                                      867      874      874      878
                                                                      888      888      889      889
                                                                      889      894      894      904
                                                                      906      906      906      924
                                                                      924     1365     1369     1376
                                                                     1376     1697     1698     1698
                                                                     1698     1738     1745     1745
                                                                     1745     1763     1763     1783
                                                                     1783     1803     1803     1823
                                                                     1824     1825     1825     1843
                                                                     1843     1859     1859     1881
                                                                     1881     1897     1906     1906
                                                                     1906     1931     1931     1952
                                                                     1955     1955     1955     1977
                                                                     1977     2005     2008     2010
                                                                     2010     2027     2030     2032
                                                                     2032     2049     2052     2054
                                                                     2054     2074     2085     2090
                                                                     2090     2097     2097     2115
                                                                     2118     2120     2121     2121
                                                                     2122     2128     2128     2184
                                                                     2185     2187     2187     2211
                                                                     2211     2230     2230     2248
                                                                     2248     2267     2267     3258
                                                                     3260     3260     3261     3261
                                                                     3262     3262     3262     3346
                                                                     3347     3347     3349     3349
                                                                     3349     3366     3368     3368
                                                                     3368     3373     3373     3373
                                                                     3390     3390     3407     3407
                                                                     3424     3424     3441     3441
                                                                     3458     3458     3475     3475
                                                                     3492     3492     3737     3737
                                                                     3757     3757     3776     3777
                                                                     3779     3779     3787     3787
                                                                     3816     3817     3822     3822
                                                                     3897     3897     3931     3931
                                                                     3999     3999     4079     4079
                                                                     4098     4098     4116     4116
                                                                     4135     4135     4153     4153
                                                                     4171     4171     4189     4189
                                                                     4206     4208     4209     4209
                                                                     4226     4228     4229     4229
                                                                     4246     4248     4249     4249
                                                                     4502     4502     4561     4561
                                                                     4584     4584     4786     4786
                                                                     4840     4856     4857     4857
                                                                     4902     4902     4907     4907
                                                                     4986     4986     5002     5002
                                                                     5023     5023     5044     5044
                                                                   114:14   115:14   116:14   117:14
                                                                   117:14   118:14   119:14   119:14
                                                                   231:14   232:14   234:14   236:14
                                                                   236:14   241:14   242:14   248:14
                                                                   248:14   263:14   264:14   266:14
                                                                   268:14   268:14   273:14   274:14
                                                                   275:14   276:14   282:14   282:14
                                                                   297:14   298:14   299:14   300:14
                                                                   300:14   301:14   302:14   303:14
                                                                   304:14   305:14   306:14   307:14
                                                                   313:14   313:14     5398     5398
                                                                     5434     5435     5437     5439
                                                                     5447     5448     5450     5456
                                                                     5457     5457     5665     5665
x                    #define, value: r3, line:      18:5      648:9    649:9    654:9    654:9
                                                                    663:9    663:9    675:9    675:9
                                                                    684:9    684:9    691:9    691:9
                                                                    706:9    706:9    717:9    717:9
                                                                    731:9    731:9    753:9    753:9
                                                                    765:9    765:9    778:9    778:9
                                                                    798:9    807:9    823:9    823:9
                                                                    824:9    838:9    838:9    839:9
                                                                    845:9    845:9    846:9    849:9
                                                                    849:9    857:9    857:9    861:9
                                                                    871:9    871:9    873:9    873:9
                                                                    874:9    874:9    875:9    884:9
                                                                    884:9    898:9    899:9    900:9
                                                                    900:9    920:9    920:9    931:9
                                                                    939:9    947:9    947:9    957:9
                                                                    979:9    979:9    991:9    991:9
                                                                   1007:9   1008:9   1022:9   1023:9
                                                                   1023:9   1039:9   1039:9   1075:9
                                                                   1075:9   1119:9   1119:9   1125:9
                                                                   1125:9   1141:9   1141:9   1163:9
                                                                   1163:9   1178:9   1189:9   1189:9
                                                                   1195:9   1195:9   1205:9   1205:9
                                                                   1216:9   1216:9   1228:9   1228:9
                                                                   1240:9   1240:9   1253:9   1253:9
                                                                    52:10    52:10    82:10    83:10
                                                                   150:10   150:10      145      145
                                                                      176      176      262      262
                                                                      502      502      667      667
                                                                      686      686      832      832
                                                                      837      837      875      876
                                                                      880      887      889      889
                                                                      895      896      899      906
                                                                      906      924      924     1376
                                                                     1376     1698     1698     1745
                                                                     1745     1763     1763     1783
                                                                     1783     1803     1803     1825
                                                                     1825     1843     1843     1859
                                                                     1859     1881     1881     1906
                                                                     1906     1931     1931     1955
                                                                     1955     1977     1977     2010
                                                                     2010     2032     2032     2054
                                                                     2054     2075     2084     2091
                                                                     2091     2097     2097     2118
                                                                     2122     2128     2128     2187
                                                                     2187     2211     2211     2230
                                                                     2230     2248     2248     2267
                                                                     2267     3262     3262     3345
                                                                     3348     3349     3349     3373
                                                                     3373     3390     3390     3407
                                                                     3407     3424     3424     3441
                                                                     3441     3458     3458     3475
                                                                     3475     3492     3492     3737
                                                                     3737     3757     3757     3779
                                                                     3779     3787     3787     3822
                                                                     3822     3897     3897     3931
                                                                     3931     3999     3999     4079
                                                                     4079     4098     4098     4116
                                                                     4116     4135     4135     4153
                                                                     4153     4171     4171     4189
                                                                     4189     4209     4209     4229
                                                                     4229     4249     4249     4502
                                                                     4502     4561     4561     4584
                                                                     4584     4786     4786     4841
                                                                     4852     4857     4857     4885
                                                                     4890     4902     4902     4907
                                                                     4907     4986     4986     5002
                                                                     5002     5023     5023     5044
                                                                     5044   119:14   119:14   233:14
                                                                   234:14   243:14   244:14   248:14
                                                                   248:14   265:14   266:14   277:14
                                                                   278:14   282:14   282:14   308:14
                                                                   309:14   313:14   313:14     5398
                                                                     5398     5457     5457     5665
                                                                     5665
y                    #define, value: r4, line:      19:5      815:9    816:9    829:9    830:9
                                                                    862:9    863:9    934:9    936:9
                                                                    941:9    941:9   1008:9   1009:9
                                                                   1020:9   1021:9   1128:9   1131:9
                                                                   1134:9   1140:9    24:10    28:10
                                                                    34:10    38:10      185      193
                                                                      218      219      237      238
                                                                     5429     5432     5452     5653
                                                                     5654     5655     5656     5658
                                                                     5659     5660     5661     5663
                                                                     5664
{                    DELIMITER 
|                    OPERATOR 
||                   OPERATOR 
}                    DELIMITER 
~                    OPERATOR 
EOF                  DELIMITER 

Segment             Type 	Mode
----------------------------------------
.text               CONST  	REL 
FISH_Ram_MemMap     DATA  	REL 
__EXTERNS           CODE  	ABS Org:0 

Label               Mode   Type                   Segment    Value/Offset
------------------------------------------------------------------------------
??DUMMY_SYMBOL_IN_BACKEND_PARSED_OPERANDS
                    ABS    CONST UNTYP.           ASEG       1267 
ABORT               REL    CONST UNTYP.           .text      C 
ABORT_NFA           REL    CONST UNTYP.           .text      0 
ABORT_QUIT          REL    CONST UNTYP.           .text      48 
ABS                 REL    CONST UNTYP.           .text      8 
ABS1_NFA            REL    CONST UNTYP.           .text      0 
AD0CR               ABS    CONST UNTYP.           ASEG       4001C000 
AD0DR0              ABS    CONST UNTYP.           ASEG       4001C010 
AD0DR1              ABS    CONST UNTYP.           ASEG       4001C014 
AD0DR2              ABS    CONST UNTYP.           ASEG       4001C018 
AD0DR3              ABS    CONST UNTYP.           ASEG       4001C01C 
AD0DR4              ABS    CONST UNTYP.           ASEG       4001C020 
AD0DR5              ABS    CONST UNTYP.           ASEG       4001C024 
AD0DR6              ABS    CONST UNTYP.           ASEG       4001C028 
AD0DR7              ABS    CONST UNTYP.           ASEG       4001C02C 
AD0GDR              ABS    CONST UNTYP.           ASEG       4001C004 
AD0INTEN            ABS    CONST UNTYP.           ASEG       4001C00C 
AD0STAT             ABS    CONST UNTYP.           ASEG       4001C030 
AGAIN               REL    CONST UNTYP.           .text      C 
AGAIN_NFA           REL    CONST UNTYP.           .text      0 
AIRCR               ABS    CONST UNTYP.           ASEG       E000ED0C 
ALIGN32_FF_PAD      REL    CONST UNTYP.           .text      C 
ALIGNED             REL    CONST UNTYP.           .text      C 
ALIGNED_NFA         REL    CONST UNTYP.           .text      0 
ALIGN_NFA           REL    CONST UNTYP.           .text      0 
ALIGN_PAD_DO        REL    CONST UNTYP.           .text      2C 
ALLOT               REL    CONST UNTYP.           .text      C 
ALLOTOK             REL    CONST UNTYP.           .text      2C 
ALLOT_NFA           REL    CONST UNTYP.           .text      0 
ALLOT_PRIM          REL    CONST UNTYP.           .text      AC 
ALL_UNINITRAM_END   ABS    CONST UNTYP.           ASEG       10000EEC 
ALL_UNINITRAM_FREE_STARTABS    CONST UNTYP.           ASEG       10000D48 
ALL_UNINITRAM_START ABS    CONST UNTYP.           ASEG       10000D40 
ANDBITS             REL    CONST UNTYP.           .text      C 
ANDBITS_NFA         REL    CONST UNTYP.           .text      0 
ANDD                REL    CONST UNTYP.           .text      8 
ANDD_NFA            REL    CONST UNTYP.           .text      0 
APCONT              REL    CONST UNTYP.           .text      70 
APDONE              REL    CONST UNTYP.           .text      C4 
APGOOD              REL    CONST UNTYP.           .text      98 
APNEXT              REL    CONST UNTYP.           .text      1C 
ASM_ENTRY_1         REL    CONST UNTYP.           .text      10 
ASM_EXIT_1          REL    CONST UNTYP.           .text      0 
ASM_NOOP_1          REL    CONST UNTYP.           .text      14 
ASM_NOOP_2          REL    CONST UNTYP.           .text      0 
ASR                 REL    CONST UNTYP.           .text      8 
ASR_NFA             REL    CONST UNTYP.           .text      0 
ASSUREPAGE          REL    CONST UNTYP.           .text      0 
AT                  REL    CONST UNTYP.           .text      8 
AT_NFA              REL    CONST UNTYP.           .text      0 
BACK                REL    CONST UNTYP.           .text      3C0 
BACKSLASH           REL    CONST UNTYP.           .text      8 
BACKSLASH_NFA       REL    CONST UNTYP.           .text      0 
BACKSPACE_CHAR      REL    CONST UNTYP.           .text      14 
BASE_FROM_R12       REL    CONST UNTYP.           .text      0 
BASE_NFA            REL    CONST UNTYP.           .text      0 
BASE_RESET_THEN_ERRORREL    CONST UNTYP.           .text      C4 
BASE_SV             REL    CONST UNTYP.           .text      C 
BASE_TO_R12         REL    CONST UNTYP.           .text      0 
BAUD1               REL    CONST UNTYP.           .text      50 
BAUDDEFAULT         REL    CONST UNTYP.           .text      44 
BCOMP               REL    CONST UNTYP.           .text      10 
BCOMP_NFA           REL    CONST UNTYP.           .text      0 
BDIGS               REL    CONST UNTYP.           .text      8 
BDIGS_NFA           REL    CONST UNTYP.           .text      0 
BEGIN               REL    CONST UNTYP.           .text      C 
BEGIN_NFA           REL    CONST UNTYP.           .text      0 
BELL                REL    CONST UNTYP.           .text      0 
BIN                 REL    CONST UNTYP.           .text      8 
BIN_NFA             REL    CONST UNTYP.           .text      0 
BLANK               REL    CONST UNTYP.           .text      8 
BLANKS              REL    CONST UNTYP.           .text      C 
BLANKS_NFA          REL    CONST UNTYP.           .text      0 
BLANK_NFA           REL    CONST UNTYP.           .text      0 
BODCTRL             ABS    CONST UNTYP.           ASEG       40048150 
BOTTOM_RSTACK       ABS    CONST UNTYP.           ASEG       10000EF0 
BP1_ERROR           REL    CONST UNTYP.           .text      78 
BP1_QUIT            REL    CONST UNTYP.           .text      3A8 
BRAN                REL    CONST UNTYP.           .text      0 
BRAN1               REL    CONST UNTYP.           .text      1 
BSOUT               REL    CONST UNTYP.           .text      1C 
BUILDS              REL    CONST UNTYP.           .text      C 
BUILDS_NFA          REL    CONST UNTYP.           .text      0 
BYE                 REL    CONST UNTYP.           .text      8 
BYE_NFA             REL    CONST UNTYP.           .text      0 
CAT                 REL    CONST UNTYP.           .text      8 
CATLT7F             REL    CONST UNTYP.           .text      0 
CAT_NFA             REL    CONST UNTYP.           .text      0 
CCOMMA              REL    CONST UNTYP.           .text      8 
CCOMMA_NFA          REL    CONST UNTYP.           .text      0 
CCOMMA_OK           REL    CONST UNTYP.           .text      20 
CCR                 ABS    CONST UNTYP.           ASEG       E000ED14 
CFA                 REL    CONST UNTYP.           .text      8 
CFA_CREATE_DOES_GOTOREL    CONST UNTYP.           .text      14 
CFA_LIT             REL    CONST UNTYP.           .text      A0 
CFA_NFA             REL    CONST UNTYP.           .text      0 
CFA_PDOTQ           REL    CONST UNTYP.           .text      C0 
CFA_SEMIS           REL    CONST UNTYP.           .text      F8 
CHECKPAGE           REL    CONST UNTYP.           .text      AC 
CLKOUTCLKDIV        ABS    CONST UNTYP.           ASEG       400480E8 
CLKOUTCLKSEL        ABS    CONST UNTYP.           ASEG       400480E0 
CLKOUTDIV           ABS    CONST UNTYP.           ASEG       400480E8 
CLKOUTUEN           ABS    CONST UNTYP.           ASEG       400480E4 
CLRBITS             REL    CONST UNTYP.           .text      C 
CLRBITS_NFA         REL    CONST UNTYP.           .text      0 
CLRENA0             ABS    CONST UNTYP.           ASEG       E000E180 
CLRPEND0            ABS    CONST UNTYP.           ASEG       E000E280 
CLRSUFFIX           REL    CONST UNTYP.           .text      45 
CLS                 REL    CONST UNTYP.           .text      8 
CLS_NFA             REL    CONST UNTYP.           .text      0 
CM1                 REL    CONST UNTYP.           .text      11 
CM2                 REL    CONST UNTYP.           .text      21 
CMOVE               REL    CONST UNTYP.           .text      C 
CMOVE_NFA           REL    CONST UNTYP.           .text      0 
CMSIS_DISABLE_IRQS  REL    CONST UNTYP.           .text      14 
CMSIS_ENABLE_IRQS   REL    CONST UNTYP.           .text      10 
COLD                REL    CONST UNTYP.           .text      C 
COLD_NFA            REL    CONST UNTYP.           .text      0 
COLON               REL    CONST UNTYP.           .text      8 
COLON_NFA           REL    CONST UNTYP.           .text      0 
COMMA               REL    CONST UNTYP.           .text      8 
COMMA_NFA           REL    CONST UNTYP.           .text      0 
COMMA_OK            REL    CONST UNTYP.           .text      20 
COMMA_PRIM          REL    CONST UNTYP.           .text      BC 
COMP                REL    CONST UNTYP.           .text      240 
CON                 REL    CONST UNTYP.           .text      8 
CONSTANT            REL    CONST UNTYP.           .text      10 
CONSTANT_NFA        REL    CONST UNTYP.           .text      0 
CON_NFA             REL    CONST UNTYP.           .text      0 
COUNT               REL    CONST UNTYP.           .text      C 
COUNT_NFA           REL    CONST UNTYP.           .text      0 
CO_END              REL    CONST UNTYP.           .text      C4 
CPUID               ABS    CONST UNTYP.           ASEG       E000ED00 
CPUIDBR             ABS    CONST UNTYP.           ASEG       E000ED00 
CR                  REL    CONST UNTYP.           .text      8 
CREA1               REL    CONST UNTYP.           .text      5C 
CREATE              REL    CONST UNTYP.           .text      C 
CREATED_OK          REL    CONST UNTYP.           .text      74 
CREATEOK            REL    CONST UNTYP.           .text      30 
CREATE_DOES_GOTO    REL    CONST UNTYP.           .text      B 
CREATE_NFA          REL    CONST UNTYP.           .text      0 
CRS                 REL    CONST UNTYP.           .text      8 
CRS_BEGIN           REL    CONST UNTYP.           .text      14 
CRS_NFA             REL    CONST UNTYP.           .text      0 
CR_CHECK            REL    CONST UNTYP.           .text      13 
CR_NFA              REL    CONST UNTYP.           .text      0 
CSDP                REL    CONST UNTYP.           FISH_Ram_M B80 
CSDP_SV             REL    CONST UNTYP.           .text      3E8 
CSP                 REL    CONST UNTYP.           FISH_Ram_M B94 
CSP_SV              REL    CONST UNTYP.           .text      84 
CSTATE              REL    CONST UNTYP.           FISH_Ram_M B68 
CSTORE              REL    CONST UNTYP.           .text      8 
CSTORE_NFA          REL    CONST UNTYP.           .text      0 
CURRENT             REL    CONST UNTYP.           FISH_Ram_M B88 
CURRENT_NFA         REL    CONST UNTYP.           .text      0 
CURRENT_SV          REL    CONST UNTYP.           .text      C 
CWPJR02_at_gmail_dot_comABS    CONST UNTYP.           ASEG       1 
C_CMSIS_DISABLE_IRQSABS    CONST EXT [000] UNTYP. __EXTERNS  Solved Extern 
C_CMSIS_ENABLE_IRQS ABS    CONST EXT [002] UNTYP. __EXTERNS  Solved Extern 
DABS                REL    CONST UNTYP.           .text      C 
DABSF               REL    CONST UNTYP.           .text      C 
DABS_NFA            REL    CONST UNTYP.           .text      0 
DBASE               REL    CONST UNTYP.           .text      C 
DBASEDONE           REL    CONST UNTYP.           .text      68 
DBASE_NFA           REL    CONST UNTYP.           .text      0 
DBAUDADDR           ABS    CONST UNTYP.           ASEG       10000D40 
DBSUSEDOT           REL    CONST UNTYP.           .text      80 
DBSUSEDUDOT         REL    CONST UNTYP.           .text      7C 
DBUSEDUDOT          REL    CONST UNTYP.           .text      64 
DDOT                REL    CONST UNTYP.           .text      8 
DDOTR               REL    CONST UNTYP.           .text      8 
DDOTR_NFA           REL    CONST UNTYP.           .text      0 
DDOT_NFA            REL    CONST UNTYP.           .text      0 
DDUP1               REL    CONST UNTYP.           .text      20 
DDUP_NFA            REL    CONST UNTYP.           .text      0 
DECIMAL             REL    CONST UNTYP.           .text      C 
DECIMAL_NFA         REL    CONST UNTYP.           .text      0 
DEC_OR_HEX          REL    CONST UNTYP.           .text      98 
DEFAULT_BASE        ABS    CONST UNTYP.           ASEG       A 
DEFAULT_BAUD        ABS    CONST UNTYP.           ASEG       2580 
DELAY               REL    CONST UNTYP.           .text      C 
DELAY_DONE          REL    CONST UNTYP.           .text      2B 
DELAY_LOOP          REL    CONST UNTYP.           .text      25 
DELAY_NFA           REL    CONST UNTYP.           .text      0 
DEVICE_ID           ABS    CONST UNTYP.           ASEG       400483F4 
DEVICE_ID_81x       ABS    CONST UNTYP.           ASEG       400483F8 
DFIND               REL    CONST UNTYP.           .text      224 
DICTFULL_ABORT      REL    CONST UNTYP.           .text      94 
DICTSPACE           REL    CONST UNTYP.           .text      0 
DICTSPACE_END       REL    CONST UNTYP.           FISH_Ram_M A38 
DICTSPACE_START     REL    CONST UNTYP.           FISH_Ram_M 10 
DIG                 REL    CONST UNTYP.           .text      8 
DIG1                REL    CONST UNTYP.           .text      40 
DIGI1               REL    CONST UNTYP.           .text      17 
DIGI2               REL    CONST UNTYP.           .text      2D 
DIGIT               REL    CONST UNTYP.           .text      C 
DIGIT_NFA           REL    CONST UNTYP.           .text      0 
DIGS                REL    CONST UNTYP.           .text      8 
DIGS1               REL    CONST UNTYP.           .text      C 
DIGS_NFA            REL    CONST UNTYP.           .text      0 
DIG_NFA             REL    CONST UNTYP.           .text      0 
DIR0                ABS    CONST UNTYP.           ASEG       A0002000 
DLIT1               REL    CONST UNTYP.           .text      30 
DLITERAL            REL    CONST UNTYP.           .text      10 
DLITERAL_NFA        REL    CONST UNTYP.           .text      0 
DLL                 REL    CONST UNTYP.           .text      BC 
DLM                 REL    CONST UNTYP.           .text      B0 
DNEGATE             REL    CONST UNTYP.           .text      C 
DNEGATE_NFA         REL    CONST UNTYP.           .text      0 
DO                  REL    CONST UNTYP.           .text      8 
DOCOL               REL    CONST UNTYP.           .text      1 
DOCOL_ISR           REL    CONST UNTYP.           .text      1 
DOCON               REL    CONST UNTYP.           .text      1 
DOES                REL    CONST UNTYP.           .text      C 
DOES_NFA            REL    CONST UNTYP.           .text      0 
DOT                 REL    CONST UNTYP.           .text      8 
DOTBASE             REL    CONST UNTYP.           .text      30 
DOTBIN              REL    CONST UNTYP.           .text      8 
DOTBIN_NFA          REL    CONST UNTYP.           .text      0 
DOTDEC              REL    CONST UNTYP.           .text      8 
DOTDEC_NFA          REL    CONST UNTYP.           .text      0 
DOTDICTSPACE        REL    CONST UNTYP.           .text      8 
DOTDICTSPACE_NFA    REL    CONST UNTYP.           .text      0 
DOTHEX              REL    CONST UNTYP.           .text      8 
DOTHEX_NFA          REL    CONST UNTYP.           .text      0 
DOTQ                REL    CONST UNTYP.           .text      8 
DOTQ1               REL    CONST UNTYP.           .text      4C 
DOTQ2               REL    CONST UNTYP.           .text      5C 
DOTQ_NFA            REL    CONST UNTYP.           .text      0 
DOTR                REL    CONST UNTYP.           .text      8 
DOTRU               REL    CONST UNTYP.           .text      8 
DOTRU_NFA           REL    CONST UNTYP.           .text      0 
DOTR_NFA            REL    CONST UNTYP.           .text      0 
DOTS                REL    CONST UNTYP.           .text      8 
DOTSBASE            REL    CONST UNTYP.           .text      48 
DOTSBIN             REL    CONST UNTYP.           .text      8 
DOTSBIN_NFA         REL    CONST UNTYP.           .text      0 
DOTSDEC             REL    CONST UNTYP.           .text      8 
DOTSDEC_NFA         REL    CONST UNTYP.           .text      0 
DOTSEND             REL    CONST UNTYP.           .text      90 
DOTSHEX             REL    CONST UNTYP.           .text      8 
DOTSHEX_NFA         REL    CONST UNTYP.           .text      0 
DOTSLOOP            REL    CONST UNTYP.           .text      4C 
DOTS_NFA            REL    CONST UNTYP.           .text      0 
DOTVARSPACE         REL    CONST UNTYP.           .text      8 
DOTVARSPACE_NFA     REL    CONST UNTYP.           .text      0 
DOT_BASE_SUFFIX     REL    CONST UNTYP.           .text      0 
DOT_NFA             REL    CONST UNTYP.           .text      0 
DOVAR               REL    CONST UNTYP.           .text      1 
DO_NFA              REL    CONST UNTYP.           .text      0 
DP                  REL    CONST UNTYP.           FISH_Ram_M B7C 
DPLUS               REL    CONST UNTYP.           .text      8 
DPLUS_NFA           REL    CONST UNTYP.           .text      0 
DPL_NFA             REL    CONST UNTYP.           .text      0 
DPL_RESET           REL    CONST UNTYP.           .text      B4 
DPL_SV              REL    CONST UNTYP.           .text      8 
DPL_ZERO_INCR       REL    CONST UNTYP.           .text      D8 
DPM                 REL    CONST UNTYP.           .text      408 
DPM1                REL    CONST UNTYP.           .text      41C 
DP_NFA              REL    CONST UNTYP.           .text      0 
DP_SV               REL    CONST UNTYP.           .text      8 
DROP                REL    CONST UNTYP.           .text      C 
DROP_NFA            REL    CONST UNTYP.           .text      0 
DUMP                REL    CONST UNTYP.           .text      C 
DUMP_ADDR_LINE      REL    CONST UNTYP.           .text      28 
DUMP_CONT           REL    CONST UNTYP.           .text      78 
DUMP_EACH_LOC       REL    CONST UNTYP.           .text      48 
DUMP_NFA            REL    CONST UNTYP.           .text      0 
DUP                 REL    CONST UNTYP.           .text      8 
DUP_NFA             REL    CONST UNTYP.           .text      0 
DZERO               REL    CONST UNTYP.           .text      2B 
EDIGS               REL    CONST UNTYP.           .text      8 
EDIGS_NFA           REL    CONST UNTYP.           .text      0 
EHOFF               REL    CONST UNTYP.           .text      C 
EHOFF_NFA           REL    CONST UNTYP.           .text      0 
EHON                REL    CONST UNTYP.           .text      C 
EHON_NFA            REL    CONST UNTYP.           .text      0 
EIGHT               REL    CONST UNTYP.           .text      14 
EL1                 REL    CONST UNTYP.           .text      54 
ELSE                REL    CONST UNTYP.           .text      C 
ELSE_NFA            REL    CONST UNTYP.           .text      0 
EMIT                REL    CONST UNTYP.           .text      C 
EMIT_NFA            REL    CONST UNTYP.           .text      0 
ENCL                REL    CONST UNTYP.           .text      C 
ENCL1               REL    CONST UNTYP.           .text      D 
ENCL2               REL    CONST UNTYP.           .text      31 
ENCL3               REL    CONST UNTYP.           .text      3F 
ENCL4               REL    CONST UNTYP.           .text      3F 
ENCL_NFA            REL    CONST UNTYP.           .text      0 
ENDIF               REL    CONST UNTYP.           .text      C 
ENDIF_NFA           REL    CONST UNTYP.           .text      0 
END_RAMVARSPACE_SV_STARTREL    CONST UNTYP.           FISH_Ram_M B5C 
EOL_SEND_XOFF       REL    CONST UNTYP.           .text      19 
EQUAL               REL    CONST UNTYP.           .text      8 
EQUAL_NFA           REL    CONST UNTYP.           .text      0 
EQUAL_TRUE          REL    CONST UNTYP.           .text      19 
ERASE               REL    CONST UNTYP.           .text      C 
ERASE_NFA           REL    CONST UNTYP.           .text      0 
ERROR               REL    CONST UNTYP.           .text      C 
ERROR_FIXUP         REL    CONST UNTYP.           .text      48 
ERROR_HALT          REL    CONST UNTYP.           FISH_Ram_M B90 
ERROR_NFA           REL    CONST UNTYP.           .text      0 
EXEC                REL    CONST UNTYP.           .text      C 
EXEC_NFA            REL    CONST UNTYP.           .text      0 
EXPE1               REL    CONST UNTYP.           .text      2C 
EXPE2               REL    CONST UNTYP.           .text      D8 
EXPE3               REL    CONST UNTYP.           .text      124 
EXPE33              REL    CONST UNTYP.           .text      128 
EXPE4               REL    CONST UNTYP.           .text      108 
EXPE5               REL    CONST UNTYP.           .text      10C 
EXPE6               REL    CONST UNTYP.           .text      BC 
EXPE7               REL    CONST UNTYP.           .text      D0 
EXPECT              REL    CONST UNTYP.           .text      C 
EXPECT_NFA          REL    CONST UNTYP.           .text      0 
FENCE               REL    CONST UNTYP.           FISH_Ram_M B84 
FENCE_NFA           REL    CONST UNTYP.           .text      0 
FENCE_SV            REL    CONST UNTYP.           .text      C 
FEND                REL    CONST UNTYP.           .text      1B 
FFDONE              REL    CONST UNTYP.           .text      A8 
FF_FINISH           REL    CONST UNTYP.           .text      70 
FF_LOOP             REL    CONST UNTYP.           .text      28 
FILL                REL    CONST UNTYP.           .text      C 
FILL_NFA            REL    CONST UNTYP.           .text      0 
FISH                REL    CONST UNTYP.           .text      C 
FISH_Author_Clyde_W_Phillips_JrABS    CONST UNTYP.           ASEG       1 
FISH_Copyright_2014_2015ABS    CONST UNTYP.           ASEG       1 
FISH_FUNDING_Contributions_NEEDED
                    ABS    CONST UNTYP.           ASEG       1 
FISH_NFA            REL    CONST UNTYP.           .text      0 
FISH_ONLY           REL    CONST UNTYP.           .text      10 
FISH_ONLY_NFA       REL    CONST UNTYP.           .text      0 
FISH_Questions_WelcomeABS    CONST UNTYP.           ASEG       1 
FISH_Team_A_Team_ForthABS    CONST UNTYP.           ASEG       1 
FLASHCFG            ABS    CONST UNTYP.           ASEG       4003C010 
FLASHCMD            REL    CONST UNTYP.           FISH_Ram_M BA0 
FLASHCRTF           REL    CONST UNTYP.           .text      0 
FLASHESEC           REL    CONST UNTYP.           .text      0 
FLASHPREP           REL    CONST UNTYP.           .text      0 
FLASHRET            REL    CONST UNTYP.           FISH_Ram_M BF0 
FLASHWRITE          REL    CONST UNTYP.           .text      0 
FLASH_FORGET        REL    CONST UNTYP.           .text      14 
FLASH_FORGET_NFA    REL    CONST UNTYP.           .text      0 
FLASH_LPAGE         ABS    CONST UNTYP.           ASEG       7000 
FLASH_PPAGE         ABS    CONST UNTYP.           ASEG       8000 
FLASH_SAVE          REL    CONST UNTYP.           .text      10 
FLASH_SAVE_NFA      REL    CONST UNTYP.           .text      0 
FLASH_SCAN          REL    CONST UNTYP.           .text      0 
FLASH_SPAGE         ABS    CONST UNTYP.           ASEG       4000 
FLASH_WR_SIZE       ABS    CONST UNTYP.           ASEG       1000 
FLOOP               REL    CONST UNTYP.           .text      13 
FLPT                REL    CONST UNTYP.           .text      44 
FLSCLP              REL    CONST UNTYP.           .text      18 
FM0_COLD            REL    CONST PUB UNTYP.       .text      1 
FM0_SYSTICK_ISR     REL    CONST PUB UNTYP.       .text      1 
FM0_WARM            REL    CONST UNTYP.           .text      0 
FMSSTART            ABS    CONST UNTYP.           ASEG       4003C020 
FMSSTOP             ABS    CONST UNTYP.           ASEG       4003C024 
FMSTAT              ABS    CONST UNTYP.           ASEG       4003CFE0 
FMSTATCLR           ABS    CONST UNTYP.           ASEG       4003CFE8 
FMSW0               ABS    CONST UNTYP.           ASEG       4003C02C 
FMSW1               ABS    CONST UNTYP.           ASEG       4003C030 
FMSW2               ABS    CONST UNTYP.           ASEG       4003C034 
FMSW3               ABS    CONST UNTYP.           ASEG       4003C038 
FORGET              REL    CONST UNTYP.           .text      C 
FORGET_NFA          REL    CONST UNTYP.           .text      0 
FOUR                REL    CONST UNTYP.           .text      8 
FOURM               REL    CONST UNTYP.           .text      8 
FOURM_NFA           REL    CONST UNTYP.           .text      0 
FOURP               REL    CONST UNTYP.           .text      8 
FOURP_NFA           REL    CONST UNTYP.           .text      0 
FOUR_NFA            REL    CONST UNTYP.           .text      0 
FPA                 REL    CONST UNTYP.           FISH_Ram_M 4 
FPADDR              REL    CONST UNTYP.           .text      0 
FPC                 REL    CONST UNTYP.           FISH_Ram_M 8 
FPCURR              REL    CONST UNTYP.           .text      0 
FPSV                REL    CONST UNTYP.           FISH_Ram_M C 
FPVAR               REL    CONST UNTYP.           .text      0 
FSAVE               REL    CONST UNTYP.           .text      84 
FSDONE              REL    CONST UNTYP.           .text      F8 
FSLASTPAGE          REL    CONST UNTYP.           .text      60 
FSNEXT              REL    CONST UNTYP.           .text      B4 
FS_BEGIN            REL    CONST UNTYP.           .text      A8 
FS_EXIT             REL    CONST UNTYP.           .text      FC 
FS_RWORD            REL    CONST UNTYP.           .text      114 
FS_WRITE            REL    CONST UNTYP.           .text      BC 
FWARM               REL    CONST UNTYP.           .text      0 
FWBEGIN             REL    CONST UNTYP.           .text      7 
GOTO                REL    CONST UNTYP.           .text      0 
GPIO0DATA           ABS    CONST UNTYP.           ASEG       50003FFC 
GPIO0DATA0          ABS    CONST UNTYP.           ASEG       50003FFC 
GPIO0DATA1          ABS    CONST UNTYP.           ASEG       50003FFD 
GPIO0DATAL          ABS    CONST UNTYP.           ASEG       50003FFC 
GPIO0DIR            ABS    CONST UNTYP.           ASEG       50008000 
GPIO0DIR0           ABS    CONST UNTYP.           ASEG       50008000 
GPIO0DIR1           ABS    CONST UNTYP.           ASEG       50008001 
GPIO0DIRL           ABS    CONST UNTYP.           ASEG       50008000 
GPIO0IBE            ABS    CONST UNTYP.           ASEG       50008008 
GPIO0IBE0           ABS    CONST UNTYP.           ASEG       50008008 
GPIO0IBE1           ABS    CONST UNTYP.           ASEG       50008009 
GPIO0IBEL           ABS    CONST UNTYP.           ASEG       50008008 
GPIO0IC             ABS    CONST UNTYP.           ASEG       5000801C 
GPIO0IE             ABS    CONST UNTYP.           ASEG       50008010 
GPIO0IE0            ABS    CONST UNTYP.           ASEG       50008010 
GPIO0IE1            ABS    CONST UNTYP.           ASEG       50008011 
GPIO0IEL            ABS    CONST UNTYP.           ASEG       50008010 
GPIO0IEV            ABS    CONST UNTYP.           ASEG       5000800C 
GPIO0IEV0           ABS    CONST UNTYP.           ASEG       5000800C 
GPIO0IEV1           ABS    CONST UNTYP.           ASEG       5000800D 
GPIO0IEVL           ABS    CONST UNTYP.           ASEG       5000800C 
GPIO0IS             ABS    CONST UNTYP.           ASEG       50008004 
GPIO0IS0            ABS    CONST UNTYP.           ASEG       50008004 
GPIO0IS1            ABS    CONST UNTYP.           ASEG       50008005 
GPIO0ISL            ABS    CONST UNTYP.           ASEG       50008004 
GPIO0MIS            ABS    CONST UNTYP.           ASEG       50008018 
GPIO0MIS0           ABS    CONST UNTYP.           ASEG       50008018 
GPIO0MIS1           ABS    CONST UNTYP.           ASEG       50008019 
GPIO0MISL           ABS    CONST UNTYP.           ASEG       50008018 
GPIO0RIS            ABS    CONST UNTYP.           ASEG       50008014 
GPIO0RIS0           ABS    CONST UNTYP.           ASEG       50008014 
GPIO0RIS1           ABS    CONST UNTYP.           ASEG       50008015 
GPIO0RISL           ABS    CONST UNTYP.           ASEG       50008014 
GPIO1DATA           ABS    CONST UNTYP.           ASEG       50013FFC 
GPIO1DATA0          ABS    CONST UNTYP.           ASEG       50013FFC 
GPIO1DATA1          ABS    CONST UNTYP.           ASEG       50013FFD 
GPIO1DATAL          ABS    CONST UNTYP.           ASEG       50013FFC 
GPIO1DIR            ABS    CONST UNTYP.           ASEG       50018000 
GPIO1DIR0           ABS    CONST UNTYP.           ASEG       50018000 
GPIO1DIR1           ABS    CONST UNTYP.           ASEG       50018001 
GPIO1DIRL           ABS    CONST UNTYP.           ASEG       50018000 
GPIO1IBE            ABS    CONST UNTYP.           ASEG       50018008 
GPIO1IBE0           ABS    CONST UNTYP.           ASEG       50018008 
GPIO1IBE1           ABS    CONST UNTYP.           ASEG       50018009 
GPIO1IBEL           ABS    CONST UNTYP.           ASEG       50018008 
GPIO1IC             ABS    CONST UNTYP.           ASEG       5001801C 
GPIO1IE             ABS    CONST UNTYP.           ASEG       50018010 
GPIO1IE0            ABS    CONST UNTYP.           ASEG       50018010 
GPIO1IE1            ABS    CONST UNTYP.           ASEG       50018011 
GPIO1IEL            ABS    CONST UNTYP.           ASEG       50018010 
GPIO1IEV            ABS    CONST UNTYP.           ASEG       5001800C 
GPIO1IEV0           ABS    CONST UNTYP.           ASEG       5001800C 
GPIO1IEV1           ABS    CONST UNTYP.           ASEG       5001800D 
GPIO1IEVL           ABS    CONST UNTYP.           ASEG       5001800C 
GPIO1IS             ABS    CONST UNTYP.           ASEG       50018004 
GPIO1IS0            ABS    CONST UNTYP.           ASEG       50018004 
GPIO1IS1            ABS    CONST UNTYP.           ASEG       50018005 
GPIO1ISL            ABS    CONST UNTYP.           ASEG       50018004 
GPIO1MIS            ABS    CONST UNTYP.           ASEG       50018018 
GPIO1MIS0           ABS    CONST UNTYP.           ASEG       50018018 
GPIO1MIS1           ABS    CONST UNTYP.           ASEG       50018019 
GPIO1MISL           ABS    CONST UNTYP.           ASEG       50018018 
GPIO1RIS            ABS    CONST UNTYP.           ASEG       50018014 
GPIO1RIS0           ABS    CONST UNTYP.           ASEG       50018014 
GPIO1RIS1           ABS    CONST UNTYP.           ASEG       50018015 
GPIO1RISL           ABS    CONST UNTYP.           ASEG       50018014 
GPIO2DATA           ABS    CONST UNTYP.           ASEG       50023FFC 
GPIO2DATA0          ABS    CONST UNTYP.           ASEG       50023FFC 
GPIO2DATA1          ABS    CONST UNTYP.           ASEG       50023FFD 
GPIO2DATAL          ABS    CONST UNTYP.           ASEG       50023FFC 
GPIO2DIR            ABS    CONST UNTYP.           ASEG       50028000 
GPIO2DIR0           ABS    CONST UNTYP.           ASEG       50028000 
GPIO2DIR1           ABS    CONST UNTYP.           ASEG       50028001 
GPIO2DIRL           ABS    CONST UNTYP.           ASEG       50028000 
GPIO2IBE            ABS    CONST UNTYP.           ASEG       50028008 
GPIO2IBE0           ABS    CONST UNTYP.           ASEG       50028008 
GPIO2IBE1           ABS    CONST UNTYP.           ASEG       50028009 
GPIO2IBEL           ABS    CONST UNTYP.           ASEG       50028008 
GPIO2IC             ABS    CONST UNTYP.           ASEG       5002801C 
GPIO2IE             ABS    CONST UNTYP.           ASEG       50028010 
GPIO2IE0            ABS    CONST UNTYP.           ASEG       50028010 
GPIO2IE1            ABS    CONST UNTYP.           ASEG       50028011 
GPIO2IEL            ABS    CONST UNTYP.           ASEG       50028010 
GPIO2IEV            ABS    CONST UNTYP.           ASEG       5002800C 
GPIO2IEV0           ABS    CONST UNTYP.           ASEG       5002800C 
GPIO2IEV1           ABS    CONST UNTYP.           ASEG       5002800D 
GPIO2IEVL           ABS    CONST UNTYP.           ASEG       5002800C 
GPIO2IS             ABS    CONST UNTYP.           ASEG       50028004 
GPIO2IS0            ABS    CONST UNTYP.           ASEG       50028004 
GPIO2IS1            ABS    CONST UNTYP.           ASEG       50028005 
GPIO2ISL            ABS    CONST UNTYP.           ASEG       50028004 
GPIO2MIS            ABS    CONST UNTYP.           ASEG       50028018 
GPIO2MIS0           ABS    CONST UNTYP.           ASEG       50028018 
GPIO2MIS1           ABS    CONST UNTYP.           ASEG       50028019 
GPIO2MISL           ABS    CONST UNTYP.           ASEG       50028018 
GPIO2RIS            ABS    CONST UNTYP.           ASEG       50028014 
GPIO2RIS0           ABS    CONST UNTYP.           ASEG       50028014 
GPIO2RIS1           ABS    CONST UNTYP.           ASEG       50028015 
GPIO2RISL           ABS    CONST UNTYP.           ASEG       50028014 
GPIO3DATA           ABS    CONST UNTYP.           ASEG       50033FFC 
GPIO3DATA0          ABS    CONST UNTYP.           ASEG       50033FFC 
GPIO3DATAL          ABS    CONST UNTYP.           ASEG       50033FFC 
GPIO3DIR            ABS    CONST UNTYP.           ASEG       50038000 
GPIO3DIR0           ABS    CONST UNTYP.           ASEG       50038000 
GPIO3DIRL           ABS    CONST UNTYP.           ASEG       50038000 
GPIO3IBE            ABS    CONST UNTYP.           ASEG       50038008 
GPIO3IBE0           ABS    CONST UNTYP.           ASEG       50038008 
GPIO3IBEL           ABS    CONST UNTYP.           ASEG       50038008 
GPIO3IC             ABS    CONST UNTYP.           ASEG       5003801C 
GPIO3IE             ABS    CONST UNTYP.           ASEG       50038010 
GPIO3IE0            ABS    CONST UNTYP.           ASEG       50038010 
GPIO3IEL            ABS    CONST UNTYP.           ASEG       50038010 
GPIO3IEV            ABS    CONST UNTYP.           ASEG       5003800C 
GPIO3IEV0           ABS    CONST UNTYP.           ASEG       5003800C 
GPIO3IEVL           ABS    CONST UNTYP.           ASEG       5003800C 
GPIO3IS             ABS    CONST UNTYP.           ASEG       50038004 
GPIO3IS0            ABS    CONST UNTYP.           ASEG       50038004 
GPIO3ISL            ABS    CONST UNTYP.           ASEG       50038004 
GPIO3MIS            ABS    CONST UNTYP.           ASEG       50038018 
GPIO3MIS0           ABS    CONST UNTYP.           ASEG       50038018 
GPIO3MISL           ABS    CONST UNTYP.           ASEG       50038018 
GPIO3RIS            ABS    CONST UNTYP.           ASEG       50038014 
GPIO3RIS0           ABS    CONST UNTYP.           ASEG       50038014 
GPIO3RISL           ABS    CONST UNTYP.           ASEG       50038014 
GPREG0              ABS    CONST UNTYP.           ASEG       40038004 
GPREG1              ABS    CONST UNTYP.           ASEG       40038008 
GPREG2              ABS    CONST UNTYP.           ASEG       4003800C 
GPREG3              ABS    CONST UNTYP.           ASEG       40038010 
GPREG4              ABS    CONST UNTYP.           ASEG       40038014 
GREATERTHAN         REL    CONST UNTYP.           .text      8 
GREATERTHAN_NFA     REL    CONST UNTYP.           .text      0 
HERE                REL    CONST UNTYP.           .text      C 
HERE_NFA            REL    CONST UNTYP.           .text      0 
HEX                 REL    CONST UNTYP.           .text      8 
HEX_NFA             REL    CONST UNTYP.           .text      0 
HLD_SV              REL    CONST UNTYP.           .text      8C 
HOLD                REL    CONST UNTYP.           .text      C 
HOLD_NFA            REL    CONST UNTYP.           .text      0 
Hz_48000000         REL    CONST UNTYP.           .text      70 
I                   REL    CONST UNTYP.           .text      8 
I2C0ADR             ABS    CONST UNTYP.           ASEG       4000000C 
I2C0ADR1            ABS    CONST UNTYP.           ASEG       40000020 
I2C0ADR2            ABS    CONST UNTYP.           ASEG       40000024 
I2C0ADR3            ABS    CONST UNTYP.           ASEG       40000028 
I2C0CONCLR          ABS    CONST UNTYP.           ASEG       40000018 
I2C0CONSET          ABS    CONST UNTYP.           ASEG       40000000 
I2C0DAT             ABS    CONST UNTYP.           ASEG       40000008 
I2C0DATABUFFER      ABS    CONST UNTYP.           ASEG       4000002C 
I2C0MASK0           ABS    CONST UNTYP.           ASEG       40000030 
I2C0MASK1           ABS    CONST UNTYP.           ASEG       40000034 
I2C0MASK2           ABS    CONST UNTYP.           ASEG       40000038 
I2C0MASK3           ABS    CONST UNTYP.           ASEG       4000003C 
I2C0MMCTRL          ABS    CONST UNTYP.           ASEG       4000001C 
I2C0SCLH            ABS    CONST UNTYP.           ASEG       40000010 
I2C0SCLL            ABS    CONST UNTYP.           ASEG       40000014 
I2C0STAT            ABS    CONST UNTYP.           ASEG       40000004 
I2CBUFFER           REL    CONST UNTYP.           FISH_Ram_M C3C 
I2CCMD              REL    CONST UNTYP.           FISH_Ram_M C30 
I2CROLE             REL    CONST UNTYP.           FISH_Ram_M C34 
I2CSTATE            REL    CONST UNTYP.           FISH_Ram_M C38 
IAPCALL             ABS    CONST UNTYP.           ASEG       1FFF1FF1 
ICER                ABS    CONST UNTYP.           ASEG       E000E180 
ICPR                ABS    CONST UNTYP.           ASEG       E000E280 
ICSR                ABS    CONST UNTYP.           ASEG       E000ED04 
IDDOT               REL    CONST UNTYP.           .text      8 
IDDOT_NFA           REL    CONST UNTYP.           .text      0 
IF                  REL    CONST UNTYP.           .text      8 
IF_EOL_SEND_XOFF    REL    CONST UNTYP.           .text      0 
IF_NFA              REL    CONST UNTYP.           .text      0 
IMMED               REL    CONST UNTYP.           .text      10 
IMMED_NFA           REL    CONST UNTYP.           .text      0 
IN                  REL    CONST UNTYP.           FISH_Ram_M B60 
INITRO              REL    CONST UNTYP.           FISH_Ram_M B70 
INITRO_SV           REL    CONST UNTYP.           .text      7C 
INITSO              REL    CONST UNTYP.           FISH_Ram_M B6C 
INITSO_SV           REL    CONST UNTYP.           .text      74 
INITTIB             REL    CONST UNTYP.           FISH_Ram_M B74 
INTE1               REL    CONST UNTYP.           .text      2C8 
INTE2               REL    CONST UNTYP.           .text      30C 
INTE3               REL    CONST UNTYP.           .text      2F8 
INTE4               REL    CONST UNTYP.           .text      300 
INTE5               REL    CONST UNTYP.           .text      340 
INTE6               REL    CONST UNTYP.           .text      334 
INTE7               REL    CONST UNTYP.           .text      33C 
INTERPRET           REL    CONST UNTYP.           .text      2C4 
IN_NFA              REL    CONST UNTYP.           .text      0 
IN_SV               REL    CONST UNTYP.           .text      8 
IOBUFSIZE           ABS    CONST UNTYP.           ASEG       60 
IOCON_DCD_LOC       ABS    CONST UNTYP.           ASEG       400440B8 
IOCON_DSR_LOC       ABS    CONST UNTYP.           ASEG       400440B4 
IOCON_PIO0_1        ABS    CONST UNTYP.           ASEG       40044010 
IOCON_PIO0_2        ABS    CONST UNTYP.           ASEG       4004401C 
IOCON_PIO0_3        ABS    CONST UNTYP.           ASEG       4004402C 
IOCON_PIO0_4        ABS    CONST UNTYP.           ASEG       40044030 
IOCON_PIO0_5        ABS    CONST UNTYP.           ASEG       40044034 
IOCON_PIO0_6        ABS    CONST UNTYP.           ASEG       4004404C 
IOCON_PIO0_7        ABS    CONST UNTYP.           ASEG       40044050 
IOCON_PIO0_8        ABS    CONST UNTYP.           ASEG       40044060 
IOCON_PIO0_9        ABS    CONST UNTYP.           ASEG       40044064 
IOCON_PIO1_10       ABS    CONST UNTYP.           ASEG       4004406C 
IOCON_PIO1_11       ABS    CONST UNTYP.           ASEG       40044098 
IOCON_PIO1_4        ABS    CONST UNTYP.           ASEG       40044094 
IOCON_PIO1_5        ABS    CONST UNTYP.           ASEG       400440A0 
IOCON_PIO1_6        ABS    CONST UNTYP.           ASEG       400440A4 
IOCON_PIO1_7        ABS    CONST UNTYP.           ASEG       400440A8 
IOCON_PIO1_8        ABS    CONST UNTYP.           ASEG       40044014 
IOCON_PIO1_9        ABS    CONST UNTYP.           ASEG       40044038 
IOCON_PIO2_0        ABS    CONST UNTYP.           ASEG       40044008 
IOCON_PIO2_1        ABS    CONST UNTYP.           ASEG       40044028 
IOCON_PIO2_10       ABS    CONST UNTYP.           ASEG       40044058 
IOCON_PIO2_11       ABS    CONST UNTYP.           ASEG       40044070 
IOCON_PIO2_2        ABS    CONST UNTYP.           ASEG       4004405C 
IOCON_PIO2_3        ABS    CONST UNTYP.           ASEG       4004408C 
IOCON_PIO2_4        ABS    CONST UNTYP.           ASEG       40044040 
IOCON_PIO2_5        ABS    CONST UNTYP.           ASEG       40044044 
IOCON_PIO2_6        ABS    CONST UNTYP.           ASEG       40044000 
IOCON_PIO2_7        ABS    CONST UNTYP.           ASEG       40044020 
IOCON_PIO2_8        ABS    CONST UNTYP.           ASEG       40044024 
IOCON_PIO2_9        ABS    CONST UNTYP.           ASEG       40044054 
IOCON_PIO3_0        ABS    CONST UNTYP.           ASEG       40044084 
IOCON_PIO3_1        ABS    CONST UNTYP.           ASEG       40044088 
IOCON_PIO3_2        ABS    CONST UNTYP.           ASEG       4004409C 
IOCON_PIO3_3        ABS    CONST UNTYP.           ASEG       400440AC 
IOCON_PIO3_4        ABS    CONST UNTYP.           ASEG       4004403C 
IOCON_PIO3_5        ABS    CONST UNTYP.           ASEG       40044048 
IOCON_RESET_PIO0_0  ABS    CONST UNTYP.           ASEG       4004400C 
IOCON_RI_LOC        ABS    CONST UNTYP.           ASEG       400440BC 
IOCON_R_PIO0_11     ABS    CONST UNTYP.           ASEG       40044074 
IOCON_R_PIO1_0      ABS    CONST UNTYP.           ASEG       40044078 
IOCON_R_PIO1_1      ABS    CONST UNTYP.           ASEG       4004407C 
IOCON_R_PIO1_2      ABS    CONST UNTYP.           ASEG       40044080 
IOCON_SCK_LOC       ABS    CONST UNTYP.           ASEG       400440B0 
IOCON_SWCLK_PIO0_10 ABS    CONST UNTYP.           ASEG       40044068 
IOCON_SWDIO_PIO1_3  ABS    CONST UNTYP.           ASEG       40044090 
IP0                 ABS    CONST UNTYP.           ASEG       E000E400 
IP1                 ABS    CONST UNTYP.           ASEG       E000E404 
IP2                 ABS    CONST UNTYP.           ASEG       E000E408 
IP3                 ABS    CONST UNTYP.           ASEG       E000E40C 
IP4                 ABS    CONST UNTYP.           ASEG       E000E410 
IP5                 ABS    CONST UNTYP.           ASEG       E000E414 
IP6                 ABS    CONST UNTYP.           ASEG       E000E418 
IP7                 ABS    CONST UNTYP.           ASEG       E000E41C 
IRCCTRL             ABS    CONST UNTYP.           ASEG       40048028 
IRQS_RESUME_NFA     REL    CONST UNTYP.           .text      0 
IRQS_SUSPEND_NFA    REL    CONST UNTYP.           .text      0 
ISER                ABS    CONST UNTYP.           ASEG       E000E100 
ISPR                ABS    CONST UNTYP.           ASEG       E000E200 
IS_BIN              REL    CONST UNTYP.           .text      84 
IS_DECIMAL          REL    CONST UNTYP.           .text      AC 
IS_HEX              REL    CONST UNTYP.           .text      BC 
I_NFA               REL    CONST UNTYP.           .text      0 
KEY                 REL    CONST UNTYP.           .text      18 
KEY_INTERPRETED_ENTRYREL    CONST UNTYP.           .text      8 
KEY_NFA             REL    CONST UNTYP.           .text      0 
LATEST              REL    CONST UNTYP.           .text      C 
LATEST_NFA          REL    CONST UNTYP.           .text      0 
LBRAC               REL    CONST UNTYP.           .text      8 
LBRAC_NFA           REL    CONST UNTYP.           .text      0 
LEAVE               REL    CONST UNTYP.           .text      C 
LEAVE_NFA           REL    CONST UNTYP.           .text      0 
LESS1               REL    CONST UNTYP.           .text      13 
LESSTHAN            REL    CONST UNTYP.           .text      8 
LESSTHAN_NFA        REL    CONST UNTYP.           .text      0 
LFA                 REL    CONST UNTYP.           .text      8 
LFA_NFA             REL    CONST UNTYP.           .text      0 
LIT                 REL    CONST UNTYP.           .text      0 
LITE1               REL    CONST UNTYP.           .text      2C 
LITERAL             REL    CONST UNTYP.           .text      C 
LITERAL_NFA         REL    CONST UNTYP.           .text      0 
LOOP                REL    CONST UNTYP.           .text      C 
LOOP_NFA            REL    CONST UNTYP.           .text      0 
LSL                 REL    CONST UNTYP.           .text      8 
LSL_NFA             REL    CONST UNTYP.           .text      0 
LSR                 REL    CONST UNTYP.           .text      8 
LSR_NFA             REL    CONST UNTYP.           .text      0 
MAINCLKSEL          ABS    CONST UNTYP.           ASEG       40048070 
MAINCLKUEN          ABS    CONST UNTYP.           ASEG       40048074 
MAX                 REL    CONST UNTYP.           .text      8 
MAX1                REL    CONST UNTYP.           .text      20 
MAXWORDLEN          ABS    CONST UNTYP.           ASEG       1F 
MAX_NFA             REL    CONST UNTYP.           .text      0 
MIN                 REL    CONST UNTYP.           .text      8 
MIN1                REL    CONST UNTYP.           .text      20 
MIN_NFA             REL    CONST UNTYP.           .text      0 
MOD                 REL    CONST UNTYP.           .text      8 
MODD_NFA            REL    CONST UNTYP.           .text      0 
MS                  REL    CONST UNTYP.           .text      8 
MSLASH              REL    CONST UNTYP.           .text      8 
MSLASH_NFA          REL    CONST UNTYP.           .text      0 
MSMOD               REL    CONST UNTYP.           .text      260 
MSTAR               REL    CONST UNTYP.           .text      8 
MSTAR_NFA           REL    CONST UNTYP.           .text      0 
MS_NFA              REL    CONST UNTYP.           .text      0 
MYBAUD              REL    CONST UNTYP.           .text      C 
MYBAUD_NFA          REL    CONST UNTYP.           .text      0 
MYWORDS             REL    CONST UNTYP.           .text      C 
MYWORDS_NFA         REL    CONST UNTYP.           .text      0 
MY_LTORG_ISR_SEMIS  REL    CONST UNTYP.           .text      4 
NBASE               REL    CONST UNTYP.           FISH_Ram_M B5C 
NDPL                REL    CONST UNTYP.           FISH_Ram_M B98 
NEGATE              REL    CONST UNTYP.           .text      C 
NEGATE_NFA          REL    CONST UNTYP.           .text      0 
NFA                 REL    CONST UNTYP.           .text      8 
NFA_ALIGN_BEGIN     REL    CONST UNTYP.           .text      14 
NFA_NFA             REL    CONST UNTYP.           .text      0 
NHLD                REL    CONST UNTYP.           FISH_Ram_M B9C 
NMISRC              ABS    CONST UNTYP.           ASEG       40048174 
NONAME_STCTR_INCR   REL    CONST UNTYP.           .text      0 
NOOP                REL    CONST UNTYP.           .text      C 
NOOP_NFA            REL    CONST UNTYP.           .text      0 
NOT                 REL    CONST UNTYP.           .text      8 
NOT_CO              REL    CONST UNTYP.           .text      6C 
NOT_CR              REL    CONST UNTYP.           .text      21 
NOT_NFA             REL    CONST UNTYP.           .text      0 
NOT_WC              REL    CONST UNTYP.           .text      E8 
NO_KEY              REL    CONST UNTYP.           .text      1F 
NSEXIT1             REL    CONST UNTYP.           .text      29 
NSLEN_DONE          REL    CONST UNTYP.           .text      F 
NSLEN_LOOP          REL    CONST UNTYP.           .text      5 
NSNOTTWO            REL    CONST UNTYP.           .text      D 
NSTWO               REL    CONST UNTYP.           .text      2F 
NULL                REL    CONST UNTYP.           .text      8 
NULLSTRLEN          REL    CONST UNTYP.           .text      C 
NULLSTRLEN_NFA      REL    CONST UNTYP.           .text      0 
NULL_NFA            REL    CONST UNTYP.           .text      0 
NUMB1               REL    CONST UNTYP.           .text      58 
NUMB2               REL    CONST UNTYP.           .text      E4 
NUMB3               REL    CONST UNTYP.           .text      F8 
NUMBER              REL    CONST UNTYP.           .text      C 
NUMBERSUFFIX        REL    CONST UNTYP.           .text      0 
NUMBER_NFA          REL    CONST UNTYP.           .text      0 
ONE                 REL    CONST UNTYP.           .text      8 
ONEM                REL    CONST UNTYP.           .text      8 
ONEM_NFA            REL    CONST UNTYP.           .text      0 
ONEP                REL    CONST UNTYP.           .text      8 
ONEP_NFA            REL    CONST UNTYP.           .text      0 
ONE_NFA             REL    CONST UNTYP.           .text      0 
OR                  REL    CONST UNTYP.           .text      8 
ORIG                REL    CONST UNTYP.           FISH_Ram_M 10 
OR_NFA              REL    CONST UNTYP.           .text      0 
OUT                 REL    CONST UNTYP.           FISH_Ram_M B64 
OUT_NFA             REL    CONST UNTYP.           .text      0 
OUT_SV              REL    CONST UNTYP.           .text      8 
OVER                REL    CONST UNTYP.           .text      C 
OVER_NFA            REL    CONST UNTYP.           .text      0 
P                   REL    CONST UNTYP.           .text      8 
PAD                 REL    CONST UNTYP.           FISH_Ram_M A38 
PAD_NFA             REL    CONST UNTYP.           .text      0 
PAD_SV              REL    CONST UNTYP.           .text      8 
PAREN               REL    CONST UNTYP.           .text      8 
PAREN_ERR           REL    CONST UNTYP.           .text      58 
PAREN_NFA           REL    CONST UNTYP.           .text      0 
PCON                ABS    CONST UNTYP.           ASEG       40038000 
PDAWAKECFG          ABS    CONST UNTYP.           ASEG       40048234 
PDOTQ               REL    CONST UNTYP.           .text      154 
PDRUNCFG            ABS    CONST UNTYP.           ASEG       40048238 
PDSLEEPCFG          ABS    CONST UNTYP.           ASEG       40048230 
PE_DONE             REL    CONST UNTYP.           .text      54 
PFA                 REL    CONST UNTYP.           .text      8 
PFA_ALIGN_BEGIN     REL    CONST UNTYP.           .text      14 
PFA_NFA             REL    CONST UNTYP.           .text      0 
PFIN1               REL    CONST UNTYP.           .text      B 
PFIN2               REL    CONST UNTYP.           .text      1B 
PFIN21              REL    CONST UNTYP.           .text      2F 
PFIN5               REL    CONST UNTYP.           .text      4F 
PFIN51              REL    CONST UNTYP.           .text      51 
PFIN7               REL    CONST UNTYP.           .text      59 
PFIND               REL    CONST UNTYP.           .text      0 
PFIND_NEXT_NFA      REL    CONST UNTYP.           .text      65 
PIN0                ABS    CONST UNTYP.           ASEG       A0002100 
PINASSIGN0          ABS    CONST UNTYP.           ASEG       4000C000 
PINASSIGN1          ABS    CONST UNTYP.           ASEG       4000C004 
PINASSIGN2          ABS    CONST UNTYP.           ASEG       4000C008 
PINASSIGN3          ABS    CONST UNTYP.           ASEG       4000C00C 
PINASSIGN4          ABS    CONST UNTYP.           ASEG       4000C010 
PINASSIGN5          ABS    CONST UNTYP.           ASEG       4000C014 
PINASSIGN6          ABS    CONST UNTYP.           ASEG       4000C018 
PINASSIGN7          ABS    CONST UNTYP.           ASEG       4000C01C 
PINASSIGN8          ABS    CONST UNTYP.           ASEG       4000C020 
PINENABLE0          ABS    CONST UNTYP.           ASEG       4000C1C0 
PINIT               ABS    CONST UNTYP.           ASEG       10000FF0 
PIOPORCAP0          ABS    CONST UNTYP.           ASEG       40048100 
PIOPORCAP1          ABS    CONST UNTYP.           ASEG       40048104 
PLOOP               REL    CONST UNTYP.           .text      C 
PLOOP_NFA           REL    CONST UNTYP.           .text      0 
PLUS                REL    CONST UNTYP.           .text      8 
PLUS_NFA            REL    CONST UNTYP.           .text      0 
PM                  REL    CONST UNTYP.           .text      3F0 
PM1                 REL    CONST UNTYP.           .text      404 
PML_LOOP            REL    CONST UNTYP.           .text      C 
PNUM1               REL    CONST UNTYP.           .text      1A4 
PNUM2               REL    CONST UNTYP.           .text      21C 
PNUM3               REL    CONST UNTYP.           .text      210 
PNUMBER             REL    CONST UNTYP.           .text      1A0 
POFF                REL    CONST UNTYP.           .text      C 
POFF_NFA            REL    CONST UNTYP.           .text      0 
PON                 REL    CONST UNTYP.           .text      8 
PON_NFA             REL    CONST UNTYP.           .text      0 
PRESETCTRL          ABS    CONST UNTYP.           ASEG       40048004 
PRINT_SUFFIX        REL    CONST UNTYP.           .text      64 
PROMPT              REL    CONST UNTYP.           FISH_Ram_M B8C 
PSTORE              REL    CONST UNTYP.           .text      8 
PSTORE_NFA          REL    CONST UNTYP.           .text      0 
P_NFA               REL    CONST UNTYP.           .text      0 
QALIGNED            REL    CONST UNTYP.           .text      10 
QALIGNED_NFA        REL    CONST UNTYP.           .text      0 
QALIGN_OK           REL    CONST UNTYP.           .text      60 
QCOMP               REL    CONST UNTYP.           .text      D8 
QCSP                REL    CONST UNTYP.           .text      2A0 
QERROR              REL    CONST UNTYP.           .text      C 
QERROR_DONE         REL    CONST UNTYP.           .text      2C 
QERROR_FINISH       REL    CONST UNTYP.           .text      28 
QERROR_NFA          REL    CONST UNTYP.           .text      0 
QEXEC               REL    CONST UNTYP.           .text      F8 
QKEY                REL    CONST UNTYP.           .text      C 
QKEY_NFA            REL    CONST UNTYP.           .text      0 
QPAIR               REL    CONST UNTYP.           .text      114 
QSTACK              REL    CONST UNTYP.           .text      12C 
QUERY               REL    CONST UNTYP.           .text      17C 
QUES                REL    CONST UNTYP.           .text      8 
QUES_NFA            REL    CONST UNTYP.           .text      0 
QUIT                REL    CONST UNTYP.           .text      348 
QUIT1               REL    CONST UNTYP.           .text      354 
QUIT2               REL    CONST UNTYP.           .text      3A8 
QUIT_EOL_DLE        REL    CONST UNTYP.           .text      3A8 
R                   REL    CONST UNTYP.           .text      8 
RAMVARSPACE         REL    CONST UNTYP.           FISH_Ram_M AFC 
RAMVARSPACE_START   REL    CONST UNTYP.           FISH_Ram_M AFC 
RAMWORDS            REL    CONST UNTYP.           .text      90 
RAM_END             ABS    CONST UNTYP.           ASEG       10001000 
RAM_START           ABS    CONST UNTYP.           ASEG       10000000 
RBASE               REL    CONST UNTYP.           .text      C 
RBASE_NFA           REL    CONST UNTYP.           .text      0 
RBRAC               REL    CONST UNTYP.           .text      8 
RBRAC_NFA           REL    CONST UNTYP.           .text      0 
RELOC_THIS_WORD     REL    CONST UNTYP.           .text      118 
REPEAT              REL    CONST UNTYP.           .text      C 
REPEAT_NFA          REL    CONST UNTYP.           .text      0 
REVW                REL    CONST UNTYP.           .text      C 
REVW_NFA            REL    CONST UNTYP.           .text      0 
RFROM               REL    CONST UNTYP.           .text      8 
RFROM_NFA           REL    CONST UNTYP.           .text      0 
RINIT               ABS    CONST UNTYP.           ASEG       10000F70 
RLIT                REL    CONST UNTYP.           .text      0 
ROT                 REL    CONST UNTYP.           .text      8 
ROT_NFA             REL    CONST UNTYP.           .text      0 
RPAT                REL    CONST UNTYP.           .text      8 
RPAT_NFA            REL    CONST UNTYP.           .text      0 
RPSTO               REL    CONST UNTYP.           .text      0 
RWORD               REL    CONST UNTYP.           .text      0 
RW_BEGIN            REL    CONST UNTYP.           .text      94 
RW_DOCONVAR         REL    CONST UNTYP.           .text      54 
RW_LFA              REL    CONST UNTYP.           .text      154 
RW_UNTIL            REL    CONST UNTYP.           .text      150 
R_NFA               REL    CONST UNTYP.           .text      0 
SCR                 ABS    CONST UNTYP.           ASEG       E000ED10 
SCSP                REL    CONST UNTYP.           .text      28C 
SEMI                REL    CONST UNTYP.           .text      8 
SEMIC_CREATE        REL    CONST UNTYP.           .text      3D4 
SEMIS               REL    CONST UNTYP.           .text      0 
SEMI_NFA            REL    CONST UNTYP.           .text      0 
SETBITS             REL    CONST UNTYP.           .text      C 
SETBITS_NFA         REL    CONST UNTYP.           .text      0 
SETENA0             ABS    CONST UNTYP.           ASEG       E000E100 
SETPEND0            ABS    CONST UNTYP.           ASEG       E000E200 
SHPR2               ABS    CONST UNTYP.           ASEG       E000ED1C 
SHPR3               ABS    CONST UNTYP.           ASEG       E000ED20 
SIGN                REL    CONST UNTYP.           .text      C 
SIGN1               REL    CONST UNTYP.           .text      2C 
SIGNON              REL    CONST UNTYP.           .text      420 
SIGN_NFA            REL    CONST UNTYP.           .text      0 
SLASH               REL    CONST UNTYP.           .text      8 
SLASH_NFA           REL    CONST UNTYP.           .text      0 
SLMOD               REL    CONST UNTYP.           .text      C 
SLMOD_NFA           REL    CONST UNTYP.           .text      0 
SPACE               REL    CONST UNTYP.           .text      C 
SPACES              REL    CONST UNTYP.           .text      C 
SPACES_DO           REL    CONST UNTYP.           .text      2C 
SPACES_DONE         REL    CONST UNTYP.           .text      38 
SPACES_NFA          REL    CONST UNTYP.           .text      0 
SPACE_NFA           REL    CONST UNTYP.           .text      0 
SPAT                REL    CONST UNTYP.           .text      8 
SPAT_NFA            REL    CONST UNTYP.           .text      0 
SPSTO               REL    CONST UNTYP.           .text      0 
SSLASH              REL    CONST UNTYP.           .text      8 
SSLASH_NFA          REL    CONST UNTYP.           .text      0 
SSMOD               REL    CONST UNTYP.           .text      C 
SSMOD_NFA           REL    CONST UNTYP.           .text      0 
SSP0CLKDIV          ABS    CONST UNTYP.           ASEG       40048094 
SSP0CPSR            ABS    CONST UNTYP.           ASEG       40040010 
SSP0CR0             ABS    CONST UNTYP.           ASEG       40040000 
SSP0CR1             ABS    CONST UNTYP.           ASEG       40040004 
SSP0DR              ABS    CONST UNTYP.           ASEG       40040008 
SSP0ICR             ABS    CONST UNTYP.           ASEG       40040020 
SSP0IMSC            ABS    CONST UNTYP.           ASEG       40040014 
SSP0MIS             ABS    CONST UNTYP.           ASEG       4004001C 
SSP0RIS             ABS    CONST UNTYP.           ASEG       40040018 
SSP0SR              ABS    CONST UNTYP.           ASEG       4004000C 
SSP1CLKDIV          ABS    CONST UNTYP.           ASEG       4004809C 
SSP1CPSR            ABS    CONST UNTYP.           ASEG       40058010 
SSP1CR0             ABS    CONST UNTYP.           ASEG       40058000 
SSP1CR1             ABS    CONST UNTYP.           ASEG       40058004 
SSP1DR              ABS    CONST UNTYP.           ASEG       40058008 
SSP1ICR             ABS    CONST UNTYP.           ASEG       40058020 
SSP1IMSC            ABS    CONST UNTYP.           ASEG       40058014 
SSP1MIS             ABS    CONST UNTYP.           ASEG       4005801C 
SSP1RIS             ABS    CONST UNTYP.           ASEG       40058018 
SSP1SR              ABS    CONST UNTYP.           ASEG       4005800C 
STACKSIZE           ABS    CONST UNTYP.           ASEG       80 
STAR                REL    CONST UNTYP.           .text      8 
STARTAPRP0          ABS    CONST UNTYP.           ASEG       40048200 
STARTERP0           ABS    CONST UNTYP.           ASEG       40048204 
STARTRSRP0CLR       ABS    CONST UNTYP.           ASEG       40048208 
STARTSRP0           ABS    CONST UNTYP.           ASEG       4004820C 
STAR_NFA            REL    CONST UNTYP.           .text      0 
STATE_NFA           REL    CONST UNTYP.           .text      0 
STATE_SV            REL    CONST UNTYP.           .text      C 
STCTR               REL    CONST UNTYP.           .text      C 
STCTR_NFA           REL    CONST UNTYP.           .text      0 
STICKER             REL    CONST UNTYP.           FISH_Ram_M AF8 
STOD                REL    CONST UNTYP.           .text      C 
STOD1               REL    CONST UNTYP.           .text      D 
STOD_NFA            REL    CONST UNTYP.           .text      0 
STORE               REL    CONST UNTYP.           .text      8 
STORE_NFA           REL    CONST UNTYP.           .text      0 
STRVA               REL    CONST UNTYP.           .text      0 
SUBB                REL    CONST UNTYP.           .text      8 
SUB_CR_4_NL         REL    CONST UNTYP.           .text      7 
SUB_NFA             REL    CONST UNTYP.           .text      0 
SV_END              REL    CONST UNTYP.           FISH_Ram_M C48 
SV_INIT_VALUES      REL    CONST UNTYP.           .text      0 
SWAP                REL    CONST UNTYP.           .text      C 
SWAP_NFA            REL    CONST UNTYP.           .text      0 
SXTB                REL    CONST UNTYP.           .text      C 
SXTB_NFA            REL    CONST UNTYP.           .text      0 
SXTH                REL    CONST UNTYP.           .text      C 
SXTH_NFA            REL    CONST UNTYP.           .text      0 
SYSAHBCLKCTRL       ABS    CONST UNTYP.           ASEG       40048080 
SYSAHBCLKDIV        ABS    CONST UNTYP.           ASEG       40048078 
SYSCLK              REL    CONST UNTYP.           .text      C 
SYSCLK_NFA          REL    CONST UNTYP.           .text      0 
SYSCLOCK            REL    CONST UNTYP.           FISH_Ram_M 0 
SYSMEMREMAP         ABS    CONST UNTYP.           ASEG       40048000 
SYSOSCCTRL          ABS    CONST UNTYP.           ASEG       40048020 
SYSPLLCLKSEL        ABS    CONST UNTYP.           ASEG       40048040 
SYSPLLCLKUEN        ABS    CONST UNTYP.           ASEG       40048044 
SYSPLLCTRL          ABS    CONST UNTYP.           ASEG       40048008 
SYSPLLSTAT          ABS    CONST UNTYP.           ASEG       4004800C 
SYSRESSTAT          ABS    CONST UNTYP.           ASEG       40048030 
SYSRSTSTAT          ABS    CONST UNTYP.           ASEG       40048030 
SYSTCKCAL           ABS    CONST UNTYP.           ASEG       40048154 
SYSTEMCLOCK         ABS    CONST UNTYP.           ASEG       2DC6C00 
SYSTICKCALVR        ABS    CONST UNTYP.           ASEG       E000E01C 
SYSTICKCSR          ABS    CONST UNTYP.           ASEG       E000E010 
SYSTICKCVR          ABS    CONST UNTYP.           ASEG       E000E018 
SYSTICKRVR          ABS    CONST UNTYP.           ASEG       E000E014 
SYSTICK_IRQ_OFF     REL    CONST UNTYP.           .text      14 
SYSTICK_IRQ_OFF_NFA REL    CONST UNTYP.           .text      0 
SYSTICK_IRQ_ON      REL    CONST UNTYP.           .text      14 
SYSTICK_IRQ_ON_NFA  REL    CONST UNTYP.           .text      0 
SYST_CALIB          ABS    CONST UNTYP.           ASEG       E000E01C 
SYST_CSR            ABS    CONST UNTYP.           ASEG       E000E010 
SYST_CVR            ABS    CONST UNTYP.           ASEG       E000E018 
SYST_RVR            ABS    CONST UNTYP.           ASEG       E000E014 
SoCinit             REL    CONST UNTYP.           .text      0 
TCS_FOUND           REL    CONST UNTYP.           .text      1B 
TCS_LOOP            REL    CONST UNTYP.           .text      F 
TDUP                REL    CONST UNTYP.           .text      C 
TDUP_NFA            REL    CONST UNTYP.           .text      0 
THEN                REL    CONST UNTYP.           .text      C 
THEN_NFA            REL    CONST UNTYP.           .text      0 
THREE               REL    CONST UNTYP.           .text      8 
THREE_NFA           REL    CONST UNTYP.           .text      0 
TIB                 REL    CONST UNTYP.           FISH_Ram_M A98 
TIB_CHAR_SCAN       REL    CONST UNTYP.           .text      0 
TIB_NFA             REL    CONST UNTYP.           .text      0 
TIB_SV              REL    CONST UNTYP.           .text      8 
TICK                REL    CONST UNTYP.           .text      8 
TICK_NFA            REL    CONST UNTYP.           .text      0 
TID                 ABS    CONST UNTYP.           ASEG       4F00 
TMR16B0CCR          ABS    CONST UNTYP.           ASEG       4000C028 
TMR16B0CR0          ABS    CONST UNTYP.           ASEG       4000C02C 
TMR16B0CTCR         ABS    CONST UNTYP.           ASEG       4000C070 
TMR16B0EMR          ABS    CONST UNTYP.           ASEG       4000C03C 
TMR16B0IR           ABS    CONST UNTYP.           ASEG       4000C000 
TMR16B0MCR          ABS    CONST UNTYP.           ASEG       4000C014 
TMR16B0MR0          ABS    CONST UNTYP.           ASEG       4000C018 
TMR16B0MR1          ABS    CONST UNTYP.           ASEG       4000C01C 
TMR16B0MR2          ABS    CONST UNTYP.           ASEG       4000C020 
TMR16B0MR3          ABS    CONST UNTYP.           ASEG       4000C024 
TMR16B0PC           ABS    CONST UNTYP.           ASEG       4000C010 
TMR16B0PR           ABS    CONST UNTYP.           ASEG       4000C00C 
TMR16B0PWMC         ABS    CONST UNTYP.           ASEG       4000C074 
TMR16B0TC           ABS    CONST UNTYP.           ASEG       4000C008 
TMR16B0TCR          ABS    CONST UNTYP.           ASEG       4000C004 
TMR16B1CCR          ABS    CONST UNTYP.           ASEG       40010028 
TMR16B1CR0          ABS    CONST UNTYP.           ASEG       4001002C 
TMR16B1CTCR         ABS    CONST UNTYP.           ASEG       40010070 
TMR16B1EMR          ABS    CONST UNTYP.           ASEG       4001003C 
TMR16B1IR           ABS    CONST UNTYP.           ASEG       40010000 
TMR16B1MCR          ABS    CONST UNTYP.           ASEG       40010014 
TMR16B1MR0          ABS    CONST UNTYP.           ASEG       40010018 
TMR16B1MR1          ABS    CONST UNTYP.           ASEG       4001001C 
TMR16B1MR2          ABS    CONST UNTYP.           ASEG       40010020 
TMR16B1MR3          ABS    CONST UNTYP.           ASEG       40010024 
TMR16B1PC           ABS    CONST UNTYP.           ASEG       40010010 
TMR16B1PR           ABS    CONST UNTYP.           ASEG       4001000C 
TMR16B1PWMC         ABS    CONST UNTYP.           ASEG       40010074 
TMR16B1TC           ABS    CONST UNTYP.           ASEG       40010008 
TMR16B1TCR          ABS    CONST UNTYP.           ASEG       40010004 
TMR32B0CCR          ABS    CONST UNTYP.           ASEG       40014028 
TMR32B0CR0          ABS    CONST UNTYP.           ASEG       4001402C 
TMR32B0CTCR         ABS    CONST UNTYP.           ASEG       40014070 
TMR32B0EMR          ABS    CONST UNTYP.           ASEG       4001403C 
TMR32B0IR           ABS    CONST UNTYP.           ASEG       40014000 
TMR32B0MCR          ABS    CONST UNTYP.           ASEG       40014014 
TMR32B0MR0          ABS    CONST UNTYP.           ASEG       40014018 
TMR32B0MR1          ABS    CONST UNTYP.           ASEG       4001401C 
TMR32B0MR2          ABS    CONST UNTYP.           ASEG       40014020 
TMR32B0MR3          ABS    CONST UNTYP.           ASEG       40014024 
TMR32B0PC           ABS    CONST UNTYP.           ASEG       40014010 
TMR32B0PR           ABS    CONST UNTYP.           ASEG       4001400C 
TMR32B0PWMC         ABS    CONST UNTYP.           ASEG       40014074 
TMR32B0TC           ABS    CONST UNTYP.           ASEG       40014008 
TMR32B0TCR          ABS    CONST UNTYP.           ASEG       40014004 
TMR32B1CCR          ABS    CONST UNTYP.           ASEG       40018028 
TMR32B1CR0          ABS    CONST UNTYP.           ASEG       4001802C 
TMR32B1CTCR         ABS    CONST UNTYP.           ASEG       40018070 
TMR32B1EMR          ABS    CONST UNTYP.           ASEG       4001803C 
TMR32B1IR           ABS    CONST UNTYP.           ASEG       40018000 
TMR32B1MCR          ABS    CONST UNTYP.           ASEG       40018014 
TMR32B1MR0          ABS    CONST UNTYP.           ASEG       40018018 
TMR32B1MR1          ABS    CONST UNTYP.           ASEG       4001801C 
TMR32B1MR2          ABS    CONST UNTYP.           ASEG       40018020 
TMR32B1MR3          ABS    CONST UNTYP.           ASEG       40018024 
TMR32B1PC           ABS    CONST UNTYP.           ASEG       40018010 
TMR32B1PR           ABS    CONST UNTYP.           ASEG       4001800C 
TMR32B1PWMC         ABS    CONST UNTYP.           ASEG       40018074 
TMR32B1TC           ABS    CONST UNTYP.           ASEG       40018008 
TMR32B1TCR          ABS    CONST UNTYP.           ASEG       40018004 
TOFA                REL    CONST UNTYP.           .text      0 
TOGGLE              REL    CONST UNTYP.           .text      0 
TOR                 REL    CONST UNTYP.           .text      8 
TOR_NFA             REL    CONST UNTYP.           .text      0 
TRAVERSE            REL    CONST UNTYP.           .text      470 
TRAVERSE_BEGIN      REL    CONST UNTYP.           .text      478 
TWO                 REL    CONST UNTYP.           .text      8 
TWOP                REL    CONST UNTYP.           .text      8 
TWOP_NFA            REL    CONST UNTYP.           .text      0 
TWOSLASH            REL    CONST UNTYP.           .text      8 
TWOSLASH_NFA        REL    CONST UNTYP.           .text      0 
TWOSTAR             REL    CONST UNTYP.           .text      8 
TWOSTAR_NFA         REL    CONST UNTYP.           .text      0 
TWO_NFA             REL    CONST UNTYP.           .text      0 
TXRDY_SUBR          REL    CONST UNTYP.           .text      1 
TYPE                REL    CONST UNTYP.           .text      C 
TYPE1               REL    CONST UNTYP.           .text      4C 
TYPE2               REL    CONST UNTYP.           .text      30 
TYPE3               REL    CONST UNTYP.           .text      50 
TYPE_NFA            REL    CONST UNTYP.           .text      0 
U0ACR               ABS    CONST UNTYP.           ASEG       40008020 
U0ADRMATCH          ABS    CONST UNTYP.           ASEG       40008050 
U0DLL               ABS    CONST UNTYP.           ASEG       40008000 
U0DLM               ABS    CONST UNTYP.           ASEG       40008004 
U0FCR               ABS    CONST UNTYP.           ASEG       40008008 
U0FDR               ABS    CONST UNTYP.           ASEG       40008028 
U0IER               ABS    CONST UNTYP.           ASEG       40008004 
U0IIR               ABS    CONST UNTYP.           ASEG       40008008 
U0LCR               ABS    CONST UNTYP.           ASEG       4000800C 
U0LSR               ABS    CONST UNTYP.           ASEG       40008014 
U0MCR               ABS    CONST UNTYP.           ASEG       40008010 
U0MSR               ABS    CONST UNTYP.           ASEG       40008018 
U0RBR               ABS    CONST UNTYP.           ASEG       40008000 
U0RBRTHR            ABS    CONST UNTYP.           ASEG       40008000 
U0RS485CTRL         ABS    CONST UNTYP.           ASEG       4000804C 
U0RS485DLY          ABS    CONST UNTYP.           ASEG       40008054 
U0SCR               ABS    CONST UNTYP.           ASEG       4000801C 
U0TER               ABS    CONST UNTYP.           ASEG       40008030 
U0THR               ABS    CONST UNTYP.           ASEG       40008000 
UART0_INIT          REL    CONST UNTYP.           .text      10 
UART0_INIT_NFA      REL    CONST UNTYP.           .text      0 
UART0_LSR           REL    CONST UNTYP.           .text      10 
UART0_LSR_NFA       REL    CONST UNTYP.           .text      0 
UART0_RX            REL    CONST UNTYP.           .text      10 
UART0_RX_NFA        REL    CONST UNTYP.           .text      0 
UART0_STAT          ABS    CONST UNTYP.           ASEG       40064008 
UART0_TX            REL    CONST UNTYP.           .text      10 
UART0_TX_NFA        REL    CONST UNTYP.           .text      0 
UARTCLKDIV          ABS    CONST UNTYP.           ASEG       40048098 
UARTCLKDIV_81x      ABS    CONST UNTYP.           ASEG       40048094 
UARTFRGDIV          ABS    CONST UNTYP.           ASEG       400480F0 
UBAUDADDR           ABS    CONST UNTYP.           ASEG       10000D44 
UDOT                REL    CONST UNTYP.           .text      8 
UDOT_BASE_SUFFIX    REL    CONST UNTYP.           .text      18 
UDOT_NFA            REL    CONST UNTYP.           .text      0 
ULES1               REL    CONST UNTYP.           .text      34 
ULES2               REL    CONST UNTYP.           .text      3C 
ULESSTHAN           REL    CONST UNTYP.           .text      8 
ULESSTHAN_NFA       REL    CONST UNTYP.           .text      0 
UNTIL               REL    CONST UNTYP.           .text      C 
UNTIL_NFA           REL    CONST UNTYP.           .text      0 
UP                  REL    CONST UNTYP.           FISH_Ram_M B78 
UP_NFA              REL    CONST UNTYP.           .text      0 
UP_SV               REL    CONST UNTYP.           .text      8 
USART0_BRG          ABS    CONST UNTYP.           ASEG       40064020 
USART0_CFG          ABS    CONST UNTYP.           ASEG       40064000 
USART0_RXDAT        ABS    CONST UNTYP.           ASEG       40064014 
USART0_TXDAT        ABS    CONST UNTYP.           ASEG       4006401C 
USEBIN              REL    CONST UNTYP.           .text      3B 
USEDEC              REL    CONST UNTYP.           .text      3F 
USEHEX              REL    CONST UNTYP.           .text      43 
USLASH              REL    CONST UNTYP.           .text      0 
USTAR               REL    CONST UNTYP.           .text      0 
VALLOT_OK           REL    CONST UNTYP.           .text      48 
VARALLOT            REL    CONST UNTYP.           .text      10 
VARALLOT_NFA        REL    CONST UNTYP.           .text      0 
VARIABLE            REL    CONST UNTYP.           .text      10 
VARIABLE_NFA        REL    CONST UNTYP.           .text      0 
VARSPACE            REL    CONST UNTYP.           .text      0 
VAR_                REL    CONST UNTYP.           .text      8 
VAR_NFA             REL    CONST UNTYP.           .text      0 
VBASE               REL    CONST UNTYP.           .text      C 
VBASE_NFA           REL    CONST UNTYP.           .text      0 
VLIS1               REL    CONST UNTYP.           .text      20 
VS_RECVR_LOOP       REL    CONST UNTYP.           .text      58 
VS_RECVR_NEXT       REL    CONST UNTYP.           .text      A4 
WARM                REL    CONST UNTYP.           .text      460 
WC_COMPILE_NFA      REL    CONST UNTYP.           .text      0 
WC_CREATE_NFA       REL    CONST UNTYP.           .text      0 
WC_FISH_PubRel_NFA  REL    CONST UNTYP.           .text      0 
WC_FISH_SYS_NFA     REL    CONST UNTYP.           .text      0 
WC_IRQ_NFA          REL    CONST UNTYP.           .text      0 
WC_NUMBERS_NFA      REL    CONST UNTYP.           .text      0 
WC_RWMEMORY_NFA     REL    CONST UNTYP.           .text      0 
WC_STACK_NFA        REL    CONST UNTYP.           .text      0 
WC_UARTx_NFA        REL    CONST UNTYP.           .text      0 
WDFEED              ABS    CONST UNTYP.           ASEG       40004008 
WDMOD               ABS    CONST UNTYP.           ASEG       40004000 
WDTC                ABS    CONST UNTYP.           ASEG       40004004 
WDTCLKDIV           ABS    CONST UNTYP.           ASEG       400480D8 
WDTCLKSEL           ABS    CONST UNTYP.           ASEG       400480D0 
WDTCLKUEN           ABS    CONST UNTYP.           ASEG       400480D4 
WDTOSCCTRL          ABS    CONST UNTYP.           ASEG       40048024 
WDTV                ABS    CONST UNTYP.           ASEG       4000400C 
WENCL               REL    CONST UNTYP.           .text      28 
WHILE               REL    CONST UNTYP.           .text      C 
WHILE_NFA           REL    CONST UNTYP.           .text      0 
WORD                REL    CONST UNTYP.           .text      C 
WORD1               REL    CONST UNTYP.           .text      10 
WORD2               REL    CONST UNTYP.           .text      14 
WORD21              REL    CONST UNTYP.           .text      8C 
WORDCAT             REL    CONST UNTYP.           .text      C 
WORDCAT_NFA         REL    CONST UNTYP.           .text      0 
WORDNOTFOUND        REL    CONST UNTYP.           .text      67 
WORDS               REL    CONST UNTYP.           .text      C 
WORDS2              REL    CONST UNTYP.           .text      60 
WORDSCONT           REL    CONST UNTYP.           .text      AC 
WORDSDONE           REL    CONST UNTYP.           .text      104 
WORDS_NFA           REL    CONST UNTYP.           .text      0 
WORD_NFA            REL    CONST UNTYP.           .text      0 
WTEST               REL    CONST UNTYP.           .text      10 
XDO                 REL    CONST UNTYP.           .text      0 
XLOO1               REL    CONST UNTYP.           .text      3 
XLOO2               REL    CONST UNTYP.           .text      13 
XLOOP               REL    CONST UNTYP.           .text      0 
XOFF                REL    CONST UNTYP.           .text      C 
XOFF_CHAR           ABS    CONST UNTYP.           ASEG       13 
XOFF_NFA            REL    CONST UNTYP.           .text      0 
XOFF_SUBR           REL    CONST UNTYP.           .text      1 
XON                 REL    CONST UNTYP.           .text      8 
XON_CHAR            ABS    CONST UNTYP.           ASEG       11 
XON_NFA             REL    CONST UNTYP.           .text      0 
XON_SUBR            REL    CONST UNTYP.           .text      1 
XORR                REL    CONST UNTYP.           .text      8 
XORR_NFA            REL    CONST UNTYP.           .text      0 
XPLOOP              REL    CONST UNTYP.           .text      0 
ZBRAN               REL    CONST UNTYP.           .text      0 
ZEQU                REL    CONST UNTYP.           .text      8 
ZEQU1               REL    CONST UNTYP.           .text      D 
ZEQU_NFA            REL    CONST UNTYP.           .text      0 
ZERO                REL    CONST UNTYP.           .text      8 
ZERO_NFA            REL    CONST UNTYP.           .text      0 
ZLESS               REL    CONST UNTYP.           .text      8 
ZLESS1              REL    CONST UNTYP.           .text      F 
ZLESS_NFA           REL    CONST UNTYP.           .text      0 
ZNDUP               REL    CONST UNTYP.           .text      C 
__lab0              REL    CONST UNTYP.           .text      80 
__lab1              REL    CONST UNTYP.           .text      A8 
__lab10             REL    CONST UNTYP.           .text      308 
__lab100            REL    CONST UNTYP.           .text      48 
__lab101            REL    CONST UNTYP.           .text      78 
__lab102            REL    CONST UNTYP.           .text      AC 
__lab103            REL    CONST UNTYP.           .text      B8 
__lab104            REL    CONST UNTYP.           .text      D4 
__lab105            REL    CONST UNTYP.           .text      EC 
__lab106            REL    CONST UNTYP.           .text      104 
__lab107            REL    CONST UNTYP.           .text      12C 
__lab108            REL    CONST UNTYP.           .text      C 
__lab109            REL    CONST UNTYP.           .text      90 
__lab11             REL    CONST UNTYP.           .text      324 
__lab110            REL    CONST UNTYP.           .text      B0 
__lab111            REL    CONST UNTYP.           .text      8 
__lab112            REL    CONST UNTYP.           .text      38 
__lab113            REL    CONST UNTYP.           .text      58 
__lab114            REL    CONST UNTYP.           .text      74 
__lab115            REL    CONST UNTYP.           .text      8C 
__lab116            REL    CONST UNTYP.           .text      A4 
__lab117            REL    CONST UNTYP.           .text      BC 
__lab118            REL    CONST UNTYP.           .text      28 
__lab119            REL    CONST UNTYP.           .text      6C 
__lab12             REL    CONST UNTYP.           .text      330 
__lab120            REL    CONST UNTYP.           .text      78 
__lab121            REL    CONST UNTYP.           .text      8C 
__lab122            REL    CONST UNTYP.           .text      C 
__lab123            REL    CONST UNTYP.           .text      18 
__lab124            REL    CONST UNTYP.           .text      8 
__lab125            REL    CONST UNTYP.           .text      8 
__lab126            REL    CONST UNTYP.           .text      8 
__lab127            REL    CONST UNTYP.           .text      8 
__lab128            REL    CONST UNTYP.           .text      C 
__lab129            REL    CONST UNTYP.           .text      8 
__lab13             REL    CONST UNTYP.           .text      344 
__lab130            REL    CONST UNTYP.           .text      8 
__lab131            REL    CONST UNTYP.           .text      8 
__lab132            REL    CONST UNTYP.           .text      C 
__lab133            REL    CONST UNTYP.           .text      C 
__lab134            REL    CONST UNTYP.           .text      C 
__lab135            REL    CONST UNTYP.           .text      8 
__lab136            REL    CONST UNTYP.           .text      C 
__lab137            REL    CONST UNTYP.           .text      C 
__lab138            REL    CONST UNTYP.           .text      C 
__lab139            REL    CONST UNTYP.           .text      C 
__lab14             REL    CONST UNTYP.           .text      370 
__lab140            REL    CONST UNTYP.           .text      C 
__lab141            REL    CONST UNTYP.           .text      8 
__lab142            REL    CONST UNTYP.           .text      8 
__lab143            REL    CONST UNTYP.           .text      8 
__lab144            REL    CONST UNTYP.           .text      8 
__lab145            REL    CONST UNTYP.           .text      8 
__lab146            REL    CONST UNTYP.           .text      20 
__lab147            REL    CONST UNTYP.           .text      1C 
__lab148            REL    CONST UNTYP.           .text      1C 
__lab149            REL    CONST UNTYP.           .text      24 
__lab15             REL    CONST UNTYP.           .text      384 
__lab150            REL    CONST UNTYP.           .text      30 
__lab151            REL    CONST UNTYP.           .text      28 
__lab152            REL    CONST UNTYP.           .text      38 
__lab153            REL    CONST UNTYP.           .text      C 
__lab154            REL    CONST UNTYP.           .text      8 
__lab155            REL    CONST UNTYP.           .text      C 
__lab156            REL    CONST UNTYP.           .text      8 
__lab157            REL    CONST UNTYP.           .text      8 
__lab158            REL    CONST UNTYP.           .text      8 
__lab159            REL    CONST UNTYP.           .text      8 
__lab16             REL    CONST UNTYP.           .text      3BC 
__lab160            REL    CONST UNTYP.           .text      8 
__lab161            REL    CONST UNTYP.           .text      8 
__lab162            REL    CONST UNTYP.           .text      8 
__lab163            REL    CONST UNTYP.           .text      8 
__lab164            REL    CONST UNTYP.           .text      8 
__lab165            REL    CONST UNTYP.           .text      8 
__lab166            REL    CONST UNTYP.           .text      8 
__lab167            REL    CONST UNTYP.           .text      1C 
__lab168            REL    CONST UNTYP.           .text      30 
__lab169            REL    CONST UNTYP.           .text      8 
__lab17             REL    CONST UNTYP.           .text      3FC 
__lab170            REL    CONST UNTYP.           .text      8 
__lab171            REL    CONST UNTYP.           .text      C 
__lab172            REL    CONST UNTYP.           .text      18 
__lab173            REL    CONST UNTYP.           .text      18 
__lab174            REL    CONST UNTYP.           .text      8 
__lab175            REL    CONST UNTYP.           .text      8 
__lab176            REL    CONST UNTYP.           .text      8 
__lab177            REL    CONST UNTYP.           .text      8 
__lab178            REL    CONST UNTYP.           .text      C 
__lab179            REL    CONST UNTYP.           .text      C 
__lab18             REL    CONST UNTYP.           .text      414 
__lab180            REL    CONST UNTYP.           .text      C 
__lab181            REL    CONST UNTYP.           .text      8 
__lab182            REL    CONST UNTYP.           .text      8 
__lab183            REL    CONST UNTYP.           .text      8 
__lab184            REL    CONST UNTYP.           .text      28 
__lab185            REL    CONST UNTYP.           .text      40 
__lab186            REL    CONST UNTYP.           .text      10 
__lab187            REL    CONST UNTYP.           .text      10 
__lab188            REL    CONST UNTYP.           .text      C 
__lab189            REL    CONST UNTYP.           .text      8 
__lab19             REL    CONST UNTYP.           .text      498 
__lab190            REL    CONST UNTYP.           .text      20 
__lab191            REL    CONST UNTYP.           .text      34 
__lab192            REL    CONST UNTYP.           .text      20 
__lab193            REL    CONST UNTYP.           .text      48 
__lab194            REL    CONST UNTYP.           .text      18 
__lab195            REL    CONST UNTYP.           .text      40 
__lab196            REL    CONST UNTYP.           .text      48 
__lab197            REL    CONST UNTYP.           .text      C 
__lab198            REL    CONST UNTYP.           .text      1C 
__lab199            REL    CONST UNTYP.           .text      20 
__lab2              REL    CONST UNTYP.           .text      54 
__lab20             REL    CONST UNTYP.           .text      0 
__lab200            REL    CONST UNTYP.           .text      18 
__lab201            REL    CONST UNTYP.           .text      18 
__lab202            REL    CONST UNTYP.           .text      1C 
__lab203            REL    CONST UNTYP.           .text      C 
__lab204            REL    CONST UNTYP.           .text      2C 
__lab205            REL    CONST UNTYP.           .text      1C 
__lab206            REL    CONST UNTYP.           .text      10 
__lab207            REL    CONST UNTYP.           .text      14 
__lab208            REL    CONST UNTYP.           .text      14 
__lab209            REL    CONST UNTYP.           .text      C 
__lab21             REL    CONST UNTYP.           .text      18 
__lab210            REL    CONST UNTYP.           .text      14 
__lab211            REL    CONST UNTYP.           .text      C 
__lab212            REL    CONST UNTYP.           .text      24 
__lab213            REL    CONST UNTYP.           .text      5C 
__lab214            REL    CONST UNTYP.           .text      B8 
__lab215            REL    CONST UNTYP.           .text      120 
__lab216            REL    CONST UNTYP.           .text      0 
__lab217            REL    CONST UNTYP.           .text      18 
__lab218            REL    CONST UNTYP.           .text      1C 
__lab219            REL    CONST UNTYP.           .text      2C 
__lab22             REL    CONST UNTYP.           .text      1C 
__lab220            REL    CONST UNTYP.           .text      50 
__lab221            REL    CONST UNTYP.           .text      84 
__lab222            REL    CONST UNTYP.           .text      90 
__lab223            REL    CONST UNTYP.           .text      B0 
__lab224            REL    CONST UNTYP.           .text      BC 
__lab225            REL    CONST UNTYP.           .text      D8 
__lab226            REL    CONST UNTYP.           .text      F4 
__lab227            REL    CONST UNTYP.           .text      114 
__lab228            REL    CONST UNTYP.           .text      12C 
__lab229            REL    CONST UNTYP.           .text      14C 
__lab23             REL    CONST UNTYP.           .text      0 
__lab230            REL    CONST UNTYP.           .text      0 
__lab231            REL    CONST UNTYP.           .text      1C 
__lab232            REL    CONST UNTYP.           .text      20 
__lab233            REL    CONST UNTYP.           .text      24 
__lab234            REL    CONST UNTYP.           .text      28 
__lab235            REL    CONST UNTYP.           .text      0 
__lab236            REL    CONST UNTYP.           .text      20 
__lab237            REL    CONST UNTYP.           .text      24 
__lab238            REL    CONST UNTYP.           .text      28 
__lab239            REL    CONST UNTYP.           .text      2C 
__lab24             REL    CONST UNTYP.           .text      0 
__lab240            REL    CONST UNTYP.           .text      30 
__lab241            REL    CONST UNTYP.           .text      0 
__lab242            REL    CONST UNTYP.           .text      24 
__lab243            REL    CONST UNTYP.           .text      28 
__lab244            REL    CONST UNTYP.           .text      2C 
__lab245            REL    CONST UNTYP.           .text      30 
__lab246            REL    CONST UNTYP.           .text      34 
__lab247            REL    CONST UNTYP.           .text      38 
__lab248            REL    CONST UNTYP.           .text      3C 
__lab249            REL    CONST UNTYP.           .text      44 
__lab25             REL    CONST UNTYP.           .text      0 
__lab250            REL    CONST UNTYP.           .text      6C 
__lab251            REL    CONST UNTYP.           .text      80 
__lab252            REL    CONST UNTYP.           .text      8C 
__lab253            REL    CONST UNTYP.           .text      30 
__lab254            REL    CONST UNTYP.           .text      A8 
__lab255            REL    CONST UNTYP.           .text      D8 
__lab256            REL    CONST UNTYP.           .text      F4 
__lab257            REL    CONST UNTYP.           .text      28 
__lab258            REL    CONST UNTYP.           .text      8C 
__lab259            REL    CONST UNTYP.           .text      94 
__lab26             REL    CONST UNTYP.           .text      0 
__lab260            REL    CONST UNTYP.           .text      64 
__lab261            REL    CONST UNTYP.           .text      70 
__lab262            REL    CONST UNTYP.           .text      7C 
__lab263            REL    CONST UNTYP.           .text      20 
__lab264            REL    CONST UNTYP.           .text      48 
__lab265            REL    CONST UNTYP.           .text      50 
__lab266            REL    CONST UNTYP.           .text      C 
__lab267            REL    CONST UNTYP.           .text      10 
__lab268            REL    CONST UNTYP.           .text      C 
__lab269            REL    CONST UNTYP.           .text      34 
__lab27             REL    CONST UNTYP.           .text      0 
__lab270            REL    CONST UNTYP.           .text      38 
__lab271            REL    CONST UNTYP.           .text      3C 
__lab272            REL    CONST UNTYP.           .text      40 
__lab273            REL    CONST UNTYP.           .text      44 
__lab274            REL    CONST UNTYP.           .text      7C 
__lab275            REL    CONST UNTYP.           .text      A0 
__lab276            REL    CONST UNTYP.           .text      A8 
__lab277            REL    CONST UNTYP.           .text      D8 
__lab278            REL    CONST UNTYP.           .text      100 
__lab279            REL    CONST UNTYP.           .text      10 
__lab28             REL    CONST UNTYP.           .text      14 
__lab280            REL    CONST UNTYP.           .text      20 
__lab281            REL    CONST UNTYP.           .text      24 
__lab282            REL    CONST UNTYP.           .text      28 
__lab283            REL    CONST UNTYP.           .text      2C 
__lab284            REL    CONST UNTYP.           .text      30 
__lab285            REL    CONST UNTYP.           .text      34 
__lab286            REL    CONST UNTYP.           .text      38 
__lab287            REL    CONST UNTYP.           .text      3C 
__lab288            REL    CONST UNTYP.           .text      88 
__lab29             REL    CONST UNTYP.           .text      18 
__lab3              REL    CONST UNTYP.           .text      60 
__lab30             REL    CONST UNTYP.           .text      0 
__lab31             REL    CONST UNTYP.           .text      14 
__lab32             REL    CONST UNTYP.           .text      18 
__lab33             REL    CONST UNTYP.           .text      0 
__lab34             REL    CONST UNTYP.           .text      74 
__lab35             REL    CONST UNTYP.           .text      0 
__lab36             REL    CONST UNTYP.           .text      0 
__lab37             REL    CONST UNTYP.           .text      0 
__lab38             REL    CONST UNTYP.           .text      0 
__lab39             REL    CONST UNTYP.           .text      0 
__lab4              REL    CONST UNTYP.           .text      1C4 
__lab40             REL    CONST UNTYP.           .text      0 
__lab41             REL    CONST UNTYP.           .text      0 
__lab42             REL    CONST UNTYP.           .text      2C 
__lab43             REL    CONST UNTYP.           .text      30 
__lab44             REL    CONST UNTYP.           .text      0 
__lab45             REL    CONST UNTYP.           .text      0 
__lab46             REL    CONST UNTYP.           .text      0 
__lab47             REL    CONST UNTYP.           .text      54 
__lab48             REL    CONST UNTYP.           .text      0 
__lab49             REL    CONST UNTYP.           .text      0 
__lab5              REL    CONST UNTYP.           .text      200 
__lab50             REL    CONST UNTYP.           .text      0 
__lab51             REL    CONST UNTYP.           .text      C 
__lab52             REL    CONST UNTYP.           .text      0 
__lab53             REL    CONST UNTYP.           .text      C 
__lab54             REL    CONST UNTYP.           .text      0 
__lab55             REL    CONST UNTYP.           .text      C 
__lab56             REL    CONST UNTYP.           .text      0 
__lab57             REL    CONST UNTYP.           .text      C 
__lab58             REL    CONST UNTYP.           .text      0 
__lab59             REL    CONST UNTYP.           .text      2C 
__lab6              REL    CONST UNTYP.           .text      218 
__lab60             REL    CONST UNTYP.           .text      30 
__lab61             REL    CONST UNTYP.           .text      34 
__lab62             REL    CONST UNTYP.           .text      38 
__lab63             REL    CONST UNTYP.           .text      3C 
__lab64             REL    CONST UNTYP.           .text      40 
__lab65             REL    CONST UNTYP.           .text      44 
__lab66             REL    CONST UNTYP.           .text      4 
__lab67             REL    CONST UNTYP.           .text      14 
__lab68             REL    CONST UNTYP.           .text      C 
__lab69             REL    CONST UNTYP.           .text      C 
__lab7              REL    CONST UNTYP.           .text      2D0 
__lab70             REL    CONST UNTYP.           .text      C 
__lab71             REL    CONST UNTYP.           .text      C 
__lab72             REL    CONST UNTYP.           .text      C 
__lab73             REL    CONST UNTYP.           .text      10 
__lab74             REL    CONST UNTYP.           .text      10 
__lab75             REL    CONST UNTYP.           .text      24 
__lab76             REL    CONST UNTYP.           .text      C 
__lab77             REL    CONST UNTYP.           .text      14 
__lab78             REL    CONST UNTYP.           .text      40 
__lab79             REL    CONST UNTYP.           .text      18 
__lab8              REL    CONST UNTYP.           .text      2E4 
__lab80             REL    CONST UNTYP.           .text      18 
__lab81             REL    CONST UNTYP.           .text      30 
__lab82             REL    CONST UNTYP.           .text      8 
__lab83             REL    CONST UNTYP.           .text      8 
__lab84             REL    CONST UNTYP.           .text      30 
__lab85             REL    CONST UNTYP.           .text      30 
__lab86             REL    CONST UNTYP.           .text      24 
__lab87             REL    CONST UNTYP.           .text      18 
__lab88             REL    CONST UNTYP.           .text      24 
__lab89             REL    CONST UNTYP.           .text      C 
__lab9              REL    CONST UNTYP.           .text      2F4 
__lab90             REL    CONST UNTYP.           .text      C 
__lab91             REL    CONST UNTYP.           .text      8 
__lab92             REL    CONST UNTYP.           .text      78 
__lab93             REL    CONST UNTYP.           .text      94 
__lab94             REL    CONST UNTYP.           .text      B0 
__lab95             REL    CONST UNTYP.           .text      C0 
__lab96             REL    CONST UNTYP.           .text      E0 
__lab97             REL    CONST UNTYP.           .text      F0 
__lab98             REL    CONST UNTYP.           .text      34 
__lab99             REL    CONST UNTYP.           .text      44 
_fillRAM            REL    CONST UNTYP.           .text      7 
_fillSTACKS         REL    CONST UNTYP.           .text      13 
_wPLLlock           REL    CONST UNTYP.           .text      70 
c_32by32to64mul     ABS    CONST EXT [001] UNTYP. __EXTERNS  Solved Extern 
c_64by32div         ABS    CONST EXT [003] UNTYP. __EXTERNS  Solved Extern 
endif               REL    CONST UNTYP.           .text      3B4 
if                  REL    CONST UNTYP.           .text      3A8 
msg_CO              REL    CONST UNTYP.           .text      0 
msg_FISH            REL    CONST UNTYP.           .text      0 
msg_FISH_TIMESTAMP  REL    CONST UNTYP.           .text      5B 
msg_MY_OK           REL    CONST UNTYP.           .text      6A 
msg_RUN             REL    CONST UNTYP.           .text      0 
msg_SIGNON_DLE      REL    CONST UNTYP.           .text      68 
msg_cr              REL    CONST UNTYP.           .text      A 
msg_dictfull        REL    CONST UNTYP.           .text      8A 
msg_dictspace       REL    CONST UNTYP.           .text      1C 
msg_forget_fish     REL    CONST UNTYP.           .text      4E 
msg_forget_saved    REL    CONST UNTYP.           .text      6B 
msg_number_error    REL    CONST UNTYP.           .text      EB 
msg_paren_err       REL    CONST UNTYP.           .text      2E 
msg_qcomp           REL    CONST UNTYP.           .text      147 
msg_qexec           REL    CONST UNTYP.           .text      160 
msg_qpair           REL    CONST UNTYP.           .text      11B 
msg_qstack          REL    CONST UNTYP.           .text      103 
msg_questionmark    REL    CONST UNTYP.           .text      6 
msg_uvfull          REL    CONST UNTYP.           .text      A7 
msg_uvspace         REL    CONST UNTYP.           .text      11 
msg_word_error      REL    CONST UNTYP.           .text      DD 
msg_wordexists      REL    CONST UNTYP.           .text      C7 
rxRDY?              REL    CONST UNTYP.           .text      5 
ssNEXT1             REL    CONST UNTYP.           .text      1 
thispfa             REL    CONST UNTYP.           .text      37 
tt1                 REL    CONST UNTYP.           .text      3C 
tt2                 REL    CONST UNTYP.           .text      40 
txRDY?              REL    CONST UNTYP.           .text      5 


##############################
#           CRC:0            #
#        Errors:   0         #
#        Warnings: 0         #
#        Bytes: 18182        #
##############################



